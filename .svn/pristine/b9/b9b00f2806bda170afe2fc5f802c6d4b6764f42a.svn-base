package com.isartdigital.builder.game.manager;
import com.isartdigital.builder.game.def.BuildingDef;
import com.isartdigital.builder.game.def.BuildingSavedDef;
import com.isartdigital.builder.game.def.MapSavedDef;
import com.isartdigital.builder.game.def.PointDef;
import com.isartdigital.builder.game.def.SizeDef;
import com.isartdigital.builder.game.def.TileSavedDef;
import com.isartdigital.builder.game.sprites.Building;
import com.isartdigital.builder.game.sprites.buildings.Casino;
import com.isartdigital.builder.game.sprites.buildings.Motel;
import com.isartdigital.builder.game.sprites.buildings.RocketFactory;
import com.isartdigital.builder.game.sprites.buildings.Temple;
import com.isartdigital.builder.game.sprites.Tile;
import com.isartdigital.utils.Config;
import com.isartdigital.utils.Debug;
import com.isartdigital.utils.game.GameObject;
import com.isartdigital.utils.game.GameStage;
import com.isartdigital.utils.game.iso.IsoManager;
import com.isartdigital.utils.game.iso.IZSortable;
import com.isartdigital.utils.game.PoolableObject;
import com.isartdigital.utils.loader.GameLoader;
import haxe.Json;
import js.Browser;
import js.Lib;
import pixi.core.math.Point;


/**
 * ...
 * @author Dorian
 */
class MapManager extends Manager
{
	/**
	 * instance unique de la classe MapManager
	 */
	private static var instance: MapManager;
	
	/**
	 * Array bidimentionnel contient toutes les tiles du jeu
	 */
	public var isMapLoaded:Bool = false;
	public var tilesMap:Array<Array<TileSavedDef>>;
	public var mapSize:Int = 100;
	
	public var globalMap:Map<String, Array<Dynamic>> = new Map<String, Array<Dynamic>> ();
	//toundo
	public function get_globalMap (): Map<String, Array<Dynamic>>
	{
		return globalMap;
	}
	
	/**
	 * Retourne l'instance unique de la classe, et la crée si elle n'existait pas au préalable
	 * @return instance unique
	 */
	public static function getInstance (): MapManager {
		if (instance == null) instance = new MapManager();
		return instance;
	}
	
	
	/**
	 * constructeur privé pour éviter qu'une instance soit créée directement
	 */
	private function new() 
	{
		super();
	}
	
			
	/**
	 * Génère une nouvelle map de base si il n'y a pas de sauvegarde, sinon charge la sauvegarde
	 * @return Success ou fail
	 */
	public function generateMap():Bool {
		var map:MapSavedDef;
		
		// Récupère les données dans le localstorage OU le json de base si il trouve rien
		if (isSaveAvailable()) {
			map = cast (Json.parse(Browser.getLocalStorage().getItem("save")));
		} else {
			map = cast (GameLoader.getContent("json/basemap.json"));
		}
		
		loadMap(map);
		saveMap();
		isMapLoaded = true;
	
		/*GameStage.getInstance().getBuildingsContainer().children.sort(function (a:IZSortable, b:IZSortable):Int {
			trace(a);
			return 0;
		});*/
		//trace(Test.definition);
		
		return null;
	}
	
	
	/**
	 * Sauvegarde la map en cours
	 * @return Success ou fail
	 */
	public function saveMap():Bool {
		var mapToSave:MapSavedDef = {
			tiles: new Array(),
			buildings: new Array()
		};
		
		var tile:Tile;
		var tileSaved:TileSavedDef;
		
		var building:Building;
		var buildingSaved:BuildingSavedDef;
		
		for (i in 0...tilesMap.length) {
			for (j in 0...tilesMap[i].length) {
				tileSaved = {name:null, isBuildable:null, x:null, y:null};
				mapToSave.tiles.push(tilesMap[i][j]);				
			}
		}
		
		
		for (i in 0...Building.list.length) {
			buildingSaved = { name:null, buildingLevel:null, x:null, y:null }
			building = Building.list[i];
			
			buildingSaved.name = building.definition.name;
			buildingSaved.buildingLevel = building.buildingLevel;
			
			buildingSaved.x = Std.int(building.toModel(true).x);
			buildingSaved.y = Std.int(building.toModel(true).y);
			
			mapToSave.buildings.push(buildingSaved);
		}
		
		Browser.getLocalStorage().setItem("save", Json.stringify(mapToSave));
		
		return true;
	}
	
	
	/**
	 * Retourne le TileSavedDef correspondant ou null
	 * @param	pPoint
	 * @return TileSavedDef or null
	 */
	public function getTileInMap(pPoint:Point) : TileSavedDef
	{
		pPoint.x = Math.round(pPoint.x);
		pPoint.y = Math.round(pPoint.y);
		if (pPoint.x < 0 || pPoint.x >= tilesMap.length || pPoint.y < 0 || pPoint.y >= tilesMap[0].length)
			return null;
		
		return tilesMap[cast(pPoint.x)][cast(pPoint.y)];
	}
	
	
	/**
	 * Permet de savoir si un batiment est construisable à un endroit donnée
	 * @param	Array des tiles concerné
	 * @return
	 */
	public function isBuildable(pTiles:Array<TileSavedDef>):Bool {
		var _isBuildable:Bool = true;
		
		if (pTiles == null) return false;
		
		for (i in 0...pTiles.length) {
			if (!pTiles[i].isBuildable) {
				_isBuildable = false;
			}
		}

		return _isBuildable;
	}
	
	
	/**
	 * Récupère un tableau contenant les tiles sous une position avec une taille
	 * @param	pPosition
	 * @param	pSize
	 * @return Array de tiles ou null si l'array exède les limitation de l'array
	 */
	public function getTilesArray(pPosition:Point, pSize:SizeDef):Array<TileSavedDef> {
		var tiles:Array<TileSavedDef> = new Array<TileSavedDef>();
		var xIndex:Int;
		var yIndex:Int;
		
		for (x in 0...pSize.width) {
			for (y in 0...pSize.height) {
				xIndex = Std.int(pPosition.x) - x;
				yIndex = Std.int(pPosition.y) - y;
				
				if (isInsideGrid(xIndex, yIndex)) {
					tiles.push(tilesMap[xIndex][yIndex]);
				} else {
					return null;
				}
			}
		}
		
		return tiles;
	}
	
	
	/**
	 * Modifie la propriété isBuildable d'un array de tiles
	 * @param	Array<TileSavedDef>
	 * @param	isBuildable
	 */
	public function setTilesBuildable(tiles:Array<TileSavedDef>, _isBuildable:Bool):Void {
		for (i in 0...tiles.length) {
			tiles[i].isBuildable = _isBuildable;
		}
	}
	
	
	/**
	 * Charge la map sauvegardé
	 * @return Si le chargement de la map a réussi ou non
	 */
	private function loadMap(map:MapSavedDef):Bool {
		// Remplissage des tiles de la map dans le containeur de tiles
		var tileSaved:TileSavedDef;
		var tile:Tile;
		var tilePosition:Point;
		tilesMap = new Array();
		
		for (i in 0...map.tiles.length) {
			tileSaved = map.tiles[i];
			
			tilePosition = IsoManager.modelToIsoView(new Point(tileSaved.x, tileSaved.y));
			if (tilesMap[tileSaved.x] == null) tilesMap[tileSaved.x] = new Array();
			tilesMap[tileSaved.x][tileSaved.y] = tileSaved;
			
			//fill globalMap
			var lPosition:String = tileSaved.x + "," + tileSaved.y;
			
			if (!globalMap.exists(lPosition))
			{
				globalMap.set(lPosition, new Array<Dynamic>());
			}
			
			globalMap.get(lPosition).push(tileSaved);
		}
		
		// Remplissage des builginds de la map dans le containeur de builginds
		var buildingSaved:BuildingSavedDef;
		var buildingDef:BuildingDef;
		var buildingPosition:Point;
		var building:Building;
		
		for (i in 0...map.buildings.length) {
			buildingSaved = map.buildings[i];
			buildingPosition = IsoManager.modelToIsoView(new Point(buildingSaved.x, buildingSaved.y));
			buildingDef = Building.getBuildingDefByName(buildingSaved.name);
			

			building = Type.createInstance(Type.resolveClass("com.isartdigital.builder.game.sprites.buildings." + buildingDef.className), [buildingDef]);
			var lPosition:String = buildingSaved.x + "," + buildingSaved.y;
			
			//sécurité si le batiment n'est pas placé sur une Tile
			if (globalMap.exists(lPosition))
				globalMap.get(lPosition).push(buildingSaved);
			
			building = new Building(buildingDef);
			building.x = buildingPosition.x;
			building.y = buildingPosition.y;
			building.buildingLevel = buildingSaved.buildingLevel;
			
			GameStage.getInstance().getBuildingsContainer().addChild(building);
			building.start();
		}
		
		return true;
	}
	
	
	/**
	 * Demande si une sauvegarde est disponible ou non
	 * @return
	 */
	private function isSaveAvailable():Bool {
		var lSaveAvailable:Bool = true;	
		if (Browser.getLocalStorage().getItem("save") == null) {
			lSaveAvailable = false;
		}
		return lSaveAvailable;
	}
	
	
	/**
	 * Indique si la position est hors de la grille ou à l'interieur
	 * @return
	 */
	private function isInsideGrid(pX:Int, pY:Int):Bool {
		var lMapManager:MapManager = MapManager.getInstance();
		
		if (pX >= 0 &&
			pY >= 0 &&
			pX < lMapManager.tilesMap.length &&
			pY < lMapManager.tilesMap[0].length) {
			return true;
		}
		
		return false;
	}
	
	
	/**
	 * Affiche la position de la tile sous la souris
	 */
	public function displayTilePositionUnderMouse() {
		var lPosition:Point = IsoManager.isoViewToModel(GameManager.getInstance().mousePosition);
		
		if (Math.floor(Math.random() * 25) == 0) trace("x : " + Math.ceil(lPosition.x) + " y : " + Math.ceil(lPosition.y));
	}
	
	
	/**
	 * Hack pour forcer l'exportation des class.
	 * Mettre ici toutes les class non importer sinon cause le bug suivant : Uncaught TypeError: cl is not a function
	 */
	private function importBuildingsClass():Void {
		Motel;
		Casino;
		RocketFactory;
		Temple;
	}
}