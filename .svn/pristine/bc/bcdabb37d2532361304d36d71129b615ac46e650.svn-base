<?php
include_once('ApplicationController.class.php');

class BuildingsController extends ApplicationController
{
	public function __construct()
	{
		
	}

	public function index($params)
	{		
		$data = self::getBuildings(addslashes($params['token']));
		
		return json_encode([
			'data' => $data,
			'error' => $error != '',
			'errorCode' => -1,
			'errorMessage' => $error
		]);
	}
	
	public function collect($params)
	{
		$userId = self::getUserIdByToken(addslashes($params['token']));
		if (!$userId) return Utils::formatErrorMessage(ERROR_BAD_TOKEN, "Bad token");
		
		$building = self::getBuildingByPosition(addslashes($params['x']), addslashes($params['y']), $userId);
		
		$buildingName = self::getBuildingNameByTypeId($building['building_type_id']);
		
		if (!self::collectBuilding($building['building_id'], $buildingName, $userId))
			return Utils::formatErrorMessage(ERROR_BUILDING, "Le batiment n'est pas collectable");
		
		return ResourcesController::getResource($params);
	}
	
	public function move($params)
	{	
		$userId = self::getUserIdByToken(addslashes($params['token']));
		if (!$userId) return Utils::formatErrorMessage(ERROR_BAD_TOKEN, "Bad token");
		
		if (!self::isFreePosition(addslashes($params['x_end']), addslashes($params['y_end']), $userId))
			return Utils::formatErrorMessage(ERROR_BAD_POSITION, "Cette position est prise");
		
		$building = self::getBuildingByPosition(addslashes($params['x_start']), addslashes($params['y_start']), $userId);

		$sql = "UPDATE building_users
				SET x = " . addslashes($params['x_end']) . ",
					y = " . addslashes($params['y_end']) . ",
					updated_at = NOW() 
				WHERE user_id = " . $userId . "
					AND id = " . $building['id'];
					
		$result = $GLOBALS['app']['db']->exec($sql);
		
		$data = $result;
		
		return json_encode([
			'data' => $data,
			'error' => $error != '',
			'errorCode' => -1,
			'errorMessage' => $error
		]);
	}

	public function createMotel($params)
	{		
		$userId = self::getUserIdByToken(addslashes($params['token']));
		if (!$userId) return Utils::formatErrorMessage(ERROR_BAD_TOKEN, "Bad token");
		
		if (!self::isFreePosition(addslashes($params['x']), addslashes($params['y']), $userId))
			return Utils::formatErrorMessage(ERROR_BAD_POSITION, "Cette position est prise");
		
		if (!self::buyBuilding('motel', $userId)) 
			return Utils::formatErrorMessage(ERROR_NO_MONEY, "Not enough gold");
		
		
		$color = "#FFFFFF"; //TO DO : passer en paraètre
								
		$request = $GLOBALS['app']['db']->prepare('INSERT INTO building_motel VALUES (NULL, ?)');
		$request->execute(array($color));
		
		$building_id = $GLOBALS['app']['db']->lastInsertId();

		$this->createBuilding($userId, "motel", $params, $building_id);
								
		return json_encode([
			'data' => $data,
			'error' => $error != '',
			'errorCode' => -1,
			'errorMessage' => $error
		]);
	}
	
	public function createTemple($params)
	{		
		$userId = self::getUserIdByToken(addslashes($params['token']));
		if (!$userId) return Utils::formatErrorMessage(ERROR_BAD_TOKEN, "Bad token");
		
		if (!self::isFreePosition(addslashes($params['x']), addslashes($params['y']), $userId))
			return Utils::formatErrorMessage(ERROR_BAD_POSITION, "Cette position est prise");
		
		if (!self::buyBuilding('temple', $userId)) 
			return Utils::formatErrorMessage(ERROR_NO_MONEY, "Not enough gold");
		
		$pinataReady = date("Y-m-d H:i:s");
								
		$request = $GLOBALS['app']['db']->prepare('INSERT INTO building_temple VALUES (NULL, ?)');
		$request->execute(array($pinataReady));

		$building_id = $GLOBALS['app']['db']->lastInsertId();
		
		$this->createBuilding($userId, "temple", $params, $building_id);
								
		return json_encode([
			'data' => $data,
			'error' => $error != '',
			'errorCode' => -1,
			'errorMessage' => $error
		]);
	}
	
	public function createRocketFactory ($params)
	{
		$userId = self::getUserIdByToken(addslashes($params['token']));
		if (!$userId) return Utils::formatErrorMessage(ERROR_BAD_TOKEN, "Bad token");
		
		if (!self::isFreePosition(addslashes($params['x']), addslashes($params['y']), $userId))
			return Utils::formatErrorMessage(ERROR_BAD_POSITION, "Cette position est prise");
		
		$lvl = 1;	
		
		if (!self::buyBuilding('rocket_factory', $userId, 1)) 
			return Utils::formatErrorMessage(ERROR_NO_MONEY, "Not enough gold");
		
		$date = date("Y-m-d H:i:s");
		
		$request = $GLOBALS['app']['db']->prepare('INSERT INTO building_rocket_factory VALUES (NULL, ?, ?)');
		$request->execute(array($lvl, $date));
		
		$building_id = $GLOBALS['app']['db']->lastInsertId();
		
		$this->createBuilding($userId, "rocket_factory", $params, $building_id);
		
		return json_encode([
			'data' => $data,
			'error' => $error != '',
			'errorCode' => -1,
			'errorMessage' => $error
		]);
	}

	public function destroy($params)
	{
		$userId = self::getUserIdByToken(addslashes($params['token']));
	
		$building = self::getBuildingByPosition($params['x'], $params['y'], $userId);

		$buildingName = self::getBuildingNameByTypeId($building['building_type_id']);
		$tableName = "building_" . $buildingName;
		
		$request = $GLOBALS['app']['db']->prepare('DELETE FROM ' . $tableName . ' WHERE id="' . $building['building_id'] . '";');
        $request->execute();

		$request = $GLOBALS['app']['db']->prepare('DELETE FROM building_users WHERE id="' . $building['id'] . '";');
        $request->execute();

		return json_encode([
            'data' => 'success',
            'error' => false,
            'errorCode' => -1,
            'errorMessage' => ''
        ]);
	}

	/**
	 * Récupère la liste des buildings
	 * @paran token Token de l'utilisateur
	 */
	public static function getBuildings($token) {
		$userId = self::getUserIdByToken($token);

		//TO DO return aussi les paramètre spécifique a cahque batiment
		
		if (!$userId) return Utils::formatErrorMessage(ERROR_BAD_TOKEN, "Bad token");
		
		$data;
		$error;
		
		$sql = "SELECT b_t.building_name as name, b_u.x, b_u.y, b_u.construct_end
				FROM building_users AS b_u
				INNER JOIN building_type AS b_t
					ON b_u.building_type_id = b_t.id
				WHERE b_u.user_id = " . $userId;
				
		$result = $GLOBALS['app']['db']->fetchAll($sql);
		return $result;
	}
	
	private function createBuilding($userId, $buildingName, $params, $building_id)
	{
		$building_type_id = self::getBuildingTypeIdByName($buildingName);
		
		$date = date("Y-m-d H:i:s");
		
		$constructTime = self::getConstructTime($buildingName);
		$construct_end = date("Y-m-d H:i:s", strtotime("+" . $constructTime . " hour", strtotime($date)));
		
		$request = $GLOBALS['app']['db']->prepare('INSERT INTO building_users VALUES (NULL, ?, ?, ?, ?, ?, ?, ?, ?)');
		$request->execute(array($userId, 
								$date, 
								$date, 
								$building_type_id, 
								$building_id, 
								addslashes($params['x']), 
								addslashes($params['y']), 
								$construct_end));
	}

	public static function getConstructTime($buildingName, $lvl = 1)
	{
		$buildingSettings = file_get_contents(__DIR__ . "./../../../assets/json/buildingsSettings.json", FILE_USE_INCLUDE_PATH);
		$buildingSettings = json_decode($buildingSettings, true);
		
		if ($lvl != 1) 
			return $buildingSettings[$buildingName][$lvl]["contruction_time"];
		else if (array_key_exists($lvl, $buildingSettings[$buildingName]))
			return $buildingSettings[$buildingName][$lvl]["contruction_time"];
		else return $buildingSettings[$buildingName]["contruction_time"];
	}
	
	public static function buyBuilding($buildingName, $userId, $lvl = 0)
	{
		$buildingCost = file_get_contents(__DIR__ . "./../../../assets/json/buildingCost.json", FILE_USE_INCLUDE_PATH);
		$buildingCost = json_decode($buildingCost, true);
		
		$price = 0;
		
		if ($lvl != 0) $price = $buildingCost[$buildingName][$lvl];
		else $price = $buildingCost[$buildingName];
		
		$sql = "SELECT r_u.count 
			FROM resource_users AS r_u 
			INNER JOIN resource_type AS r_t
			ON r_t.id = r_u.resource_type_id
			WHERE r_u.user_id = " . $userId . "
				AND r_t.name = 'gold'";
		
		$result = $GLOBALS['app']['db']->fetchAll($sql);
		
		$gold = $result[0]['count'];
		
		if ($gold < $price) return false;
		
		//retire de la gold
		//TO DO retirer en fonction du .json
		ResourcesController::spendResource(1, $price, $userId);
		
		return true;
	}
	
	/*
	 * Récupère le type_id d'un building
	 * @param buildingName Nom du building (ex: temple)
	 */
	public static function getBuildingTypeIdByName($buildingName)
	{
		$sql = "SELECT id 
		FROM building_type
		WHERE building_name = '" . $buildingName . "'";
					
		$result = $GLOBALS['app']['db']->fetchAll($sql);
		return $result[0]['id'];
	}

	/*
	 * Récupère le name d'un building
	 * @param buildingName Type id du building
	 */
	public static function getBuildingNameByTypeId($typeId)
	{
		$sql = "SELECT building_name
		FROM building_type
		WHERE id= '" . $typeId . "'";
					
		$result = $GLOBALS['app']['db']->fetchAll($sql);
		return $result[0]['building_name'];
	}


	/*
	 * Récupère la ligne d'un building grace à sa position dans le model
	 * @param x podition en x du building
	 * @param y podition en y du building
	 * @param userId le user id du batiment
	 */
	public static function getBuildingByPosition($x, $y, $userId) {
		$sql = "SELECT id, building_id, building_type_id
		FROM building_users
		WHERE x = '" . $x . "' 
			AND y = '" . $y . "'
			AND user_id = " . $userId;
		
		$result = $GLOBALS['app']['db']->fetchAll($sql);
		return $result[0];
	}
	
	public static function isFreePosition($x, $y, $userId)
	{
		//pour le debug
		return true;
		$sql = "SELECT id
				FROM building_users
				WHERE user_id = " . $userId . "
					AND x = " . $x . "
					AND y = " . $y;
					
		$result = $GLOBALS['app']['db']->fetchAll($sql);
		
		return count($result) == 0;
		
		//TO DO vérifier si la tile a cette position est buildable
	}
	
	public static function collectBuilding($buildingId, $buildingName, $userId)
	{
		$buildingGain = file_get_contents(__DIR__ . "./../../../assets/json/buildingGain.json", FILE_USE_INCLUDE_PATH);
		$buildingGain = json_decode($buildingGain, true);
		
		$sql = "SELECT *
				FROM building_" . $buildingName . "
				WHERE id = " . $buildingId;
		
		$result = $GLOBALS['app']['db']->fetchAll($sql);
		$building = $result[0];
		
		//Vérifie si le batiment est collectable
		if (!array_key_exists("last_recolt_at", $building)) return false;
		
		$lastUpdate = new DateTime($building['last_recolt_at']);
		
		$date = new DateTime('now');
		
		$diff = $lastUpdate->diff($date);
		
		//Nombre d'heure depuis la dernière récolte précis à la seconde
		$hourDetails = $diff->format('%a') * 24 + $diff->format('%h') + $diff->format('%i') / 60 + $diff->format('%s') / 3600;
		
		$gainPerHour = $buildingGain[$buildingName][$building['lvl']]['production'];
		$maxCapacity = $buildingGain[$buildingName][$building['lvl']]['capacity'];
		
		$gainResource = $gainPerHour * $hourDetails;
		
		if ($gainResource > $maxCapacity) $gainResource = $maxCapacity;
		
		//TO DO changer le 1 par un truc dynamic en fonction de la ressource générer par le batiment
		ResourcesController::addResource(1, $gainResource, $userId);
		
		$sql = "UPDATE building_" . $buildingName . "
			SET last_recolt_at = '" . $date->format("Y-m-d H:i:s") . "'
			WHERE id = " . $buildingId;
		
		$result = $GLOBALS['app']['db']->exec($sql);
		
		return true;
	}
}
