package com.isartdigital.builder.game.manager;
import com.isartdigital.builder.api.Api;
import com.isartdigital.builder.game.def.BuildingDef;
import com.isartdigital.builder.game.def.BuildingSavedDef;
import com.isartdigital.builder.game.def.MapSavedDef;
import com.isartdigital.builder.game.def.PointDef;
import com.isartdigital.builder.game.def.SizeDef;
import com.isartdigital.builder.game.def.TileSavedDef;
import com.isartdigital.builder.game.pooling.PoolObject;
import com.isartdigital.builder.game.sprites.Building;
import com.isartdigital.builder.game.sprites.buildings.Casino;
import com.isartdigital.builder.game.sprites.buildings.Motel;
import com.isartdigital.builder.game.sprites.buildings.RocketFactory;
import com.isartdigital.builder.game.sprites.buildings.Temple;
import com.isartdigital.builder.game.sprites.Tile;
import com.isartdigital.builder.game.utils.TypeDefUtils;
import com.isartdigital.utils.Config;
import com.isartdigital.utils.Debug;
import com.isartdigital.utils.game.GameObject;
import com.isartdigital.utils.game.GameStage;
import com.isartdigital.utils.game.iso.IsoManager;
import com.isartdigital.utils.game.iso.IZSortable;
import com.isartdigital.utils.loader.GameLoader;
import haxe.Json;
import js.Browser;
import js.Lib;
import pixi.core.math.Point;


/**
 * ...
 * @author Dorian
 */
class MapManager extends Manager
{
	/**
	 * instance unique de la classe MapManager
	 */
	private static var instance: MapManager;
	
	public var mapSize:Int = 100;
	
	public var globalMap:Map<String, Array<Dynamic>> = new Map<String, Array<Dynamic>> ();
	//toundo
	public function get_globalMap (): Map<String, Array<Dynamic>>
	{
		return globalMap;
	}
	
	/**
	 * Retourne l'instance unique de la classe, et la crée si elle n'existait pas au préalable
	 * @return instance unique
	 */
	public static function getInstance (): MapManager {
		if (instance == null) instance = new MapManager();
		return instance;
	}
	
	/**
	 * constructeur privé pour éviter qu'une instance soit créée directement
	 */
	private function new() 
	{
		super();
	}
	
	/**
	 * Génère une nouvelle map de base si il n'y a pas de sauvegarde, sinon charge la sauvegarde
	 * @return Success ou fail
	 */
	public function generateMap():Void {
		var map:MapSavedDef;
		
		trace(GameManager.getInstance().userInfo);
		
		// Récupère les données dans le localstorage OU le json de base si il trouve rien
		/*if (isSaveAvailable()) {
			map = cast (Json.parse(Browser.getLocalStorage().getItem("save")));
		} else {
			map = cast (GameLoader.getContent("json/basemap.json"));
		}*/
		
		
		loadMap();
		//saveMap();
	}
	
	
	/**
	 * Sauvegarde la map en cours
	 * @return Success ou fail
	 * DEPRECATED
	 * TODO : A supprimer ainsi que les appel à cette fonction quand la relation front-back sera terminé
	 * pour le chargement de la map.
	 */
	public function saveMap():Bool {
		var mapToSave:MapSavedDef = {
			buildings: new Array()
		};
		
		var building:Building;
		var buildingSaved:BuildingSavedDef;
		
		for (i in 0...Building.list.length) {
			buildingSaved = { name:null, buildingLevel:null, x:null, y:null };
			building = Building.list[i];
			
			buildingSaved.name = building.definition.name;
			buildingSaved.buildingLevel = building.buildingLevel;
			
			buildingSaved.x = Std.int(building.toModel(true).x);
			buildingSaved.y = Std.int(building.toModel(true).y);
			
			mapToSave.buildings.push(buildingSaved);
		}
		
		Browser.getLocalStorage().setItem("save", Json.stringify(mapToSave));
		
		return true;
	}
	
	
	/**
	 * Permet de savoir si un batiment est construisable à un endroit donnée
	 * @param	Array des tiles concerné (Récupérable grâce à getTilesArray(pPosition:Point, pSize:SizeDef):Array<TileSavedDef>)
	 * @return
	 */
	public function isBuildable(pTiles:Array<TileSavedDef>):Bool {
		var _isBuildable:Bool = true;
		
		if (pTiles == null) return false;
		
		for (i in 0...pTiles.length) {
			if (!pTiles[i].isBuildable) {
				_isBuildable = false;
			}
		}

		return _isBuildable;
	}
	
	
	/**
	 * Récupère un tableau contenant les tiles à une position avec une taille donné
	 * @param	pPosition position de la tile initial
	 * @param	pSize taille
	 * @return Array de tiles ou null si l'array exède les limitation de la map
	 */
	public function getTilesArray(pPosition:Point, pSize:SizeDef):Array<TileSavedDef> {
		var tiles:Array<TileSavedDef> = new Array<TileSavedDef>();
		var xIndex:Int;
		var yIndex:Int;
		
		for (x in 0...pSize.width) {
			for (y in 0...pSize.height) {
				xIndex = Std.int(pPosition.x) - x;
				yIndex = Std.int(pPosition.y) - y;
				
				if (isInsideGrid(xIndex, yIndex)) {
					tiles.push(getTileAtPosition(xIndex, yIndex));
				} else {
					return null;
				}
			}
		}
		
		return tiles;
	}
	
	
	/**
	 * Modifie la propriété isBuildable d'un array de tiles
	 * @param	Array<TileSavedDef>
	 * @param	isBuildable
	 */
	public function setTilesBuildable(tiles:Array<TileSavedDef>, _isBuildable:Bool):Void {
		var mapElements:Array<Dynamic>;
		var tile:TileSavedDef;
		
		for (i in 0...tiles.length) {
			tile = tiles[i];
			mapElements = globalMap.get(tile.x + "," + tile.y);
			
			if (mapElements != null) {
				for (j in 0...mapElements.length) {
					if (TypeDefUtils.compare(mapElements[j], TypeDefUtils.tileSavedDef)) {
						globalMap.get(tile.x + "," + tile.y)[j].isBuildable = _isBuildable;
					}
				}
			}
		}
	}
	
	
	/**
	 * Récupère un element dans un array grâce à son typeDef
	 * (Hack conseillé par Nicolas Cannasse)
	 * @param	typeDef typeDef de l'element à comparer (Trouvable dans TypeDefUtils) ex : TypeDefUtils.tileSavedDef
	 * @return Renvoie l'element trouvé, si il le trouve pas, rnevoi null
	 */
	public function getElementByTypeDefInArray(elements:Array<Dynamic>, typeDef:Dynamic):Dynamic {
		for (i in 0...elements.length) {
			if (TypeDefUtils.compare(elements[i], typeDef)) return elements[i];
		}
		return null;
	}
	
	
	/**
	 * Charge la map sauvegardé
	 * @return Si le chargement de la map a réussi ou non
	 */
	private function loadMap():Bool {
		// Remplissage des tiles de la map dans le containeur de tiles
		var map:MapSavedDef = {
			buildings: GameManager.getInstance().userInfo.buildings
		}
		
		var tilePosition:String;
		var tileSaved:TileSavedDef;
		
		for (i in 0...mapSize) {
			for (j in 0...mapSize) {
				tileSaved = {
					x: i,
					y: j,
					isBuildable: true
				};
				
				tilePosition = i + "," + j;
				
				if (!globalMap.exists(tilePosition)) {
					globalMap.set(tilePosition, new Array<Dynamic>());
				}
				
				globalMap.get(tilePosition).push(tileSaved);
			}
		}
		
		// Remplissage des builginds de la map dans le containeur de builginds
		// TODO : Faire en sorte de charger tous les fields specifique à tous les batiments
		var buildingSaved:BuildingSavedDef;
		var buildingDef:BuildingDef;
		
		for (i in 0...map.buildings.length) {
			buildingSaved = map.buildings[i];
			Reflect.deleteField(buildingSaved, 'construct_end_at');
			buildingSaved.buildingLevel = 0;
			buildingSaved.x = Std.int(buildingSaved.x);
			buildingSaved.y = Std.int(buildingSaved.y);
			
			var lPosition:String = buildingSaved.x + "," + buildingSaved.y;
			
			//sécurité si le batiment n'est pas placé sur une Tile
			if (globalMap.exists(lPosition)) {
				globalMap.get(lPosition).push(buildingSaved);
			}
		}
		
		return true;
	}
	
	
	/**
	 * Récupère une tile à la position indiqué
	 * @param pPosition - Position de la grille
	 * @return Tile récupéré
	 */
	private function getTileAtPosition(x:Int, y:Int):TileSavedDef {
		var elements:Array<Dynamic> = new Array();
		var lPosition:String = x + "," + y;
		
		if (globalMap.exists(lPosition)) {
			elements = globalMap.get(lPosition);
		}
		
		return getElementByTypeDefInArray(elements, TypeDefUtils.tileSavedDef);
	}
	
	
	/**
	 * Demande si une sauvegarde est disponible ou non
	 * @return
	 */
	private function isSaveAvailable():Bool {
		var lSaveAvailable:Bool = true;	
		if (Browser.getLocalStorage().getItem("save") == null) {
			lSaveAvailable = false;
		}
		return lSaveAvailable;
	}
	
	
	/**
	 * Indique si la position est hors de la grille ou à l'interieur
	 * @return
	 */
	private function isInsideGrid(pX:Int, pY:Int):Bool {
		var lMapManager:MapManager = MapManager.getInstance();
		
		if (pX >= 0 &&
			pY >= 0 &&
			pX < mapSize &&
			pY < mapSize) {
			return true;
		}
		
		return false;
	}
	
	
	/**
	 * /!\ fonction de debuggage
	 * Affiche la position de la tile sous la souris
	 */
	public function displayTilePositionUnderMouse() {
		var lPosition:Point = IsoManager.isoViewToModel(GameManager.getInstance().mousePosition);
		
		if (Math.floor(Math.random() * 25) == 0) trace("x : " + Math.ceil(lPosition.x) + " y : " + Math.ceil(lPosition.y));
	}
	
	
	/**
	 * Hack pour forcer l'exportation des class.
	 * Mettre ici toutes les class non importer sinon cause le bug suivant : Uncaught TypeError: cl is not a function
	 */
	private function importBuildingsClass():Void {
		Motel;
		Casino;
		RocketFactory;
		Temple;
	}
}