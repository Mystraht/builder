<haxe>
	<class path="Array" params="T" file="C:\HaxeToolkit\haxe\std/js/_std/Array.hx" extern="1">
		<length public="1" set="null">
			<x path="Int"/>
			<haxe_doc>The length of `this` Array.</haxe_doc>
		</length>
		<concat public="1" set="method">
			<f a="a">
				<c path="Array"><c path="Array.T"/></c>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>Returns a new Array by appending the elements of `a` to the elements of
		`this` Array.

		This operation does not modify `this` Array.

		If `a` is the empty Array `[]`, a copy of `this` Array is returned.

		The length of the returned Array is equal to the sum of `this.length`
		and `a.length`.

		If `a` is `null`, the result is unspecified.</haxe_doc>
		</concat>
		<join public="1" set="method">
			<f a="sep">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns a string representation of `this` Array, with `sep` separating
		each element.

		The result of this operation is equal to `Std.string(this[0]) + sep +
		Std.string(this[1]) + sep + ... + sep + Std.string(this[this.length-1])`

		If `this` is the empty Array `[]`, the result is the empty String `""`.
		If `this` has exactly one element, the result is equal to a call to
		`Std.string(this[0])`.

		If `sep` is null, the result is unspecified.</haxe_doc>
		</join>
		<pop public="1" set="method">
			<f a=""><t path="Null"><c path="Array.T"/></t></f>
			<haxe_doc>Removes the last element of `this` Array and returns it.

		This operation modifies `this` Array in place.

		If `this` has at least one element, `this.length` will decrease by 1.

		If `this` is the empty Array `[]`, null is returned and the length
		remains 0.</haxe_doc>
		</pop>
		<push public="1" set="method">
			<f a="x">
				<c path="Array.T"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Adds the element `x` at the end of `this` Array and returns the new
		length of `this` Array.

		This operation modifies `this` Array in place.

		`this.length` increases by 1.</haxe_doc>
		</push>
		<shift public="1" set="method">
			<f a=""><t path="Null"><c path="Array.T"/></t></f>
			<haxe_doc>Removes the first element of `this` Array and returns it.

		This operation modifies `this` Array in place.

		If `this` has at least one element, `this`.length and the index of each
		remaining element is decreased by 1.

		If `this` is the empty Array `[]`, `null` is returned and the length
		remains 0.</haxe_doc>
		</shift>
		<slice public="1" set="method">
			<f a="pos:?end">
				<x path="Int"/>
				<x path="Int"/>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>Creates a shallow copy of the range of `this` Array, starting at and
		including `pos`, up to but not including `end`.

		This operation does not modify `this` Array.

		The elements are not copied and retain their identity.

		If `end` is omitted or exceeds `this.length`, it defaults to the end of
		`this` Array.

		If `pos` or `end` are negative, their offsets are calculated from the
		end	of `this` Array by `this.length + pos` and `this.length + end`
		respectively. If this yields a negative value, 0 is used instead.

		If `pos` exceeds `this.length` or if `end` exceeds or equals `pos`,
		the result is `[]`.</haxe_doc>
		</slice>
		<sort public="1" set="method">
			<f a="f">
				<f a=":">
					<c path="Array.T"/>
					<c path="Array.T"/>
					<x path="Int"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[Sorts `this` Array according to the comparison function `f`, where
		`f(x,y)` returns 0 if x == y, a positive Int if x > y and a
		negative Int if x < y.

		This operation modifies `this` Array in place.

		The sort operation is not guaranteed to be stable, which means that the
		order of equal elements may not be retained. For a stable Array sorting
		algorithm, `haxe.ds.ArraySort.sort()` can be used instead.

		If `f` is null, the result is unspecified.]]></haxe_doc>
		</sort>
		<splice public="1" set="method">
			<f a="pos:len">
				<x path="Int"/>
				<x path="Int"/>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc><![CDATA[Removes `len` elements from `this` Array, starting at and including
		`pos`, an returns them.

		This operation modifies `this` Array in place.

		If `len` is < 0 or `pos` exceeds `this`.length, the result is the empty
		Array [].

		If `pos` is negative, its value is calculated from the end	of `this`
		Array by `this.length + pos`. If this yields a negative value, 0 is
		used instead.

		If the sum of the resulting values for `len` and `pos` exceed
		`this.length`, this operation will affect the elements from `pos` to the
		end of `this` Array.

		The length of the returned Array is equal to the new length of `this`
		Array subtracted from the original length of `this` Array. In other
		words, each element of the original `this` Array either remains in
		`this` Array or becomes an element of the returned Array.]]></haxe_doc>
		</splice>
		<unshift public="1" set="method">
			<f a="x">
				<c path="Array.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Adds the element `x` at the start of `this` Array.

		This operation modifies `this` Array in place.

		`this.length` and the index of each Array element increases by 1.</haxe_doc>
		</unshift>
		<iterator public="1" get="inline" set="null" line="69">
			<f a=""><t path="Iterator"><c path="Array.T"/></t></f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":runtime"/>
			</meta>
			<haxe_doc>Returns an iterator of the Array values.</haxe_doc>
		</iterator>
		<new public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new Array.</haxe_doc>
		</new>
		<haxe_doc>An Array is a storage for values. You can access it using indexes or
	with its API.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<abstract path="Class" params="T" file="C:\HaxeToolkit\haxe\std/Class.hx">
		<this><x path="Class"><c path="Class.T"/></x></this>
		<haxe_doc>An abstract type that represents a Class.

	See `Type` for the Haxe Reflection API.</haxe_doc>
		<meta>
			<m n=":valueUsed"/>
			<m n=":coreType"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<class path="Date" params="" file="C:\HaxeToolkit\haxe\std/js/_std/Date.hx" extern="1">
		<now public="1" get="inline" set="null" line="38" static="1">
			<f a=""><c path="Date"/></f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns a Date representing the current local time.</haxe_doc>
		</now>
		<fromTime public="1" get="inline" set="null" line="42" static="1">
			<f a="t">
				<x path="Float"/>
				<c path="Date"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns a Date from timestamp `t`.</haxe_doc>
		</fromTime>
		<fromString public="1" get="inline" set="null" line="48" static="1">
			<f a="s">
				<c path="String"/>
				<c path="Date"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns a Date from a formated string `s`, with the following accepted
		formats:

		- `"YYYY-MM-DD hh:mm:ss"`
		- `"YYYY-MM-DD"`
		- `"hh:mm:ss"`

		The first two formats are expressed in local time, the third in UTC
		Epoch.</haxe_doc>
		</fromString>
		<getTime public="1" set="method">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Returns the timestamp of the date. It might only have a per-second
		precision depending on the platforms.</haxe_doc>
		</getTime>
		<getHours public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the hours of `this` Date (0-23 range).</haxe_doc>
		</getHours>
		<getMinutes public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the minutes of `this` Date (0-59 range).</haxe_doc>
		</getMinutes>
		<getSeconds public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the seconds of the `this` Date (0-59 range).</haxe_doc>
		</getSeconds>
		<getFullYear public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the full year of `this` Date (4-digits).</haxe_doc>
		</getFullYear>
		<getMonth public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the month of `this` Date (0-11 range).</haxe_doc>
		</getMonth>
		<getDate public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the day of `this` Date (1-31 range).</haxe_doc>
		</getDate>
		<getDay public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the day of the week of `this` Date (0-6 range).</haxe_doc>
		</getDay>
		<toString public="1" get="inline" set="null" line="34">
			<f a=""><c path="String"/></f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns a string representation of `this` Date, by using the
		standard format [YYYY-MM-DD HH:MM:SS]. See `DateTools.format` for
		other formating rules.</haxe_doc>
		</toString>
		<new public="1" set="method">
			<f a="year:month:day:hour:min:sec">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a new date object from the given arguments.

		The behaviour of a Date instance is only consistent across platforms if
		the the arguments describe a valid date.

		- month: 0 to 11
		- day: 1 to 31
		- hour: 0 to 23
		- min: 0 to 59
		- sec: 0 to 59</haxe_doc>
		</new>
		<haxe_doc>The Date class provides a basic structure for date and time related
	information. Date instances can be created by

	- `new Date()` for a specific date,
	- `Date.now()` to obtain information about the current time,
	- `Date.fromTime()` with a given timestamp or
	- `Date.fromString()` by parsing from a String.

	There is some extra functions available in the `DateTools` class.

	In the context of haxe dates, a timestamp is defined as the number of
	milliseconds elapsed since 1st January 1970.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="EReg" params="" file="C:\HaxeToolkit\haxe\std/js/_std/EReg.hx">
		<r><c path="_EReg.HaxeRegExp"/></r>
		<match public="1" set="method" line="31">
			<f a="s">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if `this` regular expression matches String `s`.

		This method modifies the internal state.

		If `s` is `null`, the result is unspecified.</haxe_doc>
		</match>
		<matched public="1" set="method" line="38">
			<f a="n">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the matched sub-group `n` of `this` EReg.

		This method should only be called after `this.match` or
		`this.matchSub`, and then operates on the String of that operation.

		The index `n` corresponds to the n-th set of parentheses in the pattern
		of `this` EReg. If no such sub-group exists, an exception is thrown.

		If `n` equals 0, the whole matched substring is returned.</haxe_doc>
		</matched>
		<replace public="1" set="method" line="84">
			<f a="s:by">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Replaces the first substring of `s` which `this` EReg matches with `by`.

		If `this` EReg does not match any substring, the result is `s`.

		By default, this method replaces only the first matched substring. If
		the global g modifier is in place, all matched substrings are replaced.

		If `by` contains `$1` to `$9`, the digit corresponds to number of a
		matched sub-group and its value is used instead. If no such sub-group
		exists, the replacement is unspecified. The string `$$` becomes `$`.

		If `s` or `by` are null, the result is unspecified.</haxe_doc>
		</replace>
		<new public="1" set="method" line="26">
			<f a="r:opt">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a new regular expression with pattern `r` and modifiers `opt`.

		This is equivalent to the shorthand syntax `~/r/opt`

		If `r` or `opt` are null, the result is unspecified.</haxe_doc>
		</new>
		<haxe_doc>The EReg class represents regular expressions.

	While basic usage and patterns consistently work across platforms, some more
	complex operations may yield different results. This is a necessary trade-
	off to retain a certain level of performance.

	EReg instances can be created by calling the constructor, or with the
	special syntax ~/pattern/modifier

	EReg instances maintain an internal state, which is affected by several of
	its methods.

	A detailed explanation of the supported operations is available at
	http://haxe.org/manual/std-regex.html</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="js.RegExp" params="" file="C:\HaxeToolkit\haxe\std/js/RegExp.hx" extern="1">
		<global public="1" set="null"><x path="Bool"/></global>
		<ignoreCase public="1" set="null"><x path="Bool"/></ignoreCase>
		<multiline public="1" set="null"><x path="Bool"/></multiline>
		<source public="1" set="null"><c path="String"/></source>
		<lastIndex public="1"><x path="Int"/></lastIndex>
		<exec public="1" set="method"><f a="str">
	<c path="String"/>
	<t path="Null"><c path="js.RegExpMatch"/></t>
</f></exec>
		<test public="1" set="method"><f a="str">
	<c path="String"/>
	<x path="Bool"/>
</f></test>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method"><f a="pattern:?flags">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Native JavaScript regular expressions.

    For cross-platform regular expressions, use haxe `EReg` class or regexp literals.</haxe_doc>
		<meta><m n=":native"><e>"RegExp"</e></m></meta>
	</class>
	<class path="_EReg.HaxeRegExp" params="" file="C:\HaxeToolkit\haxe\std/js/_std/EReg.hx" private="1" module="EReg" extern="1">
		<extends path="js.RegExp"/>
		<m public="1"><c path="js.RegExpMatch"/></m>
		<s public="1"><c path="String"/></s>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":native"><e>"RegExp"</e></m>
		</meta>
	</class>
	<abstract path="Enum" params="T" file="C:\HaxeToolkit\haxe\std/Enum.hx">
		<this><x path="Enum"><c path="Enum.T"/></x></this>
		<haxe_doc>An abstract type that represents an Enum type.

	The corresponding enum instance type is `EnumValue`.

	See `Type` for the Haxe Reflection API.</haxe_doc>
		<meta>
			<m n=":valueUsed"/>
			<m n=":coreType"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="EnumValue" params="" file="C:\HaxeToolkit\haxe\std/EnumValue.hx">
		<this><x path="EnumValue"/></this>
		<haxe_doc>An abstract type that represents any enum value.
	See `Type` for the Haxe Reflection API.</haxe_doc>
		<meta><m n=":coreType"/></meta>
	</abstract>
	<class path="Lambda" params="" file="C:\HaxeToolkit\haxe\std/Lambda.hx">
		<exists public="1" params="A" set="method" line="115" static="1">
			<f a="it:f">
				<t path="Iterable"><c path="exists.A"/></t>
				<f a="">
					<c path="exists.A"/>
					<x path="Bool"/>
				</f>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if `it` contains an element for which `f` is true.

		This function returns true as soon as an element is found for which a
		call to `f` returns true.

		If no such element is found, the result is false.

		If `f` is null, the result is unspecified.</haxe_doc>
		</exists>
		<foreach public="1" params="A" set="method" line="134" static="1">
			<f a="it:f">
				<t path="Iterable"><c path="foreach.A"/></t>
				<f a="">
					<c path="foreach.A"/>
					<x path="Bool"/>
				</f>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if `f` is true for all elements of `it`.

		This function returns false as soon as an element is found for which a
		call to `f` returns false.

		If no such element is found, the result is true.

		In particular, this function always returns true if `it` is empty.

		If `f` is null, the result is unspecified.</haxe_doc>
		</foreach>
		<fold public="1" params="A:B" set="method" line="179" static="1">
			<f a="it:f:first">
				<t path="Iterable"><c path="fold.A"/></t>
				<f a=":">
					<c path="fold.A"/>
					<c path="fold.B"/>
					<c path="fold.B"/>
				</f>
				<c path="fold.B"/>
				<c path="fold.B"/>
			</f>
			<haxe_doc>Functional fold on Iterable `it`, using function `f` with start argument
		`first`.

		If `it` has no elements, the result is `first`.

		Otherwise the first element of `it` is passed to `f` alongside `first`.
		The result of that call is then passed to `f` with the next element of
		`it`, and so on until `it` has no more elements.

		If `it` or `f` are null, the result is unspecified.</haxe_doc>
		</fold>
		<find public="1" params="T" set="method" line="237" static="1">
			<f a="it:f">
				<t path="Iterable"><c path="find.T"/></t>
				<f a="">
					<c path="find.T"/>
					<x path="Bool"/>
				</f>
				<t path="Null"><c path="find.T"/></t>
			</f>
			<haxe_doc>Returns the first element of `it` for which `f` is true.

		This function returns as soon as an element is found for which a call to
		`f` returns true.

		If no such element is found, the result is null.

		If `f` is null, the result is unspecified.</haxe_doc>
		</find>
		<haxe_doc>The `Lambda` class is a collection of methods to support functional
	programming. It is ideally used with 'using Lambda' and then acts as an
	extension to Iterable types.

	On static platforms, working with the Iterable structure might be slower
	than performing the operations directly on known types, such as Array and
	List.

	If the first argument to any of the methods is null, the result is
	unspecified.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="List" params="T" file="C:\HaxeToolkit\haxe\std/List.hx">
		<h><c path="Array"><d/></c></h>
		<q><c path="Array"><d/></c></q>
		<length public="1" set="null">
			<x path="Int"/>
			<haxe_doc>The length of `this` List.</haxe_doc>
		</length>
		<push public="1" set="method" line="64">
			<f a="item">
				<c path="List.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Adds element `item` at the beginning of `this` List.

		`this.length` increases by 1.</haxe_doc>
		</push>
		<iterator public="1" get="inline" set="null" line="161">
			<f a=""><c path="_List.ListIterator"><c path="List.T"/></c></f>
			<haxe_doc>Returns an iterator on the elements of the list.</haxe_doc>
		</iterator>
		<new public="1" set="method" line="40">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new empty list.</haxe_doc>
		</new>
		<haxe_doc>A linked-list of elements. The list is composed of two-elements arrays
	that are chained together. It is optimized so that adding or removing an
	element does not imply copying the whole array content every time.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="_List.ListIterator" params="T" file="C:\HaxeToolkit\haxe\std/List.hx" private="1" module="List">
		<head><c path="Array"><d/></c></head>
		<val><d/></val>
		<hasNext public="1" get="inline" set="null" line="249"><f a=""><x path="Bool"/></f></hasNext>
		<next public="1" get="inline" set="null" line="253"><f a=""><c path="_List.ListIterator.T"/></f></next>
		<new public="1" get="inline" set="null" line="244"><f a="head">
	<c path="Array"><d/></c>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<abstract path="Map" params="K:V" file="C:\HaxeToolkit\haxe\std/Map.hx">
		<from>
			<icast field="fromStringMap"><c path="haxe.ds.StringMap"><c path="fromStringMap.V"/></c></icast>
			<icast field="fromIntMap"><c path="haxe.ds.IntMap"><c path="fromIntMap.V"/></c></icast>
			<icast field="fromObjectMap"><c path="haxe.ds.ObjectMap">
	<c path="fromObjectMap.K"/>
	<c path="fromObjectMap.V"/>
</c></icast>
		</from>
		<this><t path="IMap">
	<c path="Map.K"/>
	<c path="Map.V"/>
</t></this>
		<to>
			<icast field="toStringMap"><c path="haxe.ds.StringMap"><c path="toStringMap.V"/></c></icast>
			<icast field="toIntMap"><c path="haxe.ds.IntMap"><c path="toIntMap.V"/></c></icast>
			<icast field="toEnumValueMapMap"><c path="haxe.ds.EnumValueMap">
	<c path="toEnumValueMapMap.K"/>
	<c path="toEnumValueMapMap.V"/>
</c></icast>
			<icast field="toObjectMap"><c path="haxe.ds.ObjectMap">
	<c path="toObjectMap.K"/>
	<c path="toObjectMap.V"/>
</c></icast>
		</to>
		<haxe_doc><![CDATA[Map allows key to value mapping for arbitrary value types, and many key
	types.

	This is a multi-type abstract, it is instantiated as one of its
	specialization types depending on its type parameters.

	A Map can be instantiated without explicit type parameters. Type inference
	will then determine the type parameters from the usage.

	Maps can also be created with `key1 => value1, key2 => value2` syntax.

	Map is an abstract type, it is not available at runtime.]]></haxe_doc>
		<meta><m n=":multiType"><e>K</e></m></meta>
		<impl><class path="_Map.Map_Impl_" params="" file="C:\HaxeToolkit\haxe\std/Map.hx" private="1" module="Map"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<typedef path="IMap" params="K:V" file="C:\HaxeToolkit\haxe\std/Map.hx" module="Map">
		<c path="haxe.IMap">
			<c path="IMap.K"/>
			<c path="IMap.V"/>
		</c>
		<meta><m n=":deprecated"/></meta>
	</typedef>
	<class path="Math" params="" file="C:\HaxeToolkit\haxe\std/js/_std/Math.hx" extern="1">
		<abs public="1" set="method" static="1"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></abs>
		<ceil public="1" set="method" static="1"><f a="v">
	<x path="Float"/>
	<x path="Int"/>
</f></ceil>
		<floor public="1" set="method" static="1"><f a="v">
	<x path="Float"/>
	<x path="Int"/>
</f></floor>
		<min public="1" set="method" static="1"><f a="a:b">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></min>
		<pow public="1" set="method" static="1"><f a="v:exp">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></pow>
		<random public="1" set="method" static="1"><f a=""><x path="Float"/></f></random>
		<round public="1" set="method" static="1"><f a="v">
	<x path="Float"/>
	<x path="Int"/>
</f></round>
		<sqrt public="1" set="method" static="1"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></sqrt>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":keepInit"/>
		</meta>
	</class>
	<class path="Reflect" params="" file="C:\HaxeToolkit\haxe\std/js/_std/Reflect.hx">
		<field public="1" set="method" line="28" static="1">
			<f a="o:field">
				<d/>
				<c path="String"/>
				<d/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns the value of the field named `field` on object `o`.

		If `o` is not an object or has no field named `field`, the result is
		null.

		If the field is defined as a property, its accessors are ignored. Refer
		to `Reflect.getProperty` for a function supporting property accessors.

		If `field` is null, the result is unspecified.

		(As3) If used on a property field, the getter will be invoked. It is
		not possible to obtain the value directly.</haxe_doc>
		</field>
		<setField public="1" get="inline" set="null" line="32" static="1">
			<f a="o:field:value">
				<d/>
				<c path="String"/>
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Sets the field named `field` of object `o` to value `value`.

		If `o` has no field named `field`, this function is only guaranteed to
		work for anonymous structures.

		If `o` or `field` are null, the result is unspecified.

		(As3) If used on a property field, the setter will be invoked. It is
		not possible to set the value directly.</haxe_doc>
		</setField>
		<getProperty public="1" get="inline" set="null" line="36" static="1">
			<f a="o:field">
				<d/>
				<c path="String"/>
				<d/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns the value of the field named `field` on object `o`, taking
		property getter functions into account.

		If the field is not a property, this function behaves like
		`Reflect.field`, but might be slower.

		If `o` or `field` are null, the result is unspecified.</haxe_doc>
		</getProperty>
		<fields public="1" set="method" line="50" static="1">
			<f a="o">
				<d/>
				<c path="Array"><c path="String"/></c>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns the fields of structure `o`.

		This method is only guaranteed to work on anonymous structures. Refer to
		`Type.getInstanceFields` for a function supporting class instances.

		If `o` is null, the result is unspecified.</haxe_doc>
		</fields>
		<compare public="1" params="T" set="method" line="65" static="1">
			<f a="a:b">
				<c path="compare.T"/>
				<c path="compare.T"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Compares `a` and `b`.

		If `a` is less than `b`, the result is negative. If `b` is less than
		`a`, the result is positive. If `a` and `b` are equal, the result is 0.

		This function is only defined if `a` and `b` are of the same type.

		If that type is a function, the result is unspecified and
		`Reflect.compareMethods` should be used instead.

		For all other types, the result is 0 if `a` and `b` are equal. If they
		are not equal, the result depends on the type and is negative if:

		- Numeric types: a is less than b
		- String: a is lexicographically less than b
		- Other: unspecified

		If `a` and `b` are null, the result is 0. If only one of them is null,
		the result is unspecified.</haxe_doc>
		</compare>
		<isEnumValue public="1" set="method" line="84" static="1">
			<f a="v">
				<d/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if `v` is an enum value.

		The result is true if `v` is of type EnumValue, i.e. an enum
		constructor.

		Otherwise, including if `v` is null, the result is false.</haxe_doc>
		</isEnumValue>
		<deleteField public="1" set="method" line="88" static="1">
			<f a="o:field">
				<d/>
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Removes the field named `field` from structure `o`.

		This method is only guaranteed to work on anonymous structures.

		If `o` or `field` are null, the result is unspecified.</haxe_doc>
		</deleteField>
		<haxe_doc>The Reflect API is a way to manipulate values dynamically through an
	abstract interface in an untyped manner. Use with care.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="String" params="" file="C:\HaxeToolkit\haxe\std/js/_std/String.hx" extern="1">
		<fromCharCode public="1" set="method" static="1">
			<f a="code">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the String corresponding to the character code `code`.

		If `code` is negative or has another invalid value, the result is
		unspecified.</haxe_doc>
		</fromCharCode>
		<length public="1" set="null">
			<x path="Int"/>
			<haxe_doc>The number of characters in `this` String.</haxe_doc>
		</length>
		<toUpperCase public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a String where all characters of `this` String are upper case.

		Affects the characters `a-z`. Other characters remain unchanged.</haxe_doc>
		</toUpperCase>
		<toLowerCase public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a String where all characters of `this` String are lower case.

		Affects the characters `A-Z`. Other characters remain unchanged.</haxe_doc>
		</toLowerCase>
		<charAt public="1" set="method">
			<f a="index">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the character at position `index` of `this` String.

		If `index` is negative or exceeds `this.length`, the empty String ""
		is returned.</haxe_doc>
		</charAt>
		<indexOf public="1" set="method">
			<f a="str:?startIndex">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the position of the leftmost occurence of `str` within `this`
		String.

		If `startIndex` is given, the search is performed within the substring
		of `this` String starting from `startIndex`. Otherwise the search is
		performed within `this` String. In either case, the returned position
		is relative to the beginning of `this` String.

		If `str` cannot be found, -1 is returned.</haxe_doc>
		</indexOf>
		<lastIndexOf public="1" set="method">
			<f a="str:?startIndex">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the position of the rightmost occurence of `str` within `this`
		String.

		If `startIndex` is given, the search is performed within the substring
		of `this` String from 0 to `startIndex`. Otherwise the search is
		performed within `this` String. In either case, the returned position
		is relative to the beginning of `this` String.

		If `str` cannot be found, -1 is returned.</haxe_doc>
		</lastIndexOf>
		<split public="1" set="method">
			<f a="delimiter">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Splits `this` String at each occurence of `delimiter`.

		If `this` String is the empty String "", the result is not consistent
		across targets and may either be `[]` (on Js, Cpp) or `[""]`.

		If `delimiter` is the empty String "", `this` String is split into an
		Array of `this.length` elements, where the elements correspond to the
		characters of `this` String.

		If `delimiter` is not found within `this` String, the result is an Array
		with one element, which equals `this` String.

		If `delimiter` is null, the result is unspecified.

		Otherwise, `this` String is split into parts at each occurence of
		`delimiter`. If `this` String starts (or ends) with [delimiter}, the
		result Array contains a leading (or trailing) empty String "" element.
		Two subsequent delimiters also result in an empty String "" element.</haxe_doc>
		</split>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the String itself.</haxe_doc>
		</toString>
		<substring public="1" set="method">
			<f a="startIndex:?endIndex">
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the part of `this` String from `startIndex` to but not including `endIndex`.

		If `startIndex` or `endIndex` are negative, 0 is used instead.

		If `startIndex` exceeds `endIndex`, they are swapped.

		If the (possibly swapped) `endIndex` is omitted or exceeds
		`this.length`, `this.length` is used instead.

		If the (possibly swapped) `startIndex` exceeds `this.length`, the empty
		String "" is returned.</haxe_doc>
		</substring>
		<charCodeAt public="1" get="inline" set="null" line="35">
			<f a="index">
				<x path="Int"/>
				<t path="Null"><x path="Int"/></t>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns the character code at position `index` of `this` String.

		If `index` is negative or exceeds `this.length`, null is returned.

		To obtain the character code of a single character, "x".code can be used
		instead to inline the character code at compile time. Note that this
		only works on String literals of length 1.</haxe_doc>
		</charCodeAt>
		<substr public="1" get="inline" set="null" line="39">
			<f a="pos:?len">
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns `len` characters of `this` String, starting at position `pos`.

		If `len` is omitted, all characters from position `pos` to the end of
		`this` String are included.

		If `pos` is negative, its value is calculated from the end of `this`
		String by `this.length + pos`. If this yields a negative value, 0 is
		used instead.

		If the calculated position + `len` exceeds `this.length`, the characters
		from that position to the end of `this` String are returned.

		If `len` is negative, the result is unspecified.</haxe_doc>
		</substr>
		<new public="1" set="method">
			<f a="string">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a copy from a given String.</haxe_doc>
		</new>
		<haxe_doc>The basic String class.

	A haxe String is immutable, it is not possible to modify individual
	characters. No method of this class changes the state of `this` String.

	Strings can be constructed using the string literal syntax "string value".

	String can be concatenated by using the + operator. If an operand is not a
	String, it is passed through Std.string() first.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="Std" params="" file="C:\HaxeToolkit\haxe\std/js/_std/Std.hx">
		<is public="1" get="inline" set="null" line="27" static="1">
			<f a="v:t">
				<d/>
				<d/>
				<x path="Bool"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Tells if a value `v` is of the type `t`. Returns `false` if `v` or `t` are null.</haxe_doc>
		</is>
		<string public="1" set="method" line="35" static="1">
			<f a="s">
				<d/>
				<c path="String"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Converts any value to a String.

		If `s` is of `String`, `Int`, `Float` or `Bool`, its value is returned.

		If `s` is an instance of a class and that class or one of its parent classes has
		a `toString` method, that method is called. If no such method is present, the result
		is unspecified.

		If `s` is an enum constructor without argument, the constructor's name is returned. If
		arguments exists, the constructor's name followed by the String representations of
		the arguments is returned.

		If `s` is a structure, the field names along with their values are returned. The field order
		and the operator separating field names and values are unspecified.

		If s is null, "null" is returned.</haxe_doc>
		</string>
		<int public="1" get="inline" set="null" line="39" static="1">
			<f a="x">
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Converts a `Float` to an `Int`, rounded towards 0.

		If `x` is outside of the signed Int32 range, or is `NaN`, `NEGATIVE_INFINITY` or `POSITIVE_INFINITY`, the result is unspecified.</haxe_doc>
		</int>
		<parseInt public="1" set="method" line="43" static="1">
			<f a="x">
				<c path="String"/>
				<t path="Null"><x path="Int"/></t>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Converts a `String` to an `Int`.

		Leading whitespaces are ignored.

		If `x` starts with 0x or 0X, hexadecimal notation is recognized where the following digits may
		contain 0-9 and A-F.

		Otherwise `x` is read as decimal number with 0-9 being allowed characters. `x` may also start with
		a - to denote a negative value.

		In decimal mode, parsing continues until an invalid character is detected, in which case the
		result up to that point is returned. For hexadecimal notation, the effect of invalid characters
		is unspecified.

		Leading 0s that are not part of the 0x/0X hexadecimal notation are ignored, which means octal
		notation is not supported.

		If the input cannot be recognized, the result is `null`.</haxe_doc>
		</parseInt>
		<haxe_doc>The Std class provides standard methods for manipulating basic types.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":keepInit"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<abstract path="Void" params="" file="C:\HaxeToolkit\haxe\std/StdTypes.hx" module="StdTypes">
		<this><x path="Void"/></this>
		<haxe_doc>The standard Void type. Only `null` values can be of the type `Void`.</haxe_doc>
		<meta><m n=":coreType"/></meta>
	</abstract>
	<abstract path="Float" params="" file="C:\HaxeToolkit\haxe\std/StdTypes.hx" module="StdTypes">
		<this><x path="Float"/></this>
		<haxe_doc><![CDATA[The standard Float type, this is a double-precision IEEE 64bit float.

	On static targets, null cannot be assigned to Float. If this is necessary,
	`Null<Float>` can be used instead.]]></haxe_doc>
		<meta>
			<m n=":valueUsed"/>
			<m n=":coreType"/>
			<m n=":notNull"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="Int" params="" file="C:\HaxeToolkit\haxe\std/StdTypes.hx" module="StdTypes">
		<this><x path="Int"/></this>
		<to><icast><x path="Float"/></icast></to>
		<haxe_doc><![CDATA[The standard Int type. Its precision depends on the platform.

	On static targets, null cannot be assigned to Int. If this is necessary,
	`Null<Int>` can be used instead.]]></haxe_doc>
		<meta>
			<m n=":valueUsed"/>
			<m n=":coreType"/>
			<m n=":notNull"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<typedef path="Null" params="T" file="C:\HaxeToolkit\haxe\std/StdTypes.hx" module="StdTypes">
		<c path="Null.T"/>
		<haxe_doc>`Null` can be useful in two cases. In order to document some methods
	that accepts or can return a `null` value, or for the Flash compiler and AS3
	generator to distinguish between base values that can be null and others that
	can't.</haxe_doc>
	</typedef>
	<abstract path="Bool" params="" file="C:\HaxeToolkit\haxe\std/StdTypes.hx" module="StdTypes">
		<this><x path="Bool"/></this>
		<haxe_doc><![CDATA[The standard Boolean type, which can either be true or false.

	On static targets, null cannot be assigned to Bool. If this is necessary,
	`Null<Bool>` can be used instead.]]></haxe_doc>
		<meta>
			<m n=":valueUsed"/>
			<m n=":coreType"/>
			<m n=":notNull"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="Dynamic" params="T" file="C:\HaxeToolkit\haxe\std/StdTypes.hx" module="StdTypes">
		<this><x path="Dynamic"><c path="Dynamic.T"/></x></this>
		<haxe_doc>Dynamic is a special type which is compatible with all other types.

	Use of Dynamic should be minimized as it prevents several compiler
	checks and optimizations.</haxe_doc>
		<meta>
			<m n=":valueUsed"/>
			<m n=":coreType"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<typedef path="Iterator" params="T" file="C:\HaxeToolkit\haxe\std/StdTypes.hx" module="StdTypes">
		<a>
			<next set="method">
				<f a=""><c path="Iterator.T"/></f>
				<haxe_doc>Returns the current item of the Iterator and advances to the next one.

		This method is not required to check `hasNext` first. A call to this
		method while `hasNext` is false yields unspecified behavior.

		On the other hand iterators should not require a call to `hasNext`
		before the first call to `next` if an element is available.</haxe_doc>
			</next>
			<hasNext set="method">
				<f a=""><x path="Bool"/></f>
				<haxe_doc>Returns false if the iteration is complete, true otherwise.

		Usually iteration is considered to be complete if all elements of the
		underlying data structure were handled through calls to next(). However,
		in custom iterators any logic may be used to determine the completion
		state.</haxe_doc>
			</hasNext>
		</a>
		<haxe_doc>An Iterator is a structure that permits iteration over elements of type T.

	Any class with matching hasNext and next fields is considered an Iterator
	and can then be used e.g. in for-loops. This makes it easy to implement
	custom iterators.</haxe_doc>
	</typedef>
	<typedef path="Iterable" params="T" file="C:\HaxeToolkit\haxe\std/StdTypes.hx" module="StdTypes">
		<a><iterator set="method"><f a=""><t path="Iterator"><c path="Iterable.T"/></t></f></iterator></a>
		<haxe_doc>An Iterable is a data structure which has an iterator() method.
	See `Lambda` for generic functions on iterable structures.</haxe_doc>
	</typedef>
	<class path="ArrayAccess" params="T" file="C:\HaxeToolkit\haxe\std/StdTypes.hx" module="StdTypes" extern="1" interface="1"><haxe_doc>ArrayAccess is used to indicate a class that can be accessed using brackets.
	The type parameter represents the type of the elements stored.</haxe_doc></class>
	<class path="Type" params="" file="C:\HaxeToolkit\haxe\std/js/_std/Type.hx">
		<getClass public="1" params="T" get="inline" set="null" line="36" static="1">
			<f a="o">
				<c path="getClass.T"/>
				<x path="Class"><c path="getClass.T"/></x>
			</f>
			<haxe_doc>Returns the class of `o`, if `o` is a class instance.

		If `o` is null or of a different type, null is returned.

		In general, type parameter information cannot be obtained at runtime.</haxe_doc>
		</getClass>
		<getClassName public="1" set="method" line="51" static="1">
			<f a="c">
				<x path="Class"><d/></x>
				<c path="String"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns the name of class `c`, including its path.

		If `c` is inside a package, the package structure is returned dot-
		separated, with another dot separating the class name:
		`pack1.pack2.(...).packN.ClassName`
		If `c` is a sub-type of a haxe module, that module is not part of the
		package structure.

		If `c` has no package, the class name is returned.

		If `c` is null, the result is unspecified.

		The class name does not include any type parameters.</haxe_doc>
		</getClassName>
		<resolveClass public="1" set="method" line="63" static="1">
			<f a="name">
				<c path="String"/>
				<x path="Class"><d/></x>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Resolves a class by name.

		If `name` is the path of an existing class, that class is returned.

		Otherwise null is returned.

		If `name` is null or the path to a different type, the result is
		unspecified.

		The class name must not include any type parameters.</haxe_doc>
		</resolveClass>
		<createInstance public="1" params="T" set="method" line="79" static="1">
			<f a="cl:args">
				<x path="Class"><c path="createInstance.T"/></x>
				<c path="Array"><d/></c>
				<c path="createInstance.T"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Creates an instance of class `cl`, using `args` as arguments to the
		class constructor.

		This function guarantees that the class constructor is called.

		Default values of constructors arguments are not guaranteed to be
		taken into account.

		If `cl` or `args` are null, or if the number of elements in `args` does
		not match the expected number of constructor arguments, or if any
		argument has an invalid type,  or if `cl` has no own constructor, the
		result is unspecified.

		In particular, default values of constructor arguments are not
		guaranteed to be taken into account.</haxe_doc>
		</createInstance>
		<haxe_doc>The haxe Reflection API allows retrieval of type information at runtime.

	This class complements the more lightweight Reflect class, with a focus on
	class and enum instances.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<abstract path="UInt" params="" file="C:\HaxeToolkit\haxe\std/UInt.hx">
		<from><icast><x path="Int"/></icast></from>
		<this><x path="Int"/></this>
		<to>
			<icast><x path="Int"/></icast>
			<icast field="toFloat"><x path="Float"/></icast>
		</to>
		<haxe_doc>The unsigned Int type is only defined for Flash and C#.
	Simulate it for other platforms.</haxe_doc>
		<impl><class path="_UInt.UInt_Impl_" params="" file="C:\HaxeToolkit\haxe\std/UInt.hx" private="1" module="UInt">
	<gt set="method" line="116" static="1">
		<f a="a:b">
			<x path="UInt"/>
			<x path="UInt"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":op"><e><![CDATA[A>B]]></e></m></meta>
	</gt>
	<gte set="method" line="124" static="1">
		<f a="a:b">
			<x path="UInt"/>
			<x path="UInt"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":op"><e><![CDATA[A>=B]]></e></m></meta>
	</gte>
	<toFloat set="method" line="278" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Float"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":to"/>
		</meta>
	</toFloat>
	<meta>
		<m n=":keep"/>
		<m n=":directlyUsed"/>
	</meta>
</class></impl>
	</abstract>
	<class path="_UInt.UInt_Impl_" params="" file="C:\HaxeToolkit\haxe\std/UInt.hx" private="1" module="UInt">
		<gt set="method" line="116" static="1">
			<f a="a:b">
				<x path="UInt"/>
				<x path="UInt"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":op"><e><![CDATA[A>B]]></e></m></meta>
		</gt>
		<gte set="method" line="124" static="1">
			<f a="a:b">
				<x path="UInt"/>
				<x path="UInt"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":op"><e><![CDATA[A>=B]]></e></m></meta>
		</gte>
		<toFloat set="method" line="278" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":to"/>
			</meta>
		</toFloat>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="eventemitter3.EventEmitter" params="" file="C:\HaxeToolkit\haxe\lib\eventemitter3/1,0,0/src/eventemitter3/EventEmitter.hx" extern="1">
		<listeners public="1" set="method">
			<f a="event:exists">
				<c path="String"/>
				<x path="Bool"/>
				<c path="Array"><d/></c>
			</f>
			<haxe_doc>* Return a list of assigned event listeners.
	 *
	 * @param {String} event The events that should be listed.
	 * @param {Boolean} exists We only need to know if there are listeners.
	 * @returns {Array|Boolean}</haxe_doc>
		</listeners>
		<emit public="1" set="method">
			<f a="event:?a1:?a2:?a3:?a4:?a5">
				<c path="String"/>
				<d/>
				<d/>
				<d/>
				<d/>
				<d/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Emit an event to all registered event listeners.
	 *
	 * @param {String} event The name of the event.
	 * @returns {Boolean} Indication if we've emitted an event.</haxe_doc>
		</emit>
		<on public="1" set="method">
			<f a="event:fn:?context">
				<c path="String"/>
				<f a="">
					<d/>
					<x path="Void"/>
				</f>
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Register a new EventListener for the given event.
	 *
	 * @param {String} event Name of the event.
	 * @param {Function} fn Callback function.
	 * @param {Mixed} context The context of the function.</haxe_doc>
		</on>
		<once public="1" set="method">
			<f a="event:fn:?context">
				<c path="String"/>
				<f a="">
					<d/>
					<x path="Void"/>
				</f>
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Add an EventListener that's only called once.
	 *
	 * @param {String} event Name of the event.
	 * @param {Function} fn Callback function.
	 * @param {Mixed} context The context of the function.</haxe_doc>
		</once>
		<addListener public="1" set="method">
			<f a="event:fn:?context">
				<c path="String"/>
				<f a="">
					<d/>
					<x path="Void"/>
				</f>
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Register a new EventListener for the given event.
	 *
	 * @param {String} event Name of the event.
	 * @param {Function} fn Callback function.
	 * @param {Mixed} context The context of the function.</haxe_doc>
		</addListener>
		<off public="1" set="method">
			<f a="event:fn:?once">
				<c path="String"/>
				<f a="">
					<d/>
					<x path="Void"/>
				</f>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Remove event listeners.
	 *
	 * @param {String} event The event we want to remove.
	 * @param {Function} fn The listener that we need to find.
	 * @param {Mixed} context Only remove listeners matching this context.
	 * @param {Boolean} once Only remove once listeners.</haxe_doc>
		</off>
		<removeListener public="1" set="method">
			<f a="event:fn:?once">
				<c path="String"/>
				<f a="">
					<d/>
					<x path="Void"/>
				</f>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Remove event listeners.
	 *
	 * @param {String} event The event we want to remove.
	 * @param {Function} fn The listener that we need to find.
	 * @param {Mixed} context Only remove listeners matching this context.
	 * @param {Boolean} once Only remove once listeners.</haxe_doc>
		</removeListener>
		<removeAllListeners public="1" set="method">
			<f a="?event">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Remove all listeners or only the listeners for the specified event.
	 *
	 * @param {String} event The event want to remove all listeners for.</haxe_doc>
		</removeAllListeners>
		<new public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Minimal EventEmitter interface that is molded against the Node.js
	 * EventEmitter interface.
	 *
	 * @constructor</haxe_doc>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":native"><e>"EventEmitter"</e></m>
		</meta>
	</class>
	<class path="com.isartdigital.builder.Main" params="" file="src/com/isartdigital/builder/Main.hx">
		<extends path="eventemitter3.EventEmitter"/>
		<CONFIG_PATH get="inline" set="null" line="60" static="1">
			<c path="String"/>
			<haxe_doc>* chemin vers le fichier de configuration</haxe_doc>
		</CONFIG_PATH>
		<instance static="1">
			<c path="com.isartdigital.builder.Main"/>
			<haxe_doc>* instance unique de la classe Main</haxe_doc>
		</instance>
		<main set="method" line="90" static="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* initialisation générale</haxe_doc>
		</main>
		<getInstance public="1" set="method" line="98" static="1">
			<f a=""><c path="com.isartdigital.builder.Main"/></f>
			<haxe_doc>* Retourne l'instance unique de la classe, et la crée si elle n'existait pas au préalable
	 * @return instance unique</haxe_doc>
		</getInstance>
		<importClasses set="method" line="350" static="1"><f a=""><x path="Void"/></f></importClasses>
		<increase><x path="Bool"/></increase>
		<userInfoLoaded>
			<x path="Bool"/>
			<haxe_doc>* Si le /me a été chargé ou non</haxe_doc>
		</userInfoLoaded>
		<assetsLoaded>
			<x path="Bool"/>
			<haxe_doc>* Si les assets on été chargé ou non</haxe_doc>
		</assetsLoaded>
		<renderer public="1">
			<c path="pixi.core.renderers.webgl.WebGLRenderer"/>
			<haxe_doc>* renderer (WebGL ou Canvas)</haxe_doc>
		</renderer>
		<stage public="1">
			<c path="pixi.core.display.Container"/>
			<haxe_doc>* Element racine de la displayList</haxe_doc>
		</stage>
		<preloadAssets set="method" line="149">
			<f a="pLoader">
				<c path="pixi.loaders.Loader"/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>* charge les assets graphiques du preloader principal</haxe_doc>
		</preloadAssets>
		<loadAssets set="method" line="198">
			<f a="pLoader">
				<c path="com.isartdigital.utils.loader.GameLoader"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* lance le chargement principal</haxe_doc>
		</loadAssets>
		<loadUserInfos set="method" line="240">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Charge le /userInfos du jeu</haxe_doc>
		</loadUserInfos>
		<cbOnUserInfosReceipt set="method" line="244"><f a="pData">
	<c path="String"/>
	<x path="Void"/>
</f></cbOnUserInfosReceipt>
		<onLoadProgress set="method" line="262">
			<f a="pLoader">
				<c path="com.isartdigital.utils.loader.GameLoader"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* transmet les paramètres de chargement au préchargeur graphique
	 * @param	pEvent evenement de chargement</haxe_doc>
		</onLoadProgress>
		<onLoadComplete set="method" line="270">
			<f a="pLoader">
				<c path="com.isartdigital.utils.loader.GameLoader"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* initialisation du jeu
	 * @param	pEvent evenement de chargement</haxe_doc>
		</onLoadComplete>
		<tryToStartGame set="method" line="299">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Essaye de charger le jeu (Si les conditions necessaires sont valide)</haxe_doc>
		</tryToStartGame>
		<startGame set="method" line="308">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Démarre le jeu</haxe_doc>
		</startGame>
		<gameLoop set="method" line="319">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* game loop</haxe_doc>
		</gameLoop>
		<resize public="1" set="method" line="330">
			<f a="?pEvent">
				<t path="pixi.interaction.EventTarget"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Ecouteur du redimensionnement
	 * @param	pEvent evenement de redimensionnement</haxe_doc>
		</resize>
		<render set="method" line="338">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* fait le rendu de l'écran</haxe_doc>
		</render>
		<destroy public="1" set="method" line="345">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* détruit l'instance unique et met sa référence interne à null</haxe_doc>
		</destroy>
		<onFacebookLogin set="method" line="363">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Fonction appellé quand la connection à facebook est réussi</haxe_doc>
		</onFacebookLogin>
		<callBackApi set="method" line="368"><f a="pData">
	<d/>
	<x path="Void"/>
</f></callBackApi>
		<cbAds set="method" line="381"><f a="pData">
	<d/>
	<x path="Void"/>
</f></cbAds>
		<callBackUI set="method" line="389"><f a="pData">
	<d/>
	<x path="Void"/>
</f></callBackUI>
		<new set="method" line="106">
			<f a=""><x path="Void"/></f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>* création du jeu et lancement du chargement du fichier de configuration</haxe_doc>
		</new>
		<haxe_doc>* Classe d'initialisation et lancement du jeu
 * @author Mathieu ANTHOINE</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="com.isartdigital.builder.api.Api" params="" file="src/com/isartdigital/builder/api/Api.hx">
		<domain public="1" static="1"><c path="String"/></domain>
		<domainProd public="1" line="14" static="1"><c path="String"/></domainProd>
		<domainDev public="1" line="15" static="1"><c path="String"/></domainDev>
		<pathApi public="1" line="17" static="1"><c path="String"/></pathApi>
		<token public="1" static="1"><c path="String"/></token>
		<user public="1" static="1"><c path="com.isartdigital.builder.api.User"/></user>
		<gifts public="1" static="1"><c path="com.isartdigital.builder.api.Gifts"/></gifts>
		<resources public="1" static="1"><c path="com.isartdigital.builder.api.Resources"/></resources>
		<buildings public="1" static="1"><c path="com.isartdigital.builder.api.Buildings"/></buildings>
		<lanterns public="1" static="1"><c path="com.isartdigital.builder.api.Lanterns"/></lanterns>
		<instance static="1">
			<c path="com.isartdigital.builder.api.Api"/>
			<haxe_doc>* instance unique de la classe Resources</haxe_doc>
		</instance>
		<getInstance public="1" set="method" line="36" static="1">
			<f a=""><c path="com.isartdigital.builder.api.Api"/></f>
			<haxe_doc>* Retourne l'instance unique de la classe, et la crée si elle n'existait pas au préalable
	 * @return instance unique</haxe_doc>
		</getInstance>
		<formatPath public="1" set="method" line="64" static="1">
			<f a="path:params">
				<c path="String"/>
				<d/>
				<c path="String"/>
			</f>
			<haxe_doc>* Permet de mettre des paramètre dans un lien HTTP (avec un object)
	 * @param	path Adresse du lien
	 * @param	params Paramètre GET à passer</haxe_doc>
		</formatPath>
		<new set="method" line="44">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* constructeur privé pour éviter qu'une instance soit créée directement</haxe_doc>
		</new>
		<haxe_doc>* ...
 * @author Flavien</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="com.isartdigital.builder.api.Buildings" params="" file="src/com/isartdigital/builder/api/Buildings.hx">
		<instance static="1">
			<c path="com.isartdigital.builder.api.Buildings"/>
			<haxe_doc>* instance unique de la classe Buildings</haxe_doc>
		</instance>
		<getInstance public="1" set="method" line="30" static="1">
			<f a=""><c path="com.isartdigital.builder.api.Buildings"/></f>
			<haxe_doc>* Retourne l'instance unique de la classe, et la crée si elle n'existait pas au préalable
	 * @return instance unique</haxe_doc>
		</getInstance>
		<buildingsPath><c path="String"/></buildingsPath>
		<createPath><c path="String"/></createPath>
		<upgradePath><c path="String"/></upgradePath>
		<collectPath><c path="String"/></collectPath>
		<movePath><c path="String"/></movePath>
		<hardBuildPath><c path="String"/></hardBuildPath>
		<changeColorPath><c path="String"/></changeColorPath>
		<destroyPath><c path="String"/></destroyPath>
		<getAllBuildings public="1" set="method" line="44"><f a="pCallBack">
	<f a="">
		<c path="String"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></getAllBuildings>
		<create public="1" set="method" line="51"><f a="pBuilding:pX:pY:pCallBack">
	<c path="String"/>
	<x path="Int"/>
	<x path="Int"/>
	<f a="">
		<c path="String"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></create>
		<upgrade public="1" set="method" line="58"><f a="pX:pY:pCallBack">
	<x path="Int"/>
	<x path="Int"/>
	<f a="">
		<c path="String"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></upgrade>
		<collect public="1" set="method" line="65"><f a="pX:pY:pCallBack">
	<x path="Int"/>
	<x path="Int"/>
	<f a="">
		<c path="String"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></collect>
		<move public="1" set="method" line="72"><f a="pX_start:pY_start:pX_end:pY_end:pCallBack">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<f a="">
		<c path="String"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></move>
		<hardBuild public="1" set="method" line="79"><f a="pX:pY:pCallBack">
	<x path="Int"/>
	<x path="Int"/>
	<f a="">
		<c path="String"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></hardBuild>
		<changeColor public="1" set="method" line="86"><f a="pColor:pX:pY:pCallBack">
	<c path="String"/>
	<x path="Int"/>
	<x path="Int"/>
	<f a="">
		<c path="String"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></changeColor>
		<destroy public="1" set="method" line="93"><f a="pX:pY:pCallBack">
	<x path="Int"/>
	<x path="Int"/>
	<f a="">
		<c path="String"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></destroy>
		<new set="method" line="38">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* constructeur privé pour éviter qu'une instance soit créée directement</haxe_doc>
		</new>
		<haxe_doc>* ...
 * @author Dorian</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="com.isartdigital.builder.api.DataDef" params="" file="src/com/isartdigital/builder/api/DataDef.hx">
		<a>
			<errorMessage><c path="String"/></errorMessage>
			<errorCode><x path="Int"/></errorCode>
			<error><x path="Bool"/></error>
			<data><d/></data>
		</a>
		<haxe_doc>* @author Flavien</haxe_doc>
	</typedef>
	<class path="com.isartdigital.builder.api.Gifts" params="" file="src/com/isartdigital/builder/api/Gifts.hx">
		<instance static="1">
			<c path="com.isartdigital.builder.api.Gifts"/>
			<haxe_doc>* instance unique de la classe Lantern</haxe_doc>
		</instance>
		<getInstance public="1" set="method" line="21" static="1">
			<f a=""><c path="com.isartdigital.builder.api.Gifts"/></f>
			<haxe_doc>* Retourne l'instance unique de la classe, et la crée si elle n'existait pas au préalable
	 * @return instance unique</haxe_doc>
		</getInstance>
		<giftsPath><c path="String"/></giftsPath>
		<createPath><c path="String"/></createPath>
		<collectPath><c path="String"/></collectPath>
		<getGifts public="1" set="method" line="38"><f a="pCallBack">
	<f a="">
		<c path="String"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></getGifts>
		<create public="1" set="method" line="45"><f a="friendUserId:pCallBack">
	<unknown/>
	<f a="">
		<c path="String"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></create>
		<collect public="1" set="method" line="52"><f a="name:authorName:pCallBack">
	<unknown/>
	<unknown/>
	<f a="">
		<c path="String"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></collect>
		<new set="method" line="33">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* constructeur privé pour éviter qu'une instance soit créée directement</haxe_doc>
		</new>
		<haxe_doc>* ...
 * @author Roman CHEVASSU</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="com.isartdigital.builder.api.Lanterns" params="" file="src/com/isartdigital/builder/api/Lanterns.hx">
		<instance static="1">
			<c path="com.isartdigital.builder.api.Lanterns"/>
			<haxe_doc>* instance unique de la classe Lantern</haxe_doc>
		</instance>
		<getInstance public="1" set="method" line="21" static="1">
			<f a=""><c path="com.isartdigital.builder.api.Lanterns"/></f>
			<haxe_doc>* Retourne l'instance unique de la classe, et la crée si elle n'existait pas au préalable
	 * @return instance unique</haxe_doc>
		</getInstance>
		<lanternsPath><c path="String"/></lanternsPath>
		<createPath><c path="String"/></createPath>
		<getLanterns public="1" set="method" line="37"><f a="pCallBack">
	<f a="">
		<c path="String"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></getLanterns>
		<create public="1" set="method" line="44"><f a="pX:pY:pHardPurchase:pCallBack">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<f a="">
		<c path="String"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></create>
		<new set="method" line="32">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* constructeur privé pour éviter qu'une instance soit créée directement</haxe_doc>
		</new>
		<haxe_doc>* ...
 * @author Roman CHEVASSU</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="com.isartdigital.builder.api.Resources" params="" file="src/com/isartdigital/builder/api/Resources.hx">
		<instance static="1">
			<c path="com.isartdigital.builder.api.Resources"/>
			<haxe_doc>* instance unique de la classe Resources</haxe_doc>
		</instance>
		<getInstance public="1" set="method" line="24" static="1">
			<f a=""><c path="com.isartdigital.builder.api.Resources"/></f>
			<haxe_doc>* Retourne l'instance unique de la classe, et la crée si elle n'existait pas au préalable
	 * @return instance unique</haxe_doc>
		</getInstance>
		<resourcesPath><c path="String"/></resourcesPath>
		<goldPath><c path="String"/></goldPath>
		<spicePath><c path="String"/></spicePath>
		<offeringPath><c path="String"/></offeringPath>
		<get public="1" set="method" line="42"><f a="pCallBack">
	<f a="">
		<c path="String"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></get>
		<gold public="1" set="method" line="53"><f a="pCallBack">
	<f a="">
		<c path="String"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></gold>
		<spice public="1" set="method" line="60"><f a="pCallBack">
	<f a="">
		<c path="String"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></spice>
		<offering public="1" set="method" line="67"><f a="pCallBack">
	<f a="">
		<c path="String"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></offering>
		<new set="method" line="37">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* constructeur privé pour éviter qu'une instance soit créée directement</haxe_doc>
		</new>
		<haxe_doc>* ...
 * @author Flavien</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="com.isartdigital.builder.api.User" params="" file="src/com/isartdigital/builder/api/User.hx">
		<instance static="1">
			<c path="com.isartdigital.builder.api.User"/>
			<haxe_doc>* instance unique de la classe Resources</haxe_doc>
		</instance>
		<getInstance public="1" set="method" line="20" static="1">
			<f a=""><c path="com.isartdigital.builder.api.User"/></f>
			<haxe_doc>* Retourne l'instance unique de la classe, et la crée si elle n'existait pas au préalable
	 * @return instance unique</haxe_doc>
		</getInstance>
		<userPath><c path="String"/></userPath>
		<createPath><c path="String"/></createPath>
		<createFBPath><c path="String"/></createFBPath>
		<userInfoPath public="1"><c path="String"/></userInfoPath>
		<loginPath public="1"><c path="String"/></loginPath>
		<dailyRewardPath><c path="String"/></dailyRewardPath>
		<updatePath><c path="String"/></updatePath>
		<paradePath><c path="String"/></paradePath>
		<buyPath><c path="String"/></buyPath>
		<completePath><c path="String"/></completePath>
		<ftuePath><c path="String"/></ftuePath>
		<experiencePath><c path="String"/></experiencePath>
		<destroyPath><c path="String"/></destroyPath>
		<getUserInfo public="1" set="method" line="44"><f a="pCallBack">
	<f a="">
		<c path="String"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></getUserInfo>
		<getDailyreward public="1" set="method" line="51"><f a="pCallBack">
	<f a="">
		<c path="String"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></getDailyreward>
		<dailyrewardUpdate public="1" set="method" line="58"><f a="pCallBack">
	<f a="">
		<c path="String"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></dailyrewardUpdate>
		<getParade public="1" set="method" line="65"><f a="pCallBack">
	<f a="">
		<c path="String"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></getParade>
		<paradeUpdate public="1" set="method" line="72"><f a="pCallBack">
	<f a="">
		<c path="String"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></paradeUpdate>
		<getFtue public="1" set="method" line="79"><f a="pCallBack">
	<f a="">
		<c path="String"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></getFtue>
		<getExperience public="1" set="method" line="86"><f a="pCallBack">
	<f a="">
		<c path="String"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></getExperience>
		<buy public="1" set="method" line="93"><f a="pName:pCallBack">
	<c path="String"/>
	<f a="">
		<c path="String"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></buy>
		<ftueComplet public="1" set="method" line="100"><f a="pCallBack">
	<f a="">
		<c path="String"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></ftueComplet>
		<destroy public="1" set="method" line="107"><f a="pCallBack">
	<f a="">
		<c path="String"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></destroy>
		<new public="1" set="method" line="39"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* ...
 * @author Flavien</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="com.isartdigital.builder.api.Utils" params="" file="src/com/isartdigital/builder/api/Utils.hx">
		<instance static="1">
			<c path="com.isartdigital.builder.api.Utils"/>
			<haxe_doc>* instance unique de la classe Utils</haxe_doc>
		</instance>
		<getInstance public="1" set="method" line="22" static="1">
			<f a=""><c path="com.isartdigital.builder.api.Utils"/></f>
			<haxe_doc>* Retourne l'instance unique de la classe, et la crée si elle n'existait pas au préalable
	 * @return instance unique</haxe_doc>
		</getInstance>
		<errorHandler public="1" set="method" line="42" static="1">
			<f a="errorCode:errorMessage">
				<x path="Int"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Permet d'afficher le message d'erreur & opération spécifique à l'erreur
	 * @param	errorCode code d'erreur du message
	 * 		1: Bad token
	 * 		2: Model incorrect
	 * @param	errorMessage]]></haxe_doc>
		</errorHandler>
		<destroy public="1" set="method" line="54">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* détruit l'instance unique et met sa référence interne à null</haxe_doc>
		</destroy>
		<new set="method" line="30">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* constructeur privé pour éviter qu'une instance soit créée directement</haxe_doc>
		</new>
		<haxe_doc>* ...
 * @author Dorian</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="com.isartdigital.builder.game.GameManager" params="" file="src/com/isartdigital/builder/game/GameManager.hx">
		<instance static="1">
			<c path="com.isartdigital.builder.game.GameManager"/>
			<haxe_doc>* instance unique de la classe GameManager</haxe_doc>
		</instance>
		<getInstance public="1" set="method" line="57" static="1">
			<f a=""><c path="com.isartdigital.builder.game.GameManager"/></f>
			<haxe_doc>* Retourne l'instance unique de la classe, et la crée si elle n'existait pas au préalable
	 * @return instance unique</haxe_doc>
		</getInstance>
		<mousePosition public="1"><c path="pixi.core.math.Point"/></mousePosition>
		<screenRect public="1"><c path="pixi.core.math.shapes.Rectangle"/></screenRect>
		<get_ScreenRect public="1" set="method" line="48"><f a=""><c path="pixi.core.math.shapes.Rectangle"/></f></get_ScreenRect>
		<refreshMouseCoordinates set="method" line="66"><f a="pEvent">
	<c path="js.html.MouseEvent"/>
	<x path="Void"/>
</f></refreshMouseCoordinates>
		<cb_createUser set="method" line="72"><f a="pData">
	<c path="String"/>
	<x path="Void"/>
</f></cb_createUser>
		<cb_resourceAll set="method" line="83"><f a="pData">
	<c path="String"/>
	<x path="Void"/>
</f></cb_resourceAll>
		<start public="1" set="method" line="96"><f a=""><x path="Void"/></f></start>
		<gameLoop public="1" set="method" line="155">
			<f a="pEvent">
				<t path="pixi.interaction.EventTarget"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* boucle de jeu (répétée à la cadence du jeu en fps)</haxe_doc>
		</gameLoop>
		<doActions set="method" line="177"><f a="list">
	<c path="Array"><c path="com.isartdigital.utils.game.IStateMachine"/></c>
	<x path="Void"/>
</f></doActions>
		<moveCitizen set="method" line="182"><f a=""><x path="Void"/></f></moveCitizen>
		<destroy public="1" set="method" line="192">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* détruit l'instance unique et met sa référence interne à null</haxe_doc>
		</destroy>
		<new set="method" line="62"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* Manager (Singleton) en charge de gérer le déroulement d'une partie
 * @author Mathieu ANTHOINE</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="com.isartdigital.builder.game.def.GiftDef" params="" file="src/com/isartdigital/builder/game/def/GiftDef.hx">
		<a>
			<name><c path="String"/></name>
			<friend_users_id><x path="Int"/></friend_users_id>
		</a>
		<haxe_doc>* @author Dorian</haxe_doc>
	</typedef>
	<typedef path="com.isartdigital.builder.game.def.LanternDef" params="" file="src/com/isartdigital/builder/game/def/LanternDef.hx">
		<a>
			<y><x path="Int"/></y>
			<x><x path="Int"/></x>
		</a>
		<haxe_doc>* @author Dorian</haxe_doc>
	</typedef>
	<typedef path="com.isartdigital.builder.game.def.LocalizationDef" params="" file="src/com/isartdigital/builder/game/def/LocalizationDef.hx">
		<a>
			<title_screen_play><c path="String"/></title_screen_play>
			<title_screen_options><c path="String"/></title_screen_options>
			<title_screen_help><c path="String"/></title_screen_help>
			<title_screen_credits><c path="String"/></title_screen_credits>
			<shop_buy><c path="String"/></shop_buy>
			<hud_shop><c path="String"/></hud_shop>
			<building_construction><c path="String"/></building_construction>
			<building_collect><c path="String"/></building_collect>
		</a>
		<haxe_doc>* @author Thorcal</haxe_doc>
	</typedef>
	<typedef path="com.isartdigital.builder.game.def.MapSavedDef" params="" file="src/com/isartdigital/builder/game/def/MapSavedDef.hx">
		<a><buildings><c path="Array"><d/></c></buildings></a>
		<haxe_doc>* @author Dorian</haxe_doc>
	</typedef>
	<typedef path="com.isartdigital.builder.game.def.ParadeDef" params="" file="src/com/isartdigital/builder/game/def/ParadeDef.hx">
		<a>
			<parade_count><x path="Int"/></parade_count>
			<last_parade_at><c path="String"/></last_parade_at>
		</a>
		<haxe_doc>* @author Dorian</haxe_doc>
	</typedef>
	<typedef path="com.isartdigital.builder.game.def.PointDef" params="" file="src/com/isartdigital/builder/game/def/PointDef.hx">
		<a>
			<y><x path="Float"/></y>
			<x><x path="Float"/></x>
		</a>
		<haxe_doc>* @author Flavien</haxe_doc>
	</typedef>
	<typedef path="com.isartdigital.builder.game.def.ResourceDef" params="" file="src/com/isartdigital/builder/game/def/ResourceDef.hx">
		<a>
			<spice><x path="Int"/></spice>
			<offering><x path="Int"/></offering>
			<gold><x path="Int"/></gold>
		</a>
		<haxe_doc>* @author Dorian</haxe_doc>
	</typedef>
	<typedef path="com.isartdigital.builder.game.def.SizeDef" params="" file="src/com/isartdigital/builder/game/def/SizeDef.hx">
		<a>
			<width><x path="Int"/></width>
			<height><x path="Int"/></height>
		</a>
		<haxe_doc>* Utilisé pour récupéré la longueur (en tiles) d'un batiment
 * @author Dorian</haxe_doc>
	</typedef>
	<typedef path="com.isartdigital.builder.game.def.TileSavedDef" params="" file="src/com/isartdigital/builder/game/def/TileSavedDef.hx">
		<a>
			<y><x path="Int"/></y>
			<x><x path="Int"/></x>
			<isBuildable><x path="Bool"/></isBuildable>
		</a>
		<haxe_doc>* @author Dorian</haxe_doc>
	</typedef>
	<typedef path="com.isartdigital.builder.game.def.UserInfoDef" params="" file="src/com/isartdigital/builder/game/def/UserInfoDef.hx">
		<a>
			<username><c path="String"/></username>
			<resources><t path="com.isartdigital.builder.game.def.ResourceDef"/></resources>
			<parades><t path="com.isartdigital.builder.game.def.ParadeDef"/></parades>
			<lanterns><c path="Array"><t path="com.isartdigital.builder.game.def.LanternDef"/></c></lanterns>
			<gifts><c path="Array"><t path="com.isartdigital.builder.game.def.GiftDef"/></c></gifts>
			<ftue_complet><x path="Bool"/></ftue_complet>
			<experience><x path="Int"/></experience>
			<dailyreward><c path="Date"/></dailyreward>
			<buildings><c path="Array"><d/></c></buildings>
		</a>
		<haxe_doc>* @author Dorian</haxe_doc>
	</typedef>
	<class path="com.isartdigital.builder.game.manager.ClippingManager" params="" file="src/com/isartdigital/builder/game/manager/ClippingManager.hx">
		<Instance line="29" static="1"><c path="com.isartdigital.builder.game.manager.ClippingManager"/></Instance>
		<SAFE_MARGE_VIEW get="inline" set="null" line="31" static="1"><x path="Float"/></SAFE_MARGE_VIEW>
		<SAFE_MARGE_MODEL line="32" static="1"><x path="Float"/></SAFE_MARGE_MODEL>
		<getInstance public="1" set="method" line="51" static="1">
			<f a=""><c path="com.isartdigital.builder.game.manager.ClippingManager"/></f>
			<haxe_doc>* Retourne l'instance unique de la classe, et la crée si elle n'existait pas au préalable
	 * @return instance unique</haxe_doc>
		</getInstance>
		<map><x path="Map">
	<x path="Int"/>
	<x path="Map">
		<x path="Int"/>
		<c path="Array"><d/></c>
	</x>
</x></map>
		<delta><c path="pixi.core.math.Point"/></delta>
		<typeDefModels><c path="Array"><d/></c></typeDefModels>
		<classView><c path="Array"><x path="Class"><c path="com.isartdigital.builder.game.pooling.IPoolObject"/></x></c></classView>
		<screenRectView><f a=""><c path="pixi.core.math.shapes.Rectangle"/></f></screenRectView>
		<objectListView><c path="Array"><c path="Array"><c path="com.isartdigital.builder.game.pooling.IPoolObject"/></c></c></objectListView>
		<screenRectModel><c path="pixi.core.math.shapes.Rectangle"/></screenRectModel>
		<direction><c path="String"/></direction>
		<clipInX><x path="Int"/></clipInX>
		<clipInY><x path="Int"/></clipInY>
		<currentScreenPosition><c path="pixi.core.math.Point"/></currentScreenPosition>
		<screenPosition><c path="pixi.core.math.Point"/></screenPosition>
		<TOP_RIGHT><c path="pixi.core.math.Point"/></TOP_RIGHT>
		<BOTTOM_LEFT><c path="pixi.core.math.Point"/></BOTTOM_LEFT>
		<BOTTOM_RIGHT><c path="pixi.core.math.Point"/></BOTTOM_RIGHT>
		<BOTTOM_RIGHT_RIGHT><c path="pixi.core.math.Point"/></BOTTOM_RIGHT_RIGHT>
		<setOn public="1" set="method" line="81">
			<f a="pMapModel:pListView:pDelta:pDef:pBuilding:pScreeRectRef">
				<x path="Map">
					<x path="Int"/>
					<x path="Map">
						<x path="Int"/>
						<c path="Array"><d/></c>
					</x>
				</x>
				<c path="Array"><c path="Array"><c path="com.isartdigital.builder.game.pooling.IPoolObject"/></c></c>
				<c path="pixi.core.math.Point"/>
				<c path="Array"><d/></c>
				<c path="Array"><x path="Class"><c path="com.isartdigital.builder.game.pooling.IPoolObject"/></x></c>
				<f a=""><c path="pixi.core.math.shapes.Rectangle"/></f>
				<x path="Void"/>
			</f>
			<haxe_doc>* Configue le clipping.
	 * les index de pBuilding doit correspondre aux index de pTypeDef
	 * @param	pMap Map de Modèle
	 * @param	pDelta delta de clipping
	 * @param	pDef TypeDef du modèle
	 * @param	pBuilding Class de sortie qui implémente le pooling
	 * @param	pScreeRectRef getter du carré de référence</haxe_doc>
		</setOn>
		<manage public="1" set="method" line="106">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Fais le taff</haxe_doc>
		</manage>
		<addAllObjetInView public="1" set="method" line="122"><f a=""><x path="Void"/></f></addAllObjetInView>
		<addObject set="method" line="127"><f a=""><x path="Void"/></f></addObject>
		<createObjFromModel set="method" line="139"><f a="pArray">
	<c path="Array"><d/></c>
	<x path="Void"/>
</f></createObjFromModel>
		<modelExist set="method" line="164"><f a="pList:pModel">
	<c path="Array"><c path="com.isartdigital.builder.game.pooling.IPoolObject"/></c>
	<d/>
	<x path="Bool"/>
</f></modelExist>
		<getAllRow set="method" line="175"><f a=""><c path="Array"><d/></c></f></getAllRow>
		<getObjInPosition set="method" line="193"><f a="pMap:pPosition">
	<x path="Map">
		<x path="Int"/>
		<x path="Map">
			<x path="Int"/>
			<c path="Array"><d/></c>
		</x>
	</x>
	<c path="pixi.core.math.Point"/>
	<c path="Array"><d/></c>
</f></getObjInPosition>
		<getLeftCol set="method" line="206"><f a=""><c path="Array"><d/></c></f></getLeftCol>
		<getRightCol set="method" line="228"><f a=""><c path="Array"><d/></c></f></getRightCol>
		<getDownRow set="method" line="247"><f a=""><c path="Array"><d/></c></f></getDownRow>
		<getUpRow set="method" line="270"><f a=""><c path="Array"><d/></c></f></getUpRow>
		<shiftHorizontal set="method" line="289"><f a="pPoint">
	<c path="pixi.core.math.Point"/>
	<x path="Void"/>
</f></shiftHorizontal>
		<shiftVertical set="method" line="295"><f a="pPoint">
	<c path="pixi.core.math.Point"/>
	<x path="Void"/>
</f></shiftVertical>
		<setScreenRectModel set="method" line="301"><f a=""><x path="Void"/></f></setScreenRectModel>
		<removeObject set="method" line="325"><f a=""><x path="Void"/></f></removeObject>
		<removeInList set="method" line="333"><f a="pList">
	<c path="Array"><c path="com.isartdigital.builder.game.pooling.IPoolObject"/></c>
	<x path="Void"/>
</f></removeInList>
		<rectIsInRect set="method" line="343"><f a="pBase:pRect">
	<c path="pixi.core.math.shapes.Rectangle"/>
	<c path="pixi.core.math.shapes.Rectangle"/>
	<x path="Bool"/>
</f></rectIsInRect>
		<distBetween set="method" line="363"><f a="pPointA:pPointB">
	<c path="pixi.core.math.Point"/>
	<c path="pixi.core.math.Point"/>
	<x path="Float"/>
</f></distBetween>
		<hadToManage set="method" line="372">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* Renvoie true si le dernier manage était assez loin
	 * @return</haxe_doc>
		</hadToManage>
		<new set="method" line="67"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* Système de clipping d'objets
 * @author Flavien</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="com.isartdigital.builder.game.manager.Manager" params="" file="src/com/isartdigital/builder/game/manager/Manager.hx">
		<instance static="1">
			<c path="com.isartdigital.builder.game.manager.Manager"/>
			<haxe_doc>* instance unique de la classe Manager</haxe_doc>
		</instance>
		<getInstance public="1" set="method" line="22" static="1">
			<f a=""><c path="com.isartdigital.builder.game.manager.Manager"/></f>
			<haxe_doc>* Retourne l'instance unique de la classe, et la crée si elle n'existait pas au préalable
	 * @return instance unique</haxe_doc>
		</getInstance>
		<list public="1"><c path="Array"><d/></c></list>
		<destroy public="1" set="method" line="38">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* détruit l'instance unique et met sa référence interne à null</haxe_doc>
		</destroy>
		<new set="method" line="30">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* constructeur privé pour éviter qu'une instance soit créée directement</haxe_doc>
		</new>
		<haxe_doc>* ...
 * @author Dorian</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="com.isartdigital.builder.game.manager.MapManager" params="" file="src/com/isartdigital/builder/game/manager/MapManager.hx">
		<extends path="com.isartdigital.builder.game.manager.Manager"/>
		<instance static="1">
			<c path="com.isartdigital.builder.game.manager.MapManager"/>
			<haxe_doc>* instance unique de la classe MapManager</haxe_doc>
		</instance>
		<getInstance public="1" set="method" line="50" static="1">
			<f a=""><c path="com.isartdigital.builder.game.manager.MapManager"/></f>
			<haxe_doc>* Retourne l'instance unique de la classe, et la crée si elle n'existait pas au préalable
	 * @return instance unique</haxe_doc>
		</getInstance>
		<mapSize public="1"><x path="Int"/></mapSize>
		<globalMap public="1"><x path="Map">
	<x path="Int"/>
	<x path="Map">
		<x path="Int"/>
		<c path="Array"><d/></c>
	</x>
</x></globalMap>
		<generateMap public="1" set="method" line="67">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Génère une nouvelle map de base si il n'y a pas de sauvegarde, sinon charge la sauvegarde
	 * @return Success ou fail</haxe_doc>
		</generateMap>
		<isBuildable public="1" set="method" line="78">
			<f a="pTiles">
				<c path="Array"><t path="com.isartdigital.builder.game.def.TileSavedDef"/></c>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Permet de savoir si un batiment est construisable à un endroit donnée
	 * @param	Array des tiles concerné (Récupérable grâce à getTilesArray(pPosition:Point, pSize:SizeDef):Array<TileSavedDef>)
	 * @return]]></haxe_doc>
		</isBuildable>
		<getTilesArray public="1" set="method" line="99">
			<f a="pPosition:pSize">
				<c path="pixi.core.math.Point"/>
				<t path="com.isartdigital.builder.game.def.SizeDef"/>
				<c path="Array"><t path="com.isartdigital.builder.game.def.TileSavedDef"/></c>
			</f>
			<haxe_doc>* Récupère un tableau contenant les tiles à une position avec une taille donné
	 * @param	pPosition position de la tile initial
	 * @param	pSize taille
	 * @return Array de tiles ou null si l'array exède les limitation de la map</haxe_doc>
		</getTilesArray>
		<setTilesBuildable public="1" set="method" line="126">
			<f a="tiles:_isBuildable">
				<c path="Array"><t path="com.isartdigital.builder.game.def.TileSavedDef"/></c>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Modifie la propriété isBuildable d'un array de tiles
	 * @param	Array<TileSavedDef>
	 * @param	isBuildable]]></haxe_doc>
		</setTilesBuildable>
		<getElementByTypeDefInArray public="1" set="method" line="151">
			<f a="elements:typeDef">
				<c path="Array"><d/></c>
				<d/>
				<d/>
			</f>
			<haxe_doc>* Récupère un element dans un array grâce à son typeDef
	 * (Hack conseillé par Nicolas Cannasse)
	 * @param	typeDef typeDef de l'element à comparer (Trouvable dans TypeDefUtils) ex : TypeDefUtils.tileSavedDef
	 * @return Renvoie l'element trouvé, si il le trouve pas, rnevoi null</haxe_doc>
		</getElementByTypeDefInArray>
		<isElementAtPositionInMap public="1" set="method" line="165">
			<f a="map:x:y">
				<x path="Map">
					<x path="Int"/>
					<x path="Map">
						<x path="Int"/>
						<c path="Array"><d/></c>
					</x>
				</x>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Test si il y a un element dans la globalMap à la position donné
	 * @param	x
	 * @param	y
	 * @return boolean</haxe_doc>
		</isElementAtPositionInMap>
		<getElementInGlobalMapAt public="1" set="method" line="180">
			<f a="position:typeDef">
				<c path="pixi.core.math.Point"/>
				<d/>
				<d/>
			</f>
			<haxe_doc>* Récupère un element dans la global map à une position grâce à un typedef
	 * @param	position de l'element
	 * @param	element à récuperer</haxe_doc>
		</getElementInGlobalMapAt>
		<addElementInGlobalMapAt public="1" set="method" line="197">
			<f a="position:element">
				<c path="pixi.core.math.Point"/>
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Ajoute un element dans la globalMap grâce à sa position
	 * @param	position dans la map
	 * @param	element à ajouter</haxe_doc>
		</addElementInGlobalMapAt>
		<removeElementByTypeDefFromGlobalMapAt public="1" set="method" line="209">
			<f a="position:typeDef">
				<c path="pixi.core.math.Point"/>
				<d/>
				<d/>
			</f>
			<haxe_doc>* Enlève un element de la map grâce à sa position et return l'element enlevé
	 * @param	position dans la map de l'element à enlever
	 * @param	typeDef de l'element à enlever
	 * @return Renvoi l'element enlevé</haxe_doc>
		</removeElementByTypeDefFromGlobalMapAt>
		<loadMap set="method" line="228">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* Charge la map sauvegardé
	 * @return Si le chargement de la map a réussi ou non</haxe_doc>
		</loadMap>
		<getTileAtPosition set="method" line="283">
			<f a="x:y">
				<x path="Int"/>
				<x path="Int"/>
				<t path="com.isartdigital.builder.game.def.TileSavedDef"/>
			</f>
			<haxe_doc>* Récupère une tile à la position indiqué
	 * @param pPosition - Position de la grille
	 * @return Tile récupéré</haxe_doc>
		</getTileAtPosition>
		<isInsideGrid set="method" line="298">
			<f a="pX:pY">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Indique si la position est hors de la grille ou à l'interieur
	 * @return</haxe_doc>
		</isInsideGrid>
		<displayTilePositionUnderMouse public="1" set="method" line="316">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* /!\ fonction de debuggage
	 * Affiche la position de la tile sous la souris</haxe_doc>
		</displayTilePositionUnderMouse>
		<importBuildingsClass set="method" line="328">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Hack pour forcer l'exportation des class.
	 * Mettre ici toutes les class non importer sinon cause le bug suivant : Uncaught TypeError: cl is not a function</haxe_doc>
		</importBuildingsClass>
		<new set="method" line="58">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* constructeur privé pour éviter qu'une instance soit créée directement</haxe_doc>
		</new>
		<haxe_doc>* ...
 * @author Dorian</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="pathfinder.IMap" params="" file="C:\HaxeToolkit\haxe\lib\pathfinder/0,2,18/pathfinder/IMap.hx" interface="1">
		<rows public="1" set="null">
			<x path="Int"/>
			<haxe_doc>* Total rows (horizontal divisions) in the Map (y)</haxe_doc>
		</rows>
		<cols public="1" set="null">
			<x path="Int"/>
			<haxe_doc>* Total columns (vertical divisions) in the Map (x)</haxe_doc>
		</cols>
		<isWalkable public="1" set="method">
			<f a="p_x:p_y">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Returns whether a coordinate on the map is walkable, or obstructed.
	 * @param	p_x	The column
	 * @param	p_y	The row
	 * @return	true if walkable, false if obstructed</haxe_doc>
		</isWalkable>
		<haxe_doc>* @author Statm	https://github.com/statm/haxe-astar
 * @author Robert Fell</haxe_doc>
	</class>
	<class path="com.isartdigital.builder.game.manager.Maps" params="" file="src/com/isartdigital/builder/game/manager/Maps.hx">
		<implements path="pathfinder.IMap"/>
		<rows public="1" set="null"><x path="Int"/></rows>
		<cols public="1" set="null"><x path="Int"/></cols>
		<isWalkable public="1" set="method" line="20"><f a="p_x:p_y">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
</f></isWalkable>
		<new public="1" set="method" line="13"><f a="p_cols:p_rows">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* ...
 * @author Thorcal</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="com.isartdigital.builder.game.manager.RessourceManager" params="" file="src/com/isartdigital/builder/game/manager/RessourceManager.hx">
		<extends path="com.isartdigital.builder.game.manager.Manager"/>
		<instance static="1">
			<c path="com.isartdigital.builder.game.manager.RessourceManager"/>
			<haxe_doc>* instance unique de la classe RessourceManager</haxe_doc>
		</instance>
		<getInstance public="1" set="method" line="29" static="1">
			<f a=""><c path="com.isartdigital.builder.game.manager.RessourceManager"/></f>
			<haxe_doc>* Retourne l'instance unique de la classe, et la crée si elle n'existait pas au préalable
	 * @return instance unique</haxe_doc>
		</getInstance>
		<ressources public="1"><x path="Map">
	<e path="com.isartdigital.builder.game.manager.Ressources"/>
	<x path="Int"/>
</x></ressources>
		<start public="1" set="method" line="42"><f a=""><x path="Void"/></f></start>
		<getRessources public="1" set="method" line="54">
			<f a="pRessource">
				<e path="com.isartdigital.builder.game.manager.Ressources"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Renvoie le nombre de ressource pour la ressource donnée en parametre
	 * @param	pRessource</haxe_doc>
		</getRessources>
		<addRessources public="1" set="method" line="63">
			<f a="pRessource:pNumber">
				<e path="com.isartdigital.builder.game.manager.Ressources"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Ajoute pNumber à pRessource
	 * @param	pRessource
	 * @param	pNumber</haxe_doc>
		</addRessources>
		<removeRessources public="1" set="method" line="75">
			<f a="pRessource:pNumber">
				<e path="com.isartdigital.builder.game.manager.Ressources"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Retire pNumber à pRessource
	 * @param	pRessource
	 * @param	pNumber</haxe_doc>
		</removeRessources>
		<updateSpice public="1"><f a="">
	<x path="Int"/>
	<x path="Void"/>
</f></updateSpice>
		<updateGold public="1"><f a="">
	<x path="Int"/>
	<x path="Void"/>
</f></updateGold>
		<updateOfferings public="1"><f a="">
	<x path="Int"/>
	<x path="Void"/>
</f></updateOfferings>
		<updateRessources public="1" set="method" line="87"><f a=""><x path="Void"/></f></updateRessources>
		<cbOnResourcesCall set="method" line="92"><f a="pData">
	<c path="String"/>
	<x path="Void"/>
</f></cbOnResourcesCall>
		<updateAllRessources public="1" set="method" line="103"><f a="lResource">
	<t path="com.isartdigital.builder.game.def.ResourceDef"/>
	<x path="Void"/>
</f></updateAllRessources>
		<destroy public="1" set="method" line="112" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* détruit l'instance unique et met sa référence interne à null</haxe_doc>
		</destroy>
		<new set="method" line="37">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* constructeur privé pour éviter qu'une instance soit créée directement</haxe_doc>
		</new>
		<haxe_doc>* ...
 * @author Thorcal</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<enum path="com.isartdigital.builder.game.manager.Ressources" params="" file="src/com/isartdigital/builder/game/manager/Ressources.hx">
		<SPICE/>
		<GOLD/>
		<OFFERINGS/>
		<haxe_doc>* @author Thorcal</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<class path="com.isartdigital.builder.game.pooling.IPoolObject" params="" file="src/com/isartdigital/builder/game/pooling/IPoolObject.hx" interface="1">
		<x public="1"><x path="Float"/></x>
		<y public="1"><x path="Float"/></y>
		<width public="1"><x path="Float"/></width>
		<height public="1"><x path="Float"/></height>
		<position public="1"><c path="pixi.core.math.Point"/></position>
		<remove public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<haxe_doc><![CDATA[* Nettoye l'objet et l'ajoute a une poolList -> PoolObject.add
	 * Si l'objet ne peux pas être ajouté dans une poolList -> détruire l'objet]]></haxe_doc>
		</remove>
		<init public="1" set="method">
			<f a="pDefinition">
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>* initialise l'objet
	 * @param	pDefinition</haxe_doc>
		</init>
		<haxe_doc>* @author Flavien</haxe_doc>
	</class>
	<class path="com.isartdigital.builder.game.pooling.PoolObject" params="" file="src/com/isartdigital/builder/game/pooling/PoolObject.hx">
		<poolList line="14" static="1">
			<x path="Map">
				<c path="String"/>
				<c path="Array"><d/></c>
			</x>
			<haxe_doc>* Map de liste de pooling</haxe_doc>
		</poolList>
		<objectMarge get="inline" set="null" line="19" static="1">
			<x path="Int"/>
			<haxe_doc>* Nombre d'objet créé si une liste est vide</haxe_doc>
		</objectMarge>
		<objectListLimit get="inline" set="null" line="24" static="1">
			<x path="Int"/>
			<haxe_doc>* Nombre d'objet maximum dans une liste</haxe_doc>
		</objectListLimit>
		<create public="1" set="method" line="31" static="1">
			<f a="pClass">
				<x path="Class"><d/></x>
				<d/>
			</f>
			<haxe_doc>* Donne instance de pClass depuis une poolList
	 * @param	pClass la classe de l'objet a instancié
	 * @return une instance de pClass</haxe_doc>
		</create>
		<addPool public="1" set="method" line="47" static="1">
			<f a="pObject">
				<d/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Ajoute un Object a une poolList
	 * @param	pObject
	 * @return false si l'objet ne peux pas être ajouté à une liste</haxe_doc>
		</addPool>
		<createPoolList public="1" set="method" line="63" static="1">
			<f a="pClass">
				<x path="Class"><d/></x>
				<x path="Void"/>
			</f>
			<haxe_doc>* Crée une liste de pooling de la classe pClass
	 * @param	pClass</haxe_doc>
		</createPoolList>
		<addObjectToPoolList set="method" line="75" static="1">
			<f a="pName:pClass">
				<c path="String"/>
				<x path="Class"><d/></x>
				<x path="Void"/>
			</f>
			<haxe_doc>* ajoute des objets à une liste de pooling
	 * @param	pName
	 * @param	pClass</haxe_doc>
		</addObjectToPoolList>
		<new set="method" line="84"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* Système de Pooling
 * @author Flavien</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="pixi.interaction.EventEmitter" params="" file="C:\HaxeToolkit\haxe\lib\pixijs/3,0,25/pixi/interaction/EventEmitter.hx" extern="1">
		<listeners public="1" set="method">
			<f a="event">
				<c path="String"/>
				<c path="Array"><d/></c>
			</f>
			<haxe_doc>* Return a list of assigned event listeners.
	 *
	 * @param {String} eventName
	 * @returns {Array}</haxe_doc>
		</listeners>
		<emit public="1" set="method">
			<f a="event:?a1:?a2:?a3:?a4:?a5">
				<c path="String"/>
				<d/>
				<d/>
				<d/>
				<d/>
				<d/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Emit an event to all registered event listeners.
     *
     * @alias dispatchEvent
     * @param eventName {String} The name of the event.
     * @return {Bool} Indication if we've emitted an event.</haxe_doc>
		</emit>
		<on public="1" set="method">
			<f a="event:fn:?context">
				<c path="String"/>
				<f a="">
					<t path="pixi.interaction.EventTarget"/>
					<x path="Void"/>
				</f>
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Register a new EventListener for the given event.
	 *
	 * @param {String} event Name of the event.
	 * @param {function} fn Callback function.
	 * @param {Mixed} context The context of the function.</haxe_doc>
			<overloads>
				<on public="1" set="method">
					<f a="event:fn:?context">
						<c path="String"/>
						<f a=""><x path="Void"/></f>
						<d/>
						<x path="Void"/>
					</f>
					<haxe_doc>* Register a new EventListener for the given event.
	 *
	 * @param {String} event Name of the event.
	 * @param {function} fn Callback function.
	 * @param {Mixed} context The context of the function.</haxe_doc>
				</on>
				<on public="1" set="method">
					<f a="event:fn:?context">
						<c path="String"/>
						<f a="">
							<d/>
							<x path="Void"/>
						</f>
						<d/>
						<x path="Void"/>
					</f>
					<haxe_doc>* Register a new EventListener for the given event.
	 *
	 * @param {String} event Name of the event.
	 * @param {function} fn Callback function.
	 * @param {Mixed} context The context of the function.</haxe_doc>
				</on>
			</overloads>
		</on>
		<once public="1" set="method">
			<f a="event:fn:?context">
				<c path="String"/>
				<f a="">
					<t path="pixi.interaction.EventTarget"/>
					<x path="Void"/>
				</f>
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Add an EventListener that's only called once.
	 *
	 * @param {String} event Name of the event.
	 * @param {function} fn Callback function.
	 * @param {Mixed} context The context of the function.</haxe_doc>
			<overloads>
				<once public="1" set="method">
					<f a="event:fn:?context">
						<c path="String"/>
						<f a=""><x path="Void"/></f>
						<d/>
						<x path="Void"/>
					</f>
					<haxe_doc>* Add an EventListener that's only called once.
	 *
	 * @param {String} event Name of the event.
	 * @param {function} fn Callback function.
	 * @param {Mixed} context The context of the function.</haxe_doc>
				</once>
				<once public="1" set="method">
					<f a="event:fn:?context">
						<c path="String"/>
						<f a="">
							<d/>
							<x path="Void"/>
						</f>
						<d/>
						<x path="Void"/>
					</f>
					<haxe_doc>* Add an EventListener that's only called once.
	 *
	 * @param {String} event Name of the event.
	 * @param {function} fn Callback function.
	 * @param {Mixed} context The context of the function.</haxe_doc>
				</once>
			</overloads>
		</once>
		<addListener public="1" set="method">
			<f a="event:fn:?context">
				<c path="String"/>
				<f a="">
					<t path="pixi.interaction.EventTarget"/>
					<x path="Void"/>
				</f>
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Register a new EventListener for the given event.
	 *
	 * @param {String} event Name of the event.
	 * @param {function} fn Callback function.
	 * @param {Mixed} context The context of the function.</haxe_doc>
			<overloads>
				<addListener public="1" set="method">
					<f a="event:fn:?context">
						<c path="String"/>
						<f a=""><x path="Void"/></f>
						<d/>
						<x path="Void"/>
					</f>
					<haxe_doc>* Register a new EventListener for the given event.
	 *
	 * @param {String} event Name of the event.
	 * @param {function} fn Callback function.
	 * @param {Mixed} context The context of the function.</haxe_doc>
				</addListener>
				<addListener public="1" set="method">
					<f a="event:fn:?context">
						<c path="String"/>
						<f a="">
							<d/>
							<x path="Void"/>
						</f>
						<d/>
						<x path="Void"/>
					</f>
					<haxe_doc>* Register a new EventListener for the given event.
	 *
	 * @param {String} event Name of the event.
	 * @param {function} fn Callback function.
	 * @param {Mixed} context The context of the function.</haxe_doc>
				</addListener>
			</overloads>
		</addListener>
		<off public="1" set="method">
			<f a="event:fn:?once">
				<c path="String"/>
				<f a="">
					<t path="pixi.interaction.EventTarget"/>
					<x path="Void"/>
				</f>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Remove event listeners.
	 *
	 * @param {String} event The event we want to remove.
	 * @param {function} fn The listener that we need to find.
	 * @param {Bool} once Only remove once listeners.</haxe_doc>
			<overloads>
				<off public="1" set="method">
					<f a="event:fn:?once">
						<c path="String"/>
						<f a=""><x path="Void"/></f>
						<x path="Bool"/>
						<x path="Void"/>
					</f>
					<haxe_doc>* Remove event listeners.
	 *
	 * @param {String} event The event we want to remove.
	 * @param {function} fn The listener that we need to find.
	 * @param {Bool} once Only remove once listeners.</haxe_doc>
				</off>
				<off public="1" set="method">
					<f a="event:fn:?once">
						<c path="String"/>
						<f a="">
							<d/>
							<x path="Void"/>
						</f>
						<x path="Bool"/>
						<x path="Void"/>
					</f>
					<haxe_doc>* Remove event listeners.
	 *
	 * @param {String} event The event we want to remove.
	 * @param {function} fn The listener that we need to find.
	 * @param {Bool} once Only remove once listeners.</haxe_doc>
				</off>
			</overloads>
		</off>
		<removeListener public="1" set="method">
			<f a="event:fn:?once">
				<c path="String"/>
				<f a="">
					<t path="pixi.interaction.EventTarget"/>
					<x path="Void"/>
				</f>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Remove event listeners.
	 *
	 * @param {String} event The event we want to remove.
	 * @param {function} fn The listener that we need to find.
	 * @param {Bool} once Only remove once listeners.</haxe_doc>
			<overloads>
				<removeListener public="1" set="method">
					<f a="event:fn:?once">
						<c path="String"/>
						<f a=""><x path="Void"/></f>
						<x path="Bool"/>
						<x path="Void"/>
					</f>
					<haxe_doc>* Remove event listeners.
	 *
	 * @param {String} event The event we want to remove.
	 * @param {function} fn The listener that we need to find.
	 * @param {Bool} once Only remove once listeners.</haxe_doc>
				</removeListener>
				<removeListener public="1" set="method">
					<f a="event:fn:?once">
						<c path="String"/>
						<f a="">
							<d/>
							<x path="Void"/>
						</f>
						<x path="Bool"/>
						<x path="Void"/>
					</f>
					<haxe_doc>* Remove event listeners.
	 *
	 * @param {String} event The event we want to remove.
	 * @param {function} fn The listener that we need to find.
	 * @param {Bool} once Only remove once listeners.</haxe_doc>
				</removeListener>
			</overloads>
		</removeListener>
		<removeAllListeners public="1" set="method">
			<f a="?event">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Remove all listeners or only the listeners for the specified event.
	 *
	 * @param {String} event The event want to remove all listeners for.</haxe_doc>
		</removeAllListeners>
		<new public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Minimal EventEmitter interface that is molded against the Node.js
	 * EventEmitter interface.
	 *
	 * @constructor</haxe_doc>
		</new>
	</class>
	<class path="pixi.interaction.InteractionManager" params="" file="C:\HaxeToolkit\haxe\lib\pixijs/3,0,25/pixi/interaction/InteractionManager.hx" extern="1">
		<extends path="pixi.interaction.EventEmitter"/>
		<renderer public="1">
			<c path="pixi.core.renderers.SystemRenderer"/>
			<haxe_doc>* The renderer this interaction manager works for.
     *
     * @member {SystemRenderer}</haxe_doc>
		</renderer>
		<autoPreventDefault public="1">
			<x path="Bool"/>
			<haxe_doc>* Should default browser actions automatically be prevented.
     *
     * @member {Bool}
     * @default true</haxe_doc>
		</autoPreventDefault>
		<interactionFrequency public="1">
			<x path="Int"/>
			<haxe_doc>* As this frequency increases the interaction events will be checked more often.
     *
     * @member {Int}
     * @default 10</haxe_doc>
		</interactionFrequency>
		<mouse public="1">
			<c path="pixi.interaction.InteractionData"/>
			<haxe_doc>* The mouse data
     *
     * @member {InteractionData}</haxe_doc>
		</mouse>
		<eventData public="1">
			<t path="pixi.interaction.EventTarget"/>
			<haxe_doc>* An event data object to handle all the event tracking/dispatching
     *
     * @member {EventTarget}</haxe_doc>
		</eventData>
		<interactiveDataPool public="1">
			<c path="Array"><c path="pixi.interaction.InteractionData"/></c>
			<haxe_doc>* Tiny little interactiveData pool !
     *
     * @member {Array}</haxe_doc>
		</interactiveDataPool>
		<onMouseUp public="1">
			<f a="">
				<t path="pixi.interaction.EventTarget"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* @member {function}</haxe_doc>
		</onMouseUp>
		<onMouseDown public="1">
			<f a="">
				<t path="pixi.interaction.EventTarget"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* @member {function}</haxe_doc>
		</onMouseDown>
		<onMouseMove public="1">
			<f a="">
				<t path="pixi.interaction.EventTarget"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* @member {function}</haxe_doc>
		</onMouseMove>
		<onMouseOut public="1">
			<f a="">
				<t path="pixi.interaction.EventTarget"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* @member {function}</haxe_doc>
		</onMouseOut>
		<onTouchStart public="1">
			<f a="">
				<t path="pixi.interaction.EventTarget"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* @member {function}</haxe_doc>
		</onTouchStart>
		<onTouchEnd public="1">
			<f a="">
				<t path="pixi.interaction.EventTarget"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* @member {function}</haxe_doc>
		</onTouchEnd>
		<onTouchMove public="1">
			<f a="">
				<t path="pixi.interaction.EventTarget"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* @member {function}</haxe_doc>
		</onTouchMove>
		<tap public="1">
			<f a="">
				<t path="pixi.interaction.EventTarget"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* @member {function}</haxe_doc>
		</tap>
		<click public="1">
			<f a="">
				<t path="pixi.interaction.EventTarget"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* @member {function}</haxe_doc>
		</click>
		<last public="1">
			<x path="Int"/>
			<haxe_doc>* @member {Int}</haxe_doc>
		</last>
		<currentCursorStyle public="1">
			<c path="String"/>
			<haxe_doc>* The css style of the cursor that is being used
     * @member {String}</haxe_doc>
		</currentCursorStyle>
		<mapPositionToPoint public="1" set="method">
			<f a="point:x:y">
				<c path="pixi.core.math.Point"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Maps x and y coords from a DOM object and maps them correctly to the pixi view. The resulting value is stored in the point.
	 * This takes into account the fact that the DOM element could be scaled and positioned anywhere on the screen.
	 *
	 * @param  {Point} point the point that the result will be stored in
	 * @param  {Float} x the x coord of the position to map
	 * @param  {Float} y the y coord of the position to map</haxe_doc>
		</mapPositionToPoint>
		<processInteractive public="1" set="method">
			<f a="point:displayObject:func:hitTest:interactive">
				<c path="pixi.core.math.Point"/>
				<c path="pixi.core.display.DisplayObject"/>
				<f a=""><x path="Void"/></f>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* This function is provides a neat way of crawling through the scene graph and running a specified 	function on all interactive objects it finds.
	 * It will also take care of hit testing the interactive objects and passes the hit across in the 	function.
	 *
	 * @param  {Point} point the point that is tested for collision
	 * @param  {Container|Sprite|TilingSprite} displayObject the displayObject that will be hit test (recurcsivly crawls its children)
	 * @param  {function} func the 	function that will be called on each interactive object. The displayObject and hit will be passed to the 	function
	 * @param  {Bool} hitTest this indicates if the objects inside should be hit test against the point
	 * @return {Bool} returns true if the displayObject hit the point</haxe_doc>
		</processInteractive>
		<new public="1" set="method">
			<f a="renderer">
				<c path="pixi.core.renderers.webgl.WebGLRenderer"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* The interaction manager deals with mouse and touch events. Any DisplayObject can be interactive
	 * if its interactive parameter is set to true
	 * This manager also supports multitouch.
	 *
	 * @class
	 * @memberof PIXI.interaction
	 * @param renderer {CanvasRenderer|WebGLRenderer} A reference to the current renderer
	 * @param [options] {object}
	 * @param [options.autoPreventDefault=true] {boolean} Should the manager automatically prevent default browser actions.
	 * @param [options.interactionFrequency=10] {number} Frequency increases the interaction events will be checked.</haxe_doc>
			<overloads><new public="1" set="method">
	<f a="renderer:?options">
		<c path="pixi.core.renderers.canvas.CanvasRenderer"/>
		<t path="pixi.interaction.InteractionManagerOptions"/>
		<x path="Void"/>
	</f>
	<haxe_doc>* The interaction manager deals with mouse and touch events. Any DisplayObject can be interactive
	 * if its interactive parameter is set to true
	 * This manager also supports multitouch.
	 *
	 * @class
	 * @memberof PIXI.interaction
	 * @param renderer {CanvasRenderer|WebGLRenderer} A reference to the current renderer
	 * @param [options] {object}
	 * @param [options.autoPreventDefault=true] {boolean} Should the manager automatically prevent default browser actions.
	 * @param [options.interactionFrequency=10] {number} Frequency increases the interaction events will be checked.</haxe_doc>
</new></overloads>
		</new>
		<meta><m n=":native"><e>"PIXI.interaction.InteractionManager"</e></m></meta>
	</class>
	<class path="pixi.core.display.DisplayObject" params="" file="C:\HaxeToolkit\haxe\lib\pixijs/3,0,25/pixi/core/display/DisplayObject.hx" extern="1">
		<extends path="pixi.interaction.InteractionManager"/>
		<getGlobalPosition public="1" set="method">
			<f a="point">
				<c path="pixi.core.math.Point"/>
				<c path="pixi.core.math.Point"/>
			</f>
			<haxe_doc>* Returns the global position of the displayObject
	 *
	 * @param point {Point} the point to write the global value to. If null a new point will be returned
	 * @return {Point}</haxe_doc>
		</getGlobalPosition>
		<getBounds public="1" set="method">
			<f a="?matrix">
				<c path="pixi.core.math.Matrix"/>
				<c path="pixi.core.math.shapes.Rectangle"/>
			</f>
			<haxe_doc>* Retrieves the bounds of the displayObject as a rectangle object
	 *
	 * @param matrix {Matrix}
	 * @return {Rectangle} the rectangular bounding area</haxe_doc>
		</getBounds>
		<getLocalBounds public="1" set="method">
			<f a=""><c path="pixi.core.math.shapes.Rectangle"/></f>
			<haxe_doc>* Retrieves the local bounds of the displayObject as a rectangle object
	 *
	 * @return {Rectangle} the rectangular bounding area</haxe_doc>
		</getLocalBounds>
		<toGlobal public="1" set="method">
			<f a="position">
				<c path="pixi.core.math.Point"/>
				<c path="pixi.core.math.Point"/>
			</f>
			<haxe_doc>* Calculates the global position of the display object
	 *
	 * @param position {Point} The world origin to calculate from
	 * @return {Point} A point object representing the position of this object</haxe_doc>
		</toGlobal>
		<toLocal public="1" set="method">
			<f a="position:?frm">
				<c path="pixi.core.math.Point"/>
				<c path="pixi.core.display.DisplayObject"/>
				<c path="pixi.core.math.Point"/>
			</f>
			<haxe_doc>* Calculates the local position of the display object relative to another point
	 *
	 * @param position {Point} The world origin to calculate from
	 * @param [from] {DisplayObject} The DisplayObject to calculate the global position from
	 * @return {Point} A point object representing the position of this object</haxe_doc>
		</toLocal>
		<generateTexture public="1" set="method">
			<f a="renderer:?resolution:?scaleMode">
				<c path="pixi.core.renderers.webgl.WebGLRenderer"/>
				<x path="Float"/>
				<x path="Int"/>
				<c path="pixi.core.textures.Texture"/>
			</f>
			<haxe_doc>* Useful function that returns a texture of the display object that can then be used to create sprites
	 * This can be quite useful if your displayObject is static / complicated and needs to be reused multiple times.
	 *
	 * @param renderer {CanvasRenderer|WebGLRenderer} The renderer used to generate the texture.
	 * @param resolution {Number} The resolution of the texture being generated
	 * @param scaleMode {Number} See {@link SCALE_MODES} for possible values
	 * @return {Texture} a texture of the display object</haxe_doc>
			<overloads><generateTexture public="1" set="method">
	<f a="renderer:?resolution:?scaleMode">
		<c path="pixi.core.renderers.canvas.CanvasRenderer"/>
		<x path="Float"/>
		<x path="Int"/>
		<c path="pixi.core.textures.Texture"/>
	</f>
	<haxe_doc>* Useful function that returns a texture of the display object that can then be used to create sprites
	 * This can be quite useful if your displayObject is static / complicated and needs to be reused multiple times.
	 *
	 * @param renderer {CanvasRenderer|WebGLRenderer} The renderer used to generate the texture.
	 * @param resolution {Number} The resolution of the texture being generated
	 * @param scaleMode {Number} See {@link SCALE_MODES} for possible values
	 * @return {Texture} a texture of the display object</haxe_doc>
</generateTexture></overloads>
		</generateTexture>
		<updateTransform public="1" set="method"><f a=""><x path="Void"/></f></updateTransform>
		<displayObjectUpdateTransform public="1" set="method"><f a=""><x path="Void"/></f></displayObjectUpdateTransform>
		<destroy public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Base destroy method for generic display objects
	 * @param [destroyChildren] {Bool} if set to true, all the children will have their destroy method called as well (Container)
	 * @param [destroyTexture] {Bool} Should it destroy the current texture of the sprite as well (Sprite)
	 * @param [destroyBaseTexture] {Bool} whether to destroy the base texture as well (Text, Sprite)</haxe_doc>
			<overloads>
				<destroy public="1" set="method">
					<f a="?destroyTexture:?destroyBaseTexture">
						<x path="Bool"/>
						<x path="Bool"/>
						<x path="Void"/>
					</f>
					<haxe_doc>* Base destroy method for generic display objects
	 * @param [destroyChildren] {Bool} if set to true, all the children will have their destroy method called as well (Container)
	 * @param [destroyTexture] {Bool} Should it destroy the current texture of the sprite as well (Sprite)
	 * @param [destroyBaseTexture] {Bool} whether to destroy the base texture as well (Text, Sprite)</haxe_doc>
				</destroy>
				<destroy public="1" set="method">
					<f a="?destroyChildren">
						<x path="Bool"/>
						<x path="Void"/>
					</f>
					<haxe_doc>* Base destroy method for generic display objects
	 * @param [destroyChildren] {Bool} if set to true, all the children will have their destroy method called as well (Container)
	 * @param [destroyTexture] {Bool} Should it destroy the current texture of the sprite as well (Sprite)
	 * @param [destroyBaseTexture] {Bool} whether to destroy the base texture as well (Text, Sprite)</haxe_doc>
				</destroy>
			</overloads>
		</destroy>
		<name public="1">
			<c path="String"/>
			<haxe_doc>* The instance name of the object.
	 *
	 * @member {String}</haxe_doc>
		</name>
		<cacheAsBitmap public="1">
			<x path="Bool"/>
			<haxe_doc>* Set this to true if you want this display object to be cached as a bitmap.
	 * This basically takes a snap shot of the display object as it is at that moment. It can provide a performance benefit for complex static displayObjects.
	 * To remove simply set this property to 'null'
	 *
	 * @member {Bool}
	 * @memberof DisplayObject#</haxe_doc>
		</cacheAsBitmap>
		<position public="1">
			<c path="pixi.core.math.Point"/>
			<haxe_doc>* The coordinate of the object relative to the local coordinates of the parent.
	 *
	 * @member {Point}</haxe_doc>
		</position>
		<scale public="1">
			<c path="pixi.core.math.Point"/>
			<haxe_doc>* The scale factor of the object.
	 *
	 * @member {Point}</haxe_doc>
		</scale>
		<pivot public="1">
			<c path="pixi.core.math.Point"/>
			<haxe_doc>* The pivot point of the displayObject that it rotates around
	 *
	 * @member {Point}</haxe_doc>
		</pivot>
		<rotation public="1">
			<x path="Float"/>
			<haxe_doc>* The rotation of the object in radians.
	 *
	 * @member {Float}</haxe_doc>
		</rotation>
		<alpha public="1">
			<x path="Float"/>
			<haxe_doc>* The opacity of the object.
	 *
	 * @member {Float}</haxe_doc>
		</alpha>
		<visible public="1">
			<x path="Bool"/>
			<haxe_doc>* The visibility of the object. If false the object will not be drawn, and
	 * the updateTransform function will not be called.
	 *
	 * @member {Bool}</haxe_doc>
		</visible>
		<renderable public="1">
			<x path="Bool"/>
			<haxe_doc>* Can this object be rendered, if false the object will not be drawn but the updateTransform
	 * methods will still be called.
	 *
	 * @member {Bool}</haxe_doc>
		</renderable>
		<parent public="1">
			<c path="pixi.core.display.Container"/>
			<haxe_doc>* The display object container that contains this display object.
	 *
	 * @member {Container}
	 * @readOnly</haxe_doc>
		</parent>
		<worldAlpha public="1">
			<x path="Float"/>
			<haxe_doc>* The multiplied alpha of the displayObject
	 *
	 * @member {Float}
	 * @readOnly</haxe_doc>
		</worldAlpha>
		<worldTransform public="1">
			<c path="pixi.core.math.Matrix"/>
			<haxe_doc>* Current transform of the object based on world (parent) factors
	 *
	 * @member {Matrix}
	 * @readOnly</haxe_doc>
		</worldTransform>
		<filterArea public="1">
			<c path="pixi.core.math.shapes.Rectangle"/>
			<haxe_doc>* The area the filter is applied to. This is used as more of an optimisation
	 * rather than figuring out the dimensions of the displayObject each frame you can set this rectangle
	 *
	 * @member {Rectangle}</haxe_doc>
		</filterArea>
		<x public="1">
			<x path="Float"/>
			<haxe_doc>* The position of the displayObject on the x axis relative to the local coordinates of the parent.
	 *
	 * @member {Float}
	 * @memberof DisplayObject#</haxe_doc>
		</x>
		<y public="1">
			<x path="Float"/>
			<haxe_doc>* The position of the displayObject on the y axis relative to the local coordinates of the parent.
	 *
	 * @member {Float}
	 * @memberof DisplayObject#</haxe_doc>
		</y>
		<worldVisible public="1">
			<x path="Bool"/>
			<haxe_doc>* Indicates if the displayObject is globally visible.
	 *
	 * @member {Bool}
	 * @memberof DisplayObject#
	 * @readonly</haxe_doc>
		</worldVisible>
		<mask public="1">
			<d/>
			<haxe_doc>* Sets a mask for the displayObject. A mask is an object that limits the visibility of an object to the shape of the mask applied to it.
	 * In PIXI a regular mask must be a PIXI.Graphics object. This allows for much faster masking in canvas as it utilises shape clipping.
	 * To remove a mask, set this property to null.
	 *
	 * @member {Graphics}
	 * @memberof DisplayObject#</haxe_doc>
		</mask>
		<filters public="1">
			<c path="Array"><d/></c>
			<haxe_doc>* Sets the filters for the displayObject.
	 * * IMPORTANT: This is a webGL only feature and will be ignored by the canvas renderer.
	 * To remove filters simply set this property to 'null'
	 *
	 * @member {Filter[]}
	 * @memberof DisplayObject#</haxe_doc>
		</filters>
		<interactive public="1">
			<x path="Bool"/>
			<haxe_doc>* Indicates if the displayObject is interactive or not.
	 *
	 * @member {Bool}
	 * @default false
	 * @memberof DisplayObject#</haxe_doc>
		</interactive>
		<buttonMode public="1">
			<x path="Bool"/>
			<haxe_doc>* Indicates if the displayObject uses button mode or normal mode.
	 *
	 * @member {Bool}
	 * @default false
	 * @memberof DisplayObject#</haxe_doc>
		</buttonMode>
		<interactiveChildren public="1">
			<x path="Bool"/>
			<haxe_doc>* Indicates if the children of displayObject are interactive or not.
	 *
	 * @member {Bool}
	 * @default true
	 * @memberof DisplayObject#</haxe_doc>
		</interactiveChildren>
		<defaultCursor public="1">
			<c path="String"/>
			<haxe_doc>* Default cursor.
	 *
	 * @member {String}
	 * @default pointer
	 * @memberof DisplayObject#</haxe_doc>
		</defaultCursor>
		<hitArea public="1">
			<d/>
			<haxe_doc>* Hit area
	 *
	 * @memberof DisplayObject#</haxe_doc>
		</hitArea>
		<new public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* The base class for all objects that are rendered on the screen.
	 * This is an abstract class and should not be used on its own rather it should be extended.
	 *
	 * @class
	 * @namespace PIXI</haxe_doc>
		</new>
		<meta><m n=":native"><e>"PIXI.DisplayObject"</e></m></meta>
	</class>
	<class path="pixi.core.display.Container" params="" file="C:\HaxeToolkit\haxe\lib\pixijs/3,0,25/pixi/core/display/Container.hx" extern="1">
		<extends path="pixi.core.display.DisplayObject"/>
		<children public="1">
			<c path="Array"><c path="pixi.core.display.DisplayObject"/></c>
			<haxe_doc>* The array of children of this container.
	 *
	 * @member {DisplayObject[]}
	 * @readonly</haxe_doc>
		</children>
		<width public="1">
			<x path="Float"/>
			<haxe_doc>* The width of the Container, setting this will actually modify the scale to achieve the value set
	 *
	 * @member {Float}
	 * @memberof Container#</haxe_doc>
		</width>
		<height public="1">
			<x path="Float"/>
			<haxe_doc>* The height of the Container, setting this will actually modify the scale to achieve the value set
	 *
	 * @member {Float}
	 * @memberof Container#</haxe_doc>
		</height>
		<addChild public="1" set="method">
			<f a="child">
				<c path="pixi.core.display.DisplayObject"/>
				<c path="pixi.core.display.DisplayObject"/>
			</f>
			<haxe_doc>* Adds a child to the container.
	 *
	 * @param child {DisplayObject} The DisplayObject to add to the container
	 * @return {DisplayObject} The child that was added.</haxe_doc>
		</addChild>
		<addChildAt public="1" set="method">
			<f a="child:index">
				<c path="pixi.core.display.DisplayObject"/>
				<x path="Int"/>
				<c path="pixi.core.display.DisplayObject"/>
			</f>
			<haxe_doc>* Adds a child to the container at a specified index. If the index is out of bounds an error will be thrown
	 *
	 * @param child {DisplayObject} The child to add
	 * @param index {Int} The index to place the child in
	 * @return {DisplayObject} The child that was added.</haxe_doc>
		</addChildAt>
		<swapChildren public="1" set="method">
			<f a="child1:child2">
				<c path="pixi.core.display.DisplayObject"/>
				<c path="pixi.core.display.DisplayObject"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Swaps the position of 2 Display Objects within this container.
	 *
	 * @param child1 {DisplayObject}
	 * @param child2 {DisplayObject}</haxe_doc>
		</swapChildren>
		<getChildIndex public="1" set="method">
			<f a="child">
				<c path="pixi.core.display.DisplayObject"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Returns the index position of a child DisplayObject instance
	 *
	 * @param child {DisplayObject} The DisplayObject instance to identify
	 * @return {Int} The index position of the child display object to identify</haxe_doc>
		</getChildIndex>
		<setChildIndex public="1" set="method">
			<f a="child:index">
				<c path="pixi.core.display.DisplayObject"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Changes the position of an existing child in the display object container
	 *
	 * @param child {DisplayObject} The child DisplayObject instance for which you want to change the index number
	 * @param index {Int} The resulting index number for the child display object</haxe_doc>
		</setChildIndex>
		<getChildAt public="1" set="method">
			<f a="index">
				<x path="Int"/>
				<c path="pixi.core.display.DisplayObject"/>
			</f>
			<haxe_doc>* Returns the child at the specified index
	 *
	 * @param index {Int} The index to get the child from
	 * @return {DisplayObject} The child at the given index, if any.</haxe_doc>
		</getChildAt>
		<removeChild public="1" set="method">
			<f a="child">
				<c path="pixi.core.display.DisplayObject"/>
				<c path="pixi.core.display.DisplayObject"/>
			</f>
			<haxe_doc>* Removes a child from the container.
	 *
	 * @param child {DisplayObject} The DisplayObject to remove
	 * @return {DisplayObject} The child that was removed.</haxe_doc>
		</removeChild>
		<removeChildAt public="1" set="method">
			<f a="index">
				<x path="Int"/>
				<c path="pixi.core.display.DisplayObject"/>
			</f>
			<haxe_doc>* Removes a child from the specified index position.
	 *
	 * @param index {Int} The index to get the child from
	 * @return {DisplayObject} The child that was removed.</haxe_doc>
		</removeChildAt>
		<removeChildren public="1" set="method">
			<f a="?beginIndex:?endIndex">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Removes all children from this container that are within the begin and end indexes.
	 *
	 * @param beginIndex {Int} The beginning position. Default value is 0.
	 * @param endIndex {Int} The ending position. Default value is size of the container.</haxe_doc>
		</removeChildren>
		<getChildByName public="1" set="method">
			<f a="name">
				<c path="String"/>
				<c path="pixi.core.display.DisplayObject"/>
			</f>
			<haxe_doc>* Returns the display object in the container
	*
	* @param name {string} instance name
	* @return {DisplayObject}</haxe_doc>
		</getChildByName>
		<new public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* A Container represents a collection of display objects.
	 * It is the base class of all display objects that act as a container for other objects.
	 *
	 * @class
	 * @extends DisplayObject
	 * @namespace PIXI</haxe_doc>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":native"><e>"PIXI.Container"</e></m>
		</meta>
	</class>
	<class path="com.isartdigital.utils.game.GameObject" params="" file="src/com/isartdigital/utils/game/GameObject.hx">
		<extends path="pixi.core.display.Container"/>
		<forceUpdateTransform set="method" line="24">
			<f a=""><x path="Void"/></f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>* Force la mise à jour de la matrices de transformation des éléments constituant le GameObject</haxe_doc>
		</forceUpdateTransform>
		<destroy public="1" set="method" line="31" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* nettoie et détruit l'instance</haxe_doc>
		</destroy>
		<new public="1" set="method" line="15"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* Classe de base des objets interactifs dans le jeu
 * Met à jour automatiquement ses données internes de position et transformation
 * 
 * @author Mathieu ANTHOINE</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="com.isartdigital.utils.game.IStateMachine" params="" file="src/com/isartdigital/utils/game/IStateMachine.hx" interface="1">
		<doAction public="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* méthode appelée à chaque gameLoop. Elle peut faire référence à différentes méthodes au cours du temps</haxe_doc>
		</doAction>
		<start public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Activation</haxe_doc>
		</start>
		<haxe_doc>* Interface permettant à des classes d'implémenter le modèle Machine à état en respectant les convention de la structure
 * @author Mathieu ANTHOINE</haxe_doc>
	</class>
	<class path="com.isartdigital.utils.game.StateMachine" params="" file="src/com/isartdigital/utils/game/StateMachine.hx">
		<extends path="com.isartdigital.utils.game.GameObject"/>
		<implements path="com.isartdigital.utils.game.IStateMachine"/>
		<doAction public="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* méthode appelée à chaque gameLoop. Elle peut faire référence à différentes méthodes au cours du temps</haxe_doc>
		</doAction>
		<setModeVoid set="method" line="27">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* applique le mode "ne fait rien"</haxe_doc>
		</setModeVoid>
		<doActionVoid set="method" line="34">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* fonction vide destinée à maintenir la référence de doAction sans rien faire</haxe_doc>
		</doActionVoid>
		<setModeNormal set="method" line="40">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* applique le mode normal (mode par defaut)</haxe_doc>
		</setModeNormal>
		<doActionNormal set="method" line="47">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* fonction destinée à appliquer un comportement par defaut</haxe_doc>
		</doActionNormal>
		<start public="1" set="method" line="52">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Activation</haxe_doc>
		</start>
		<destroy public="1" set="method" line="59" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* nettoie et détruit l'instance</haxe_doc>
		</destroy>
		<new public="1" set="method" line="18"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* Implémentation de base d'une Machine à état
 * expose de façon publique sa méthode doAction qui peut faire référence à différentes méthodes prévues (doActionVoid, doActionNormal) ou spécifiques définies par ses classes filles
 * Par convention le changement de référence de doAction se fait via des méthodes setMode (setModeVoid, setModeAction) qui peuvent aussi contenir des paramètres d'initialisation
 * @author Mathieu ANTHOINE</haxe_doc>
	</class>
	<class path="com.isartdigital.utils.game.StateGraphic" params="" file="src/com/isartdigital/utils/game/StateGraphic.hx">
		<extends path="com.isartdigital.utils.game.StateMachine"/>
		<animAlpha public="1" line="78" static="1">
			<x path="Float"/>
			<haxe_doc>* niveau d'alpha des anim</haxe_doc>
		</animAlpha>
		<boxAlpha public="1" line="83" static="1">
			<x path="Float"/>
			<haxe_doc>* niveau d'alpha des Boxes</haxe_doc>
		</boxAlpha>
		<boxesCache static="1">
			<x path="Map">
				<c path="String"/>
				<x path="Map">
					<c path="String"/>
					<d/>
				</x>
			</x>
			<haxe_doc>* cache des boxes de tous les StateGraphic</haxe_doc>
		</boxesCache>
		<addBoxes public="1" set="method" line="248" static="1">
			<f a="pJson">
				<c path="haxe.Json"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Créer toutes les Boxes
	 * @param	pFile Nom du fichier contenant la description des boxes</haxe_doc>
		</addBoxes>
		<factory>
			<c path="com.isartdigital.utils.game.factory.AnimFactory"/>
			<haxe_doc>* Fabrique d'anim</haxe_doc>
		</factory>
		<anim>
			<c path="pixi.core.display.Container"/>
			<haxe_doc>* anim de l'état courant</haxe_doc>
		</anim>
		<box>
			<c path="pixi.core.display.Container"/>
			<haxe_doc>* box de l'état courant</haxe_doc>
		</box>
		<ANIM_SUFFIX set="null">
			<c path="String"/>
			<haxe_doc>* suffixe du nom d'export des symboles Animés</haxe_doc>
		</ANIM_SUFFIX>
		<BOX_SUFFIX set="null">
			<c path="String"/>
			<haxe_doc>* suffixe du nom d'export des symboles Box</haxe_doc>
		</BOX_SUFFIX>
		<DEFAULT_STATE set="null">
			<c path="String"/>
			<haxe_doc>* etat par défaut</haxe_doc>
		</DEFAULT_STATE>
		<assetName>
			<c path="String"/>
			<haxe_doc>* Nom de l'asset (sert à identifier les textures à utiliser)
	 * Prend le nom de la classe Fille par défaut</haxe_doc>
		</assetName>
		<state>
			<c path="String"/>
			<haxe_doc>* état en cours</haxe_doc>
		</state>
		<boxType>
			<e path="com.isartdigital.utils.game.BoxType"/>
			<haxe_doc>* Type de box de collision
	 * Si boxType est égal à BoxType.NONE, aucune collision ne se fait, il n'est pas nécessaire d'avoir une boite de collision définie
	 * Si boxType est égal à BoxType.SIMPLE, seul un symbole sert de Box pour tous les états, son nom d'export etant assetName+"_"+BOX_SUFFIX
	 * Si boxType est égal à BoxType.MULTIPLE, chaque state correspond à une boite de collision, chaque state va cherche la boite assetName+"_"+ANIM_SUFFIX+"_"+BOX_SUFFIX
	 * Si boxType est égal à BoxType.SELF, hitBox retourne le MovieClip anim</haxe_doc>
		</boxType>
		<isAnimEnd public="1" set="null">
			<x path="Bool"/>
			<haxe_doc>* l'anim est-elle terminée ?</haxe_doc>
		</isAnimEnd>
		<setAnimEnd set="method" line="95"><f a=""><x path="Void"/></f></setAnimEnd>
		<changeAsset public="1" set="method" line="109">
			<f a="pAssetName:?pState">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>*	Change l'asset à la volé par un asset personnalisé		
	 *  DEPRECATED</haxe_doc>
		</changeAsset>
		<toModel public="1" set="method" line="119">
			<f a="?pFloor">
				<x path="Bool"/>
				<c path="pixi.core.math.Point"/>
			</f>
			<haxe_doc>* Conversion du modèle à la vue Isométrique du stateGraphic		
	 * @param	pFloor Arrondi les valeur		
	 * @return point en x, y dans la vue</haxe_doc>
		</toModel>
		<setState set="method" line="137">
			<f a="pState:?pLoop:?pAutoPlay:?pStart">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="UInt"/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>* défini l'état courant du StateGraphic
	 * @param	pState nom de l'état (run, walk...)
	 * @param	pLoop l'anim boucle (isAnimEnd sera toujours false) ou pas
	 * @param	pAutoPlay lance l'anim automatiquement
	 * @param	pStart lance l'anim à cette frame</haxe_doc>
		</setState>
		<changeTexture set="method" line="197"><f a="pState">
	<c path="String"/>
	<x path="Void"/>
</f></changeTexture>
		<getID set="method" line="205">
			<f a="pState">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>* retourne l'identifiant complet de l'animation
	 * @param	pState etat de l'anim
	 * @return identifiant</haxe_doc>
		</getID>
		<createBox set="method" line="213">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* crée la ou les box de collision de l'état</haxe_doc>
		</createBox>
		<getBox public="1" set="method" line="279">
			<f a="pState">
				<c path="String"/>
				<x path="Map">
					<c path="String"/>
					<d/>
				</x>
			</f>
			<haxe_doc>* Cherche dans le cache général des boxes, celle correspondant au state demandé
	 * @param	pState State de l'instance
	 * @return	la box correspondante
	 * @return</haxe_doc>
		</getBox>
		<pause public="1" set="method" line="286">
			<f a=""><x path="Void"/></f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>* met en pause l'anim</haxe_doc>
		</pause>
		<resume public="1" set="method" line="293">
			<f a=""><x path="Void"/></f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>* relance l'anim</haxe_doc>
		</resume>
		<hitBox public="1" get="accessor" set="null">
			<c path="pixi.core.display.Container"/>
			<haxe_doc>* retourne la zone de hit de l'objet</haxe_doc>
		</hitBox>
		<get_hitBox set="method" line="302"><f a=""><c path="pixi.core.display.Container"/></f></get_hitBox>
		<hitPoints public="1" get="accessor" set="null">
			<c path="Array"><c path="pixi.core.math.Point"/></c>
			<haxe_doc>* retourne un tableau de points de collision dont les coordonnées sont exprimées dans le systeme global</haxe_doc>
		</hitPoints>
		<get_hitPoints set="method" line="312"><f a=""><c path="Array"><c path="pixi.core.math.Point"/></c></f></get_hitPoints>
		<destroy public="1" set="method" line="320" override="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>* nettoyage et suppression de l'instance</haxe_doc>
		</destroy>
		<new public="1" set="method" line="99"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* Classe de base des objets interactifs ayant plusieurs états graphiques
 * Gère la représentation graphique (anim) et les conteneurs utiles au gamePlay (box) qui peuvent être de simples boites de collision ou beaucoup plus
 * suivant l'implémentation faite par le développeur dans les classes filles
 * @author Mathieu ANTHOINE
 * @version 0.11.0</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="com.isartdigital.builder.game.sprites.Citizen" params="" file="src/com/isartdigital/builder/game/sprites/Citizen.hx">
		<extends path="com.isartdigital.utils.game.StateGraphic"/>
		<list public="1" line="24" static="1"><c path="Array"><c path="com.isartdigital.builder.game.sprites.Citizen"/></c></list>
		<posInModel public="1"><c path="pixi.core.math.Point"/></posInModel>
		<listPos><c path="Array"><c path="pixi.core.math.Point"/></c></listPos>
		<nextPosModel><c path="pixi.core.math.Point"/></nextPosModel>
		<nextPosIso><c path="pixi.core.math.Point"/></nextPosIso>
		<speed><c path="pixi.core.math.Point"/></speed>
		<startPathfinder set="method" line="45"><f a=""><x path="Void"/></f></startPathfinder>
		<doActionNormal set="method" line="61" override="1"><f a=""><x path="Void"/></f></doActionNormal>
		<setNextPos set="method" line="72">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Récupere le prochain point du model à atteindre dans listPos</haxe_doc>
		</setNextPos>
		<moveTo public="1" set="method" line="82">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Bouge le sprite vers une coordonnée du model grace à setNextPos</haxe_doc>
		</moveTo>
		<destroy public="1" set="method" line="98" override="1"><f a=""><x path="Void"/></f></destroy>
		<new public="1" set="method" line="31"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* ...
 * @author Thorcal</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="com.isartdigital.builder.game.sprites.SpriteObject" params="" file="src/com/isartdigital/builder/game/sprites/SpriteObject.hx">
		<extends path="com.isartdigital.utils.game.StateGraphic"/>
		<implements path="com.isartdigital.builder.game.pooling.IPoolObject"/>
		<remove public="1" set="method" line="18"><f a=""><x path="Bool"/></f></remove>
		<init public="1" set="method" line="27"><f a="pDefinition">
	<d/>
	<x path="Void"/>
</f></init>
		<new public="1" set="method" line="13"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* ...
 * @author Flavien</haxe_doc>
	</class>
	<class path="com.isartdigital.builder.game.sprites.Tile" params="" file="src/com/isartdigital/builder/game/sprites/Tile.hx">
		<extends path="com.isartdigital.builder.game.sprites.SpriteObject"/>
		<implements path="com.isartdigital.builder.game.pooling.IPoolObject"/>
		<list public="1" line="24" static="1"><c path="Array"><c path="com.isartdigital.builder.game.sprites.Tile"/></c></list>
		<tilesCount><x path="Int"/></tilesCount>
		<tileColor><x path="Int"/></tileColor>
		<isBuildable public="1"><x path="Bool"/></isBuildable>
		<isWalkable public="1"><x path="Bool"/></isWalkable>
		<remove public="1" set="method" line="40" override="1"><f a=""><x path="Bool"/></f></remove>
		<init public="1" set="method" line="52" override="1"><f a="pDefiniton">
	<d/>
	<x path="Void"/>
</f></init>
		<setRandomColor set="method" line="74"><f a=""><x path="Void"/></f></setRandomColor>
		<destroy public="1" set="method" line="80" override="1"><f a=""><x path="Void"/></f></destroy>
		<new public="1" set="method" line="32"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* Classe des tiles
 * @author Dorian MILLIERE</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="com.isartdigital.utils.game.iso.IZSortable" params="" file="src/com/isartdigital/utils/game/iso/IZSortable.hx" interface="1">
		<colMin public="1"><x path="UInt"/></colMin>
		<colMax public="1"><x path="UInt"/></colMax>
		<rowMin public="1"><x path="UInt"/></rowMin>
		<rowMax public="1"><x path="UInt"/></rowMax>
		<haxe_doc>* Interface des objets à "z sorter"
 * @author Mathieu Anthoine</haxe_doc>
	</class>
	<class path="com.isartdigital.builder.game.sprites.buildings.Building" params="" file="src/com/isartdigital/builder/game/sprites/buildings/Building.hx">
		<extends path="com.isartdigital.builder.game.sprites.SpriteObject"/>
		<implements path="com.isartdigital.builder.game.pooling.IPoolObject"/>
		<implements path="com.isartdigital.utils.game.iso.IZSortable"/>
		<list public="1" line="40" static="1"><c path="Array"><c path="com.isartdigital.builder.game.sprites.buildings.Building"/></c></list>
		<movingBuilding public="1" static="1"><c path="com.isartdigital.builder.game.sprites.buildings.Building"/></movingBuilding>
		<cancelMoving set="method" line="188" static="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Annule le deplacement du batiment actuellement en train de bouger et le remet à sa position initiale</haxe_doc>
		</cancelMoving>
		<definition public="1"><t path="com.isartdigital.builder.game.sprites.buildings.def.BuildingDef"/></definition>
		<buildingLevel public="1"><x path="Int"/></buildingLevel>
		<colMin public="1"><x path="UInt"/></colMin>
		<colMax public="1"><x path="UInt"/></colMax>
		<rowMin public="1"><x path="UInt"/></rowMin>
		<rowMax public="1"><x path="UInt"/></rowMax>
		<positionBeforeConstruct><c path="pixi.core.math.Point"/></positionBeforeConstruct>
		<init public="1" set="method" line="64" override="1"><f a="pDefinition">
	<d/>
	<x path="Void"/>
</f></init>
		<addToStage set="method" line="91"><f a=""><x path="Void"/></f></addToStage>
		<remove public="1" set="method" line="101" override="1"><f a=""><x path="Bool"/></f></remove>
		<doActionNormal set="method" line="114" override="1"><f a=""><x path="Void"/></f></doActionNormal>
		<upgradeBuilding public="1" set="method" line="133">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Upgrade un building</haxe_doc>
		</upgradeBuilding>
		<buildingClick public="1" set="method" line="142">
			<f a="event">
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Commence le deplacement d'un batiment</haxe_doc>
		</buildingClick>
		<stopMoving set="method" line="161">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Stop le deplacement d'un batiment</haxe_doc>
		</stopMoving>
		<constructRequest set="method" line="166"><f a=""><x path="Void"/></f></constructRequest>
		<setPositionBeforeConstructWith set="method" line="180"><f a="newPosition">
	<c path="pixi.core.math.Point"/>
	<x path="Void"/>
</f></setPositionBeforeConstructWith>
		<callServerToDestroy public="1" set="method" line="201"><f a=""><x path="Void"/></f></callServerToDestroy>
		<cbTryToDestroy set="method" line="206"><f a="pResponse">
	<c path="String"/>
	<x path="Void"/>
</f></cbTryToDestroy>
		<destroy public="1" set="method" line="214" override="1"><f a=""><x path="Void"/></f></destroy>
		<new public="1" set="method" line="54"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* ...
 * @author Dorian</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="com.isartdigital.builder.game.sprites.buildings.BuildingConstructor" params="" file="src/com/isartdigital/builder/game/sprites/buildings/BuildingConstructor.hx">
		<mapManager><c path="com.isartdigital.builder.game.manager.MapManager"/></mapManager>
		<building><c path="com.isartdigital.builder.game.sprites.buildings.Building"/></building>
		<positionBeforeConstruct><c path="pixi.core.math.Point"/></positionBeforeConstruct>
		<destinationPosition><c path="pixi.core.math.Point"/></destinationPosition>
		<setDestination public="1" set="method" line="28"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setDestination>
		<tilesAtDestinationIsBuildable public="1" set="method" line="33"><f a=""><x path="Bool"/></f></tilesAtDestinationIsBuildable>
		<construct public="1" set="method" line="38"><f a=""><x path="Void"/></f></construct>
		<updateTilesBuildableState set="method" line="43"><f a=""><x path="Void"/></f></updateTilesBuildableState>
		<updateBuildingReferencePositionInGlobalMap set="method" line="48"><f a=""><x path="Void"/></f></updateBuildingReferencePositionInGlobalMap>
		<setOriginTilesToConstructibleInGlobalMap set="method" line="54"><f a=""><x path="Void"/></f></setOriginTilesToConstructibleInGlobalMap>
		<setDestinationTilesToNotConstructibleInGlobalMap set="method" line="59"><f a=""><x path="Void"/></f></setDestinationTilesToNotConstructibleInGlobalMap>
		<getBuildingFromGlobalMap set="method" line="64"><f a=""><d/></f></getBuildingFromGlobalMap>
		<new public="1" set="method" line="20"><f a="building:positionBeforeConstruct">
	<c path="com.isartdigital.builder.game.sprites.buildings.Building"/>
	<c path="pixi.core.math.Point"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* ...
 * @author Dorian</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="com.isartdigital.builder.game.sprites.buildings.BuildingMover" params="" file="src/com/isartdigital/builder/game/sprites/buildings/BuildingMover.hx">
		<building><c path="com.isartdigital.builder.game.sprites.buildings.Building"/></building>
		<definition><t path="com.isartdigital.builder.game.sprites.buildings.def.BuildingDef"/></definition>
		<mousePosition><c path="pixi.core.math.Point"/></mousePosition>
		<moveUnderMouse public="1" set="method" line="23"><f a=""><x path="Void"/></f></moveUnderMouse>
		<setMousePosition public="1" set="method" line="37"><f a="mousePosition">
	<c path="pixi.core.math.Point"/>
	<x path="Void"/>
</f></setMousePosition>
		<mousePositionNullException set="method" line="41"><f a=""><x path="Void"/></f></mousePositionNullException>
		<new public="1" set="method" line="17"><f a="building">
	<c path="com.isartdigital.builder.game.sprites.buildings.Building"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* ...
 * @author Dorian MILLIERE</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="com.isartdigital.builder.game.sprites.buildings.childrens.Altar" params="" file="src/com/isartdigital/builder/game/sprites/buildings/childrens/Altar.hx">
		<extends path="com.isartdigital.builder.game.sprites.buildings.Building"/>
		<new public="1" set="method" line="12"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* ...
 * @author Flavien</haxe_doc>
	</class>
	<class path="com.isartdigital.builder.game.sprites.buildings.childrens.Brothel" params="" file="src/com/isartdigital/builder/game/sprites/buildings/childrens/Brothel.hx">
		<extends path="com.isartdigital.builder.game.sprites.buildings.Building"/>
		<new public="1" set="method" line="10"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* ...
 * @author Flavien</haxe_doc>
	</class>
	<class path="com.isartdigital.builder.game.sprites.buildings.childrens.Casino" params="" file="src/com/isartdigital/builder/game/sprites/buildings/childrens/Casino.hx">
		<extends path="com.isartdigital.builder.game.sprites.buildings.Building"/>
		<new public="1" set="method" line="12"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* ...
 * @author Dorian</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="com.isartdigital.builder.game.sprites.buildings.childrens.House" params="" file="src/com/isartdigital/builder/game/sprites/buildings/childrens/House.hx">
		<extends path="com.isartdigital.builder.game.sprites.buildings.Building"/>
		<new public="1" set="method" line="10"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* ...
 * @author Flavien</haxe_doc>
	</class>
	<class path="com.isartdigital.builder.game.sprites.buildings.component.IUpgradableComponent" params="" file="src/com/isartdigital/builder/game/sprites/buildings/component/IUpgradableComponent.hx" interface="1">
		<setUpgradableComponent public="1" set="method"><f a="upgradableComponent">
	<c path="com.isartdigital.builder.game.sprites.buildings.component.UpgradableComponent"/>
	<x path="Void"/>
</f></setUpgradableComponent>
		<haxe_doc>* @author Dorian</haxe_doc>
	</class>
	<class path="com.isartdigital.builder.game.sprites.buildings.component.ICollectableComponent" params="" file="src/com/isartdigital/builder/game/sprites/buildings/component/ICollectableComponent.hx" interface="1">
		<setCollectableComponent public="1" set="method"><f a="collectableComponent">
	<c path="com.isartdigital.builder.game.sprites.buildings.component.CollectableComponent"/>
	<x path="Void"/>
</f></setCollectableComponent>
		<haxe_doc>* @author Dorian</haxe_doc>
	</class>
	<class path="com.isartdigital.builder.game.sprites.buildings.childrens.Motel" params="" file="src/com/isartdigital/builder/game/sprites/buildings/childrens/Motel.hx">
		<extends path="com.isartdigital.builder.game.sprites.buildings.Building"/>
		<implements path="com.isartdigital.builder.game.sprites.buildings.component.IUpgradableComponent"/>
		<implements path="com.isartdigital.builder.game.sprites.buildings.component.ICollectableComponent"/>
		<collectableComponent><c path="com.isartdigital.builder.game.sprites.buildings.component.CollectableComponent"/></collectableComponent>
		<upgradableComponent><c path="com.isartdigital.builder.game.sprites.buildings.component.UpgradableComponent"/></upgradableComponent>
		<setCollectableComponent public="1" set="method" line="23"><f a="collectableComponent">
	<c path="com.isartdigital.builder.game.sprites.buildings.component.CollectableComponent"/>
	<x path="Void"/>
</f></setCollectableComponent>
		<setUpgradableComponent public="1" set="method" line="27"><f a="upgradableComponent">
	<c path="com.isartdigital.builder.game.sprites.buildings.component.UpgradableComponent"/>
	<x path="Void"/>
</f></setUpgradableComponent>
		<collect public="1" set="method" line="31"><f a=""><x path="Void"/></f></collect>
		<upgrade public="1" set="method" line="35"><f a=""><x path="Void"/></f></upgrade>
		<new public="1" set="method" line="18"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* Element placeholder
 * On imagine qu'il est Collectable et Upgradable
 * @author Dorian</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="com.isartdigital.builder.game.sprites.buildings.childrens.Pyrotechnician" params="" file="src/com/isartdigital/builder/game/sprites/buildings/childrens/Pyrotechnician.hx">
		<extends path="com.isartdigital.builder.game.sprites.buildings.Building"/>
		<new public="1" set="method" line="10"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* ...
 * @author Flavien</haxe_doc>
	</class>
	<class path="com.isartdigital.builder.game.sprites.buildings.childrens.RocketFactory" params="" file="src/com/isartdigital/builder/game/sprites/buildings/childrens/RocketFactory.hx">
		<extends path="com.isartdigital.builder.game.sprites.buildings.Building"/>
		<new public="1" set="method" line="13"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* ...
 * @author Dorian</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="com.isartdigital.builder.game.sprites.buildings.childrens.Temple" params="" file="src/com/isartdigital/builder/game/sprites/buildings/childrens/Temple.hx">
		<extends path="com.isartdigital.builder.game.sprites.buildings.Building"/>
		<new public="1" set="method" line="11"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* ...
 * @author Dorian</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="com.isartdigital.builder.game.sprites.buildings.childrens.decoration.Park" params="" file="src/com/isartdigital/builder/game/sprites/buildings/childrens/decoration/Park.hx">
		<extends path="com.isartdigital.builder.game.sprites.buildings.Building"/>
		<new public="1" set="method" line="10"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* ...
 * @author Flavien</haxe_doc>
	</class>
	<class path="com.isartdigital.builder.game.sprites.buildings.component.CollectableComponent" params="" file="src/com/isartdigital/builder/game/sprites/buildings/component/CollectableComponent.hx">
		<lastRecoltAt public="1"><c path="Date"/></lastRecoltAt>
		<collect public="1" set="method" line="16"><f a=""><x path="Void"/></f></collect>
		<new public="1" set="method" line="11"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* ...
 * @author Dorian MILLIERE</haxe_doc>
	</class>
	<class path="com.isartdigital.builder.game.sprites.buildings.component.UpgradableComponent" params="" file="src/com/isartdigital/builder/game/sprites/buildings/component/UpgradableComponent.hx">
		<lvl public="1"><x path="Int"/></lvl>
		<upgrade public="1" set="method" line="16"><f a=""><x path="Void"/></f></upgrade>
		<new public="1" set="method" line="11"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* ...
 * @author Dorian MILLIERE</haxe_doc>
	</class>
	<typedef path="com.isartdigital.builder.game.sprites.buildings.def.BuildingDef" params="" file="src/com/isartdigital/builder/game/sprites/buildings/def/BuildingDef.hx">
		<a>
			<spriteName><c path="String"/></spriteName>
			<size><t path="com.isartdigital.builder.game.def.SizeDef"/></size>
			<name><c path="String"/></name>
			<className><c path="String"/></className>
		</a>
		<haxe_doc>* @author Dorian</haxe_doc>
	</typedef>
	<typedef path="com.isartdigital.builder.game.sprites.buildings.def.BuildingSavedDef" params="" file="src/com/isartdigital/builder/game/sprites/buildings/def/BuildingSavedDef.hx">
		<a>
			<y><x path="Int"/></y>
			<x><x path="Int"/></x>
			<name><c path="String"/></name>
			<color><c path="String"/></color>
			<buildingLevel><x path="Int"/></buildingLevel>
		</a>
		<haxe_doc>* @author Dorian</haxe_doc>
	</typedef>
	<class path="com.isartdigital.builder.game.sprites.buildings.utils.BuildingDefinition" params="" file="src/com/isartdigital/builder/game/sprites/buildings/utils/BuildingDefinition.hx">
		<BUILDING_JSON_PATH get="inline" set="null" line="11" static="1"><c path="String"/></BUILDING_JSON_PATH>
		<definitionName static="1"><c path="String"/></definitionName>
		<getByName public="1" set="method" line="20" static="1"><f a="name">
	<c path="String"/>
	<t path="com.isartdigital.builder.game.sprites.buildings.def.BuildingDef"/>
</f></getByName>
		<setDefinitionName set="method" line="27" static="1"><f a="pDefinitionName">
	<c path="String"/>
	<x path="Void"/>
</f></setDefinitionName>
		<getTypedBuildingDefinitions set="method" line="31" static="1"><f a=""><c path="Array"><t path="com.isartdigital.builder.game.sprites.buildings.def.BuildingDef"/></c></f></getTypedBuildingDefinitions>
		<getBuildingDefinitionInto set="method" line="35" static="1"><f a="buildingDefinitions">
	<c path="Array"><t path="com.isartdigital.builder.game.sprites.buildings.def.BuildingDef"/></c>
	<t path="com.isartdigital.builder.game.sprites.buildings.def.BuildingDef"/>
</f></getBuildingDefinitionInto>
		<new public="1" set="method" line="14"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* ...
 * @author Dorian MILLIERE</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="com.isartdigital.builder.game.sprites.buildings.utils.BuildingPosition" params="" file="src/com/isartdigital/builder/game/sprites/buildings/utils/BuildingPosition.hx">
		<building><c path="com.isartdigital.builder.game.sprites.buildings.Building"/></building>
		<definition><t path="com.isartdigital.builder.game.sprites.buildings.def.BuildingDef"/></definition>
		<getPositionOnCursor public="1" set="method" line="22"><f a=""><c path="pixi.core.math.Point"/></f></getPositionOnCursor>
		<getBuildingOffset set="method" line="28"><f a=""><c path="pixi.core.math.Point"/></f></getBuildingOffset>
		<getMousePositionWith set="method" line="37"><f a="buildingOffset">
	<c path="pixi.core.math.Point"/>
	<c path="pixi.core.math.Point"/>
</f></getMousePositionWith>
		<new public="1" set="method" line="16"><f a="building">
	<c path="com.isartdigital.builder.game.sprites.buildings.Building"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* ...
 * @author Dorian MILLIERE</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="com.isartdigital.builder.game.utils.TypeDefUtils" params="" file="src/com/isartdigital/builder/game/utils/TypeDefUtils.hx">
		<tileSavedDef public="1" line="11" static="1"><t path="com.isartdigital.builder.game.def.TileSavedDef"/></tileSavedDef>
		<buildingSavedDef public="1" line="12" static="1"><t path="com.isartdigital.builder.game.sprites.buildings.def.BuildingSavedDef"/></buildingSavedDef>
		<getValue public="1" set="method" line="24" static="1">
			<f a="pTypeDef">
				<d/>
				<d/>
			</f>
			<haxe_doc>* 
	 * @param	pTypeDef
	 * @return</haxe_doc>
		</getValue>
		<compare public="1" set="method" line="37" static="1">
			<f a="pType1:pType2">
				<d/>
				<d/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Test si deux typeDef sont identique ou non
	 * Note : faire la comparaison entre deux instance de typedef
	 * @param	pType1
	 * @param	pType2
	 * @return true si identique, sinon false</haxe_doc>
		</compare>
		<new public="1" set="method" line="14"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* ...
 * @author Flavien</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="com.isartdigital.builder.ui.CheatPanel" params="" file="src/com/isartdigital/builder/ui/CheatPanel.hx">
		<instance static="1">
			<c path="com.isartdigital.builder.ui.CheatPanel"/>
			<haxe_doc>* instance unique de la classe CheatPanel</haxe_doc>
		</instance>
		<getInstance public="1" set="method" line="30" static="1">
			<f a=""><c path="com.isartdigital.builder.ui.CheatPanel"/></f>
			<haxe_doc>* Retourne l'instance unique de la classe, et la crée si elle n'existait pas au préalable
	 * @return instance unique</haxe_doc>
		</getInstance>
		<gui>
			<c path="dat.gui.GUI"/>
			<haxe_doc>* instance de dat.GUI composée par le CheatPanel</haxe_doc>
		</gui>
		<init set="method" line="43"><f a=""><x path="Void"/></f></init>
		<ingame public="1" set="method" line="48"><f a=""><x path="Void"/></f></ingame>
		<clear public="1" set="method" line="63">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* vide le CheatPanel</haxe_doc>
		</clear>
		<destroy public="1" set="method" line="72">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* détruit l'instance unique et met sa référence interne à null</haxe_doc>
		</destroy>
		<new set="method" line="38">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* constructeur privé pour éviter qu'une instance soit créée directement</haxe_doc>
		</new>
		<haxe_doc>* Classe permettant de manipuler des parametres du projet au runtime
 * Si la propriété Config.debug et à false ou que la propriété Config.data.cheat est à false, aucun code n'est executé.
 * Il n'est pas nécessaire de retirer ou commenter le code du CheatPanel dans la version "release" du jeu
 * @author Mathieu ANTHOINE</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="com.isartdigital.utils.ui.UIComponent" params="" file="src/com/isartdigital/utils/ui/UIComponent.hx">
		<extends path="com.isartdigital.utils.game.GameObject"/>
		<positionables><c path="Array"><t path="com.isartdigital.utils.ui.UIPositionable"/></c></positionables>
		<isOpened><x path="Bool"/></isOpened>
		<modalZone><c path="pixi.core.sprites.Sprite"/></modalZone>
		<_modal><x path="Bool"/></_modal>
		<modalImage public="1"><c path="String"/></modalImage>
		<build public="1" set="method" line="40">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* permet de construire l'UIComponent à partir de l'UIBuilder</haxe_doc>
		</build>
		<addChildItems set="method" line="49"><f a="pItems">
	<c path="Array"><t path="com.isartdigital.utils.ui.UIPositionable"/></c>
	<x path="Void"/>
</f></addChildItems>
		<addChildItem set="method" line="57"><f a="pItems">
	<c path="Array"><t path="com.isartdigital.utils.ui.UIPositionable"/></c>
	<x path="Void"/>
</f></addChildItem>
		<open public="1" set="method" line="65"><f a=""><x path="Void"/></f></open>
		<modal public="1" get="accessor" set="accessor"><x path="Bool"/></modal>
		<get_modal set="method" line="77"><f a=""><x path="Bool"/></f></get_modal>
		<set_modal set="method" line="81"><f a="pModal">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_modal>
		<stopPropagation set="method" line="106"><f a="pEvent">
	<t path="pixi.interaction.EventTarget"/>
	<x path="Void"/>
</f></stopPropagation>
		<close public="1" set="method" line="108"><f a=""><x path="Void"/></f></close>
		<onResize set="method" line="119">
			<f a="?pEvent">
				<t path="pixi.interaction.EventTarget"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* déclenche le positionnement des objets
	 * @param pEvent</haxe_doc>
		</onResize>
		<destroy public="1" set="method" line="143" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* nettoie l'instance</haxe_doc>
		</destroy>
		<new public="1" set="method" line="32"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* Base de tous les conteneurs d'interface
 * @author Mathieu ANTHOINE</haxe_doc>
	</class>
	<class path="com.isartdigital.utils.ui.Screen" params="" file="src/com/isartdigital/utils/ui/Screen.hx">
		<extends path="com.isartdigital.utils.ui.UIComponent"/>
		<new public="1" set="method" line="12"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* Classe de base des Ecrans
 * Tous les écrans d'interface héritent de cette classe
 * @author Mathieu ANTHOINE</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="com.isartdigital.builder.ui.GraphicLoader" params="" file="src/com/isartdigital/builder/ui/GraphicLoader.hx">
		<extends path="com.isartdigital.utils.ui.Screen"/>
		<instance static="1">
			<c path="com.isartdigital.builder.ui.GraphicLoader"/>
			<haxe_doc>* instance unique de la classe GraphicLoader</haxe_doc>
		</instance>
		<getInstance public="1" set="method" line="40" static="1">
			<f a=""><c path="com.isartdigital.builder.ui.GraphicLoader"/></f>
			<haxe_doc>* Retourne l'instance unique de la classe, et la crée si elle n'existait pas au préalable
	 * @return instance unique</haxe_doc>
		</getInstance>
		<loaderBar><c path="pixi.core.sprites.Sprite"/></loaderBar>
		<update public="1" set="method" line="49">
			<f a="pProgress">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* mise à jour de la barre de chargement
	 * @param	pProgress</haxe_doc>
		</update>
		<destroy public="1" set="method" line="56" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* détruit l'instance unique et met sa référence interne à null</haxe_doc>
		</destroy>
		<new public="1" set="method" line="22"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* Preloader Graphique principal
 * @author Mathieu ANTHOINE</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="com.isartdigital.builder.ui.UIManager" params="" file="src/com/isartdigital/builder/ui/UIManager.hx">
		<instance static="1">
			<c path="com.isartdigital.builder.ui.UIManager"/>
			<haxe_doc>* instance unique de la classe UIManager</haxe_doc>
		</instance>
		<getInstance public="1" set="method" line="36" static="1">
			<f a=""><c path="com.isartdigital.builder.ui.UIManager"/></f>
			<haxe_doc>* Retourne l'instance unique de la classe, et la crée si elle n'existait pas au préalable
	 * @return instance unique</haxe_doc>
		</getInstance>
		<popins>
			<c path="Array"><c path="com.isartdigital.utils.ui.Popin"/></c>
			<haxe_doc>* tableau des popins ouverts</haxe_doc>
		</popins>
		<openScreen public="1" set="method" line="45">
			<f a="pScreen">
				<c path="com.isartdigital.utils.ui.Screen"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Ajoute un écran dans le conteneur de Screens en s'assurant qu'il n'y en a pas d'autres
	 * @param	pScreen Screen à ouvrir</haxe_doc>
		</openScreen>
		<closeScreens public="1" set="method" line="54">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Supprime les écrans dans le conteneur de Screens</haxe_doc>
		</closeScreens>
		<openPopin public="1" set="method" line="68">
			<f a="pPopin">
				<c path="com.isartdigital.utils.ui.Popin"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Ajoute un popin dans le conteneur de Popin
	 * @param	pPopin Popin à ouvrir</haxe_doc>
		</openPopin>
		<closeCurrentPopin public="1" set="method" line="77">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Supprime le popin dans le conteneur de Screens</haxe_doc>
		</closeCurrentPopin>
		<openHud public="1" set="method" line="89">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Ajoute le hud dans le conteneur de Hud</haxe_doc>
		</openHud>
		<closeHud public="1" set="method" line="97">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Retire le hud du conteneur de Hud</haxe_doc>
		</closeHud>
		<startGame public="1" set="method" line="105">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* met l'interface en mode jeu</haxe_doc>
		</startGame>
		<destroy public="1" set="method" line="113">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* détruit l'instance unique et met sa référence interne à null</haxe_doc>
		</destroy>
		<new public="1" set="method" line="27"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* Manager (Singleton) en charge de gérer les écrans d'interface
 * @author Mathieu ANTHOINE</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="com.isartdigital.builder.ui.hud.BaseBuildingHUD" params="" file="src/com/isartdigital/builder/ui/hud/BaseBuildingHUD.hx">
		<extends path="com.isartdigital.utils.ui.UIComponent"/>
		<_instance static="1"><c path="com.isartdigital.builder.ui.hud.BaseBuildingHUD"/></_instance>
		<getInstance public="1" set="method" line="19" static="1"><f a=""><c path="com.isartdigital.builder.ui.hud.BaseBuildingHUD"/></f></getInstance>
		<BUTTON_DELETE_NAME line="30" static="1"><c path="String"/></BUTTON_DELETE_NAME>
		<BUTTON_COLOR_NAME line="31" static="1"><c path="String"/></BUTTON_COLOR_NAME>
		<BUTTON_UPGRADABLE_NAME line="32" static="1"><c path="String"/></BUTTON_UPGRADABLE_NAME>
		<BUTTON_MOVE_NAME line="33" static="1"><c path="String"/></BUTTON_MOVE_NAME>
		<hadToMove public="1"><x path="Bool"/></hadToMove>
		<elements><c path="Array"><c path="com.isartdigital.utils.game.StateGraphic"/></c></elements>
		<hideChild set="method" line="49"><f a=""><x path="Void"/></f></hideChild>
		<initHUD public="1" set="method" line="60">
			<f a="pMove:pDelete:?pUpgrading:?pColor">
				<f a="">
					<t path="pixi.interaction.EventTarget"/>
					<x path="Void"/>
				</f>
				<f a="">
					<t path="pixi.interaction.EventTarget"/>
					<x path="Void"/>
				</f>
				<f a="">
					<t path="pixi.interaction.EventTarget"/>
					<x path="Void"/>
				</f>
				<f a="">
					<t path="pixi.interaction.EventTarget"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc>* Active le BuildingHUD</haxe_doc>
		</initHUD>
		<isClassNameEqual set="method" line="87"><f a="pName:pSuffix:pClass">
	<c path="String"/>
	<c path="String"/>
	<x path="Class"><d/></x>
	<x path="Bool"/>
</f></isClassNameEqual>
		<closeHUD public="1" set="method" line="93"><f a=""><x path="Void"/></f></closeHUD>
		<new public="1" set="method" line="35"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* ...
 * @author Flavien</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="com.isartdigital.builder.ui.hud.CurrencyAsset" params="" file="src/com/isartdigital/builder/ui/hud/CurrencyAsset.hx">
		<extends path="com.isartdigital.utils.ui.UIComponent"/>
		<changeCount public="1" set="method" line="18"><f a="pNumber">
	<x path="Int"/>
	<x path="Void"/>
</f></changeCount>
		<new public="1" set="method" line="12"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* ...
 * @author Flavien</haxe_doc>
	</class>
	<class path="com.isartdigital.builder.ui.hud.GoldCurrency" params="" file="src/com/isartdigital/builder/ui/hud/GoldCurrency.hx">
		<extends path="com.isartdigital.builder.ui.hud.CurrencyAsset"/>
		<changeCount public="1" set="method" line="23" override="1"><f a="pNumber">
	<x path="Int"/>
	<x path="Void"/>
</f></changeCount>
		<new public="1" set="method" line="17"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* ...
 * @author Flavien</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="com.isartdigital.builder.ui.hud.Hud" params="" file="src/com/isartdigital/builder/ui/hud/Hud.hx">
		<extends path="com.isartdigital.utils.ui.Screen"/>
		<instance static="1">
			<c path="com.isartdigital.builder.ui.hud.Hud"/>
			<haxe_doc>* instance unique de la classe Hud</haxe_doc>
		</instance>
		<getInstance public="1" set="method" line="39" static="1">
			<f a=""><c path="com.isartdigital.builder.ui.hud.Hud"/></f>
			<haxe_doc>* Retourne l'instance unique de la classe, et la crée si elle n'existait pas au préalable
	 * @return instance unique</haxe_doc>
		</getInstance>
		<hudRessources><c path="pixi.core.display.Container"/></hudRessources>
		<goldText><c path="pixi.core.text.Text"/></goldText>
		<spiceText><c path="pixi.core.text.Text"/></spiceText>
		<offeringText><c path="pixi.core.text.Text"/></offeringText>
		<onResize set="method" line="75" override="1">
			<f a="?pEvent">
				<t path="pixi.interaction.EventTarget"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* repositionne les éléments du Hud
	 * @param	pEvent</haxe_doc>
		</onResize>
		<refreshHUD public="1" set="method" line="84"><f a=""><x path="Void"/></f></refreshHUD>
		<cb_resourceAll set="method" line="88"><f a="pData">
	<c path="String"/>
	<x path="Void"/>
</f></cb_resourceAll>
		<destroy public="1" set="method" line="108" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* détruit l'instance unique et met sa référence interne à null</haxe_doc>
		</destroy>
		<new public="1" set="method" line="44"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* Classe en charge de gérer les informations du Hud
 * @author Mathieu ANTHOINE</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="com.isartdigital.builder.ui.hud.OfferingsCurrency" params="" file="src/com/isartdigital/builder/ui/hud/OfferingsCurrency.hx">
		<extends path="com.isartdigital.builder.ui.hud.CurrencyAsset"/>
		<changeCount public="1" set="method" line="23" override="1"><f a="pNumber">
	<x path="Int"/>
	<x path="Void"/>
</f></changeCount>
		<new public="1" set="method" line="17"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* ...
 * @author Flavien</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="com.isartdigital.builder.ui.hud.SpiceCurrency" params="" file="src/com/isartdigital/builder/ui/hud/SpiceCurrency.hx">
		<extends path="com.isartdigital.builder.ui.hud.CurrencyAsset"/>
		<changeCount public="1" set="method" line="23" override="1"><f a="pNumber">
	<x path="Int"/>
	<x path="Void"/>
</f></changeCount>
		<new public="1" set="method" line="17"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* ...
 * @author Flavien</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="com.isartdigital.utils.ui.Popin" params="" file="src/com/isartdigital/utils/ui/Popin.hx">
		<extends path="com.isartdigital.utils.ui.UIComponent"/>
		<new public="1" set="method" line="11"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* Classe de base des PopIn
 * Toutes les popin d'interface héritent de cette classe
 * @author Mathieu ANTHOINE</haxe_doc>
	</class>
	<class path="com.isartdigital.builder.ui.popin.Confirm" params="" file="src/com/isartdigital/builder/ui/popin/Confirm.hx">
		<extends path="com.isartdigital.utils.ui.Popin"/>
		<instance static="1">
			<c path="com.isartdigital.builder.ui.popin.Confirm"/>
			<haxe_doc>* instance unique de la classe Confirm</haxe_doc>
		</instance>
		<getInstance public="1" set="method" line="33" static="1">
			<f a=""><c path="com.isartdigital.builder.ui.popin.Confirm"/></f>
			<haxe_doc>* Retourne l'instance unique de la classe, et la crée si elle n'existait pas au préalable
	 * @return instance unique</haxe_doc>
		</getInstance>
		<background><c path="pixi.core.sprites.Sprite"/></background>
		<test set="method" line="55"><f a="pEvent">
	<t path="pixi.interaction.EventTarget"/>
	<x path="Void"/>
</f></test>
		<onClick set="method" line="59"><f a="pEvent">
	<t path="pixi.interaction.EventTarget"/>
	<x path="Void"/>
</f></onClick>
		<destroy public="1" set="method" line="68" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* détruit l'instance unique et met sa référence interne à null</haxe_doc>
		</destroy>
		<new set="method" line="41">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* constructeur privé pour éviter qu'une instance soit créée directement</haxe_doc>
		</new>
		<haxe_doc>* Exemple de classe héritant de Popin
 * @author Mathieu ANTHOINE</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="com.isartdigital.builder.ui.screens.TitleCard" params="" file="src/com/isartdigital/builder/ui/screens/TitleCard.hx">
		<extends path="com.isartdigital.utils.ui.Screen"/>
		<instance static="1">
			<c path="com.isartdigital.builder.ui.screens.TitleCard"/>
			<haxe_doc>* instance unique de la classe TitleCard</haxe_doc>
		</instance>
		<getInstance public="1" set="method" line="31" static="1">
			<f a=""><c path="com.isartdigital.builder.ui.screens.TitleCard"/></f>
			<haxe_doc>* Retourne l'instance unique de la classe, et la crée si elle n'existait pas au préalable
	 * @return instance unique</haxe_doc>
		</getInstance>
		<background><c path="pixi.core.sprites.Sprite"/></background>
		<destroy public="1" set="method" line="48" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* détruit l'instance unique et met sa référence interne à null</haxe_doc>
		</destroy>
		<new public="1" set="method" line="39">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* constructeur privé pour éviter qu'une instance soit créée directement</haxe_doc>
		</new>
		<haxe_doc>* Exemple de classe héritant de Screen
 * @author Mathieu ANTHOINE</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="com.isartdigital.utils.ui.Button" params="" file="src/com/isartdigital/utils/ui/Button.hx">
		<extends path="com.isartdigital.utils.game.StateGraphic"/>
		<UP get="inline" set="null" line="15" static="1"><x path="Int"/></UP>
		<OVER get="inline" set="null" line="16" static="1"><x path="Int"/></OVER>
		<DOWN get="inline" set="null" line="17" static="1"><x path="Int"/></DOWN>
		<txt><c path="pixi.core.text.Text"/></txt>
		<upStyle><t path="pixi.core.text.TextStyle"/></upStyle>
		<overStyle><t path="pixi.core.text.TextStyle"/></overStyle>
		<downStyle><t path="pixi.core.text.TextStyle"/></downStyle>
		<createText set="method" line="45"><f a=""><x path="Void"/></f></createText>
		<setText public="1" set="method" line="53"><f a="pText">
	<c path="String"/>
	<x path="Void"/>
</f></setText>
		<setModeNormal set="method" line="57" override="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":has_untyped"/></meta>
		</setModeNormal>
		<_mouseVoid set="method" line="64"><f a=""><x path="Void"/></f></_mouseVoid>
		<_click set="method" line="66">
			<f a="pEvent">
				<t path="pixi.interaction.EventTarget"/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</_click>
		<_mouseDown set="method" line="71">
			<f a="pEvent">
				<t path="pixi.interaction.EventTarget"/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</_mouseDown>
		<_mouseOver set="method" line="76">
			<f a="pEvent">
				<t path="pixi.interaction.EventTarget"/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</_mouseOver>
		<_mouseOut set="method" line="81">
			<f a="pEvent">
				<t path="pixi.interaction.EventTarget"/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</_mouseOut>
		<destroy public="1" set="method" line="86" override="1"><f a=""><x path="Void"/></f></destroy>
		<new public="1" set="method" line="25"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* Classe de base des boutons
 * @author Mathieu ANTHOINE</haxe_doc>
	</class>
	<class path="com.isartdigital.builder.ui.uimodule.ButtonsBuilding" params="" file="src/com/isartdigital/builder/ui/uimodule/ButtonsBuilding.hx">
		<extends path="com.isartdigital.utils.ui.Button"/>
		<onClick><f a="">
	<t path="pixi.interaction.EventTarget"/>
	<x path="Void"/>
</f></onClick>
		<baseOnClick set="method" line="23"><f a="pEvent">
	<t path="pixi.interaction.EventTarget"/>
	<x path="Void"/>
</f></baseOnClick>
		<setClickCallBack public="1" set="method" line="28"><f a="pCallBack">
	<f a="">
		<t path="pixi.interaction.EventTarget"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></setClickCallBack>
		<new public="1" set="method" line="14"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* ...
 * @author Flavien</haxe_doc>
	</class>
	<class path="com.isartdigital.builder.ui.uimodule.ColorButton" params="" file="src/com/isartdigital/builder/ui/uimodule/ColorButton.hx">
		<extends path="com.isartdigital.builder.ui.uimodule.ButtonsBuilding"/>
		<new public="1" set="method" line="13"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* ...
 * @author Flavien</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="com.isartdigital.builder.ui.uimodule.DeleteButton" params="" file="src/com/isartdigital/builder/ui/uimodule/DeleteButton.hx">
		<extends path="com.isartdigital.builder.ui.uimodule.ButtonsBuilding"/>
		<new public="1" set="method" line="13"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* ...
 * @author Flavien</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="com.isartdigital.builder.ui.uimodule.MoveButton" params="" file="src/com/isartdigital/builder/ui/uimodule/MoveButton.hx">
		<extends path="com.isartdigital.builder.ui.uimodule.ButtonsBuilding"/>
		<new public="1" set="method" line="15"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* ...
 * @author Flavien</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="com.isartdigital.builder.ui.uimodule.PlayButton" params="" file="src/com/isartdigital/builder/ui/uimodule/PlayButton.hx">
		<extends path="com.isartdigital.utils.ui.Button"/>
		<onClick set="method" line="25"><f a="pEvent">
	<t path="pixi.interaction.EventTarget"/>
	<x path="Void"/>
</f></onClick>
		<new public="1" set="method" line="16"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* ...
 * @author Thorcal</haxe_doc>
	</class>
	<class path="com.isartdigital.builder.ui.uimodule.UpgradeButton" params="" file="src/com/isartdigital/builder/ui/uimodule/UpgradeButton.hx">
		<extends path="com.isartdigital.builder.ui.uimodule.ButtonsBuilding"/>
		<new public="1" set="method" line="13"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* ...
 * @author Flavien</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="com.isartdigital.services.Ads" params="" file="src/com/isartdigital/services/Ads.hx">
		<TYPE_END public="1" get="inline" set="null" line="32" static="1">
			<c path="String"/>
			<haxe_doc>* Publicité vidéo vu jusqu'au bout</haxe_doc>
		</TYPE_END>
		<TYPE_CANCEL public="1" get="inline" set="null" line="37" static="1">
			<c path="String"/>
			<haxe_doc>* Annulation du visionnage d'une publicité vidéo ou fermeture d'une publicité image</haxe_doc>
		</TYPE_CANCEL>
		<TYPE_CLOSE public="1" get="inline" set="null" line="42" static="1">
			<c path="String"/>
			<haxe_doc>* Fermeture d'une publicité image</haxe_doc>
		</TYPE_CLOSE>
		<TYPE_CLICK public="1" get="inline" set="null" line="47" static="1">
			<c path="String"/>
			<haxe_doc>* click sur la publicité</haxe_doc>
		</TYPE_CLICK>
		<IMAGE get="inline" set="null" line="52" static="1">
			<c path="String"/>
			<haxe_doc>* pub image</haxe_doc>
		</IMAGE>
		<MOVIE get="inline" set="null" line="57" static="1">
			<c path="String"/>
			<haxe_doc>* pub vidéo</haxe_doc>
		</MOVIE>
		<current static="1"><c path="com.isartdigital.services._Ads.Ad"/></current>
		<callback static="1"><f a="">
	<d/>
	<x path="Void"/>
</f></callback>
		<getImage public="1" set="method" line="68" static="1">
			<f a="pCallback">
				<f a="">
					<d/>
					<x path="Void"/>
				</f>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Demande l'affichage d'un publicité image
	 * @param	pCallback fonction à appelée une fois la publicité affichée et quittée
	 * @return true si la demande d'affichage est acceptée, sinon false (quand une autre pub est en cours)</haxe_doc>
		</getImage>
		<askForImage set="method" line="72" static="1"><f a="pCallback:?pVideo">
	<f a="">
		<d/>
		<x path="Void"/>
	</f>
	<c path="String"/>
	<x path="Bool"/>
</f></askForImage>
		<getMovie public="1" set="method" line="89" static="1">
			<f a="pCallback">
				<f a="">
					<d/>
					<x path="Void"/>
				</f>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Demande l'affichage d'un publicité vidéo
	 * @param	pCallback fonction à appelée une fois la publicité affichée et quittée
	 * @return true si la demande d'affichage est acceptée, sinon false (quand une autre pub est en cours)</haxe_doc>
		</getMovie>
		<initService set="method" line="99" static="1"><f a="pCallback">
	<f a="">
		<d/>
		<x path="Void"/>
	</f>
	<c path="com.isartdigital.services.HttpService"/>
</f></initService>
		<onData set="method" line="108" static="1"><f a="pData">
	<c path="String"/>
	<x path="Void"/>
</f></onData>
		<onQuit set="method" line="115" static="1"><f a="pClose">
	<c path="String"/>
	<x path="Void"/>
</f></onQuit>
		<haxe_doc>* Service permettant d'afficher des publicités des autres Builder
 * @author Mathieu Anthoine</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="com.isartdigital.services._Ads.Ad" params="" file="src/com/isartdigital/services/Ads.hx" private="1" module="com.isartdigital.services.Ads">
		<extends path="com.isartdigital.utils.ui.Popin"/>
		<CROSS_SIZE get="inline" set="null" line="147" static="1"><x path="Int"/></CROSS_SIZE>
		<QUIT_SIZE get="inline" set="null" line="148" static="1"><x path="Int"/></QUIT_SIZE>
		<id public="1"><c path="String"/></id>
		<url><c path="String"/></url>
		<target><c path="String"/></target>
		<content><c path="pixi.core.sprites.Sprite"/></content>
		<btnQuit><c path="pixi.core.display.Container"/></btnQuit>
		<txtQuit><c path="pixi.core.text.Text"/></txtQuit>
		<timer><c path="haxe.Timer"/></timer>
		<timerError><c path="haxe.Timer"/></timerError>
		<duration><x path="Int"/></duration>
		<onError set="method" line="186"><f a=""><x path="Void"/></f></onError>
		<onTimer set="method" line="196"><f a=""><x path="Void"/></f></onTimer>
		<allowQuit set="method" line="206"><f a=""><x path="Void"/></f></allowQuit>
		<createContent set="method" line="221"><f a=""><x path="Void"/></f></createContent>
		<onComplete set="method" line="223"><f a="?pEvent">
	<c path="pixi.loaders.Loader"/>
	<x path="Void"/>
</f></onComplete>
		<quit set="method" line="236">
			<f a="pType">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</quit>
		<onQuit set="method" line="241"><f a="pEvent">
	<t path="pixi.interaction.EventTarget"/>
	<x path="Void"/>
</f></onQuit>
		<close public="1" set="method" line="244" override="1"><f a=""><x path="Void"/></f></close>
		<new public="1" set="method" line="150"><f a="pId:pUrl:pTarget">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="com.isartdigital.services._Ads.AdImage" params="" file="src/com/isartdigital/services/Ads.hx" private="1" module="com.isartdigital.services.Ads">
		<extends path="com.isartdigital.services._Ads.Ad"/>
		<onComplete set="method" line="261" override="1"><f a="?pEvent">
	<c path="pixi.loaders.Loader"/>
	<x path="Void"/>
</f></onComplete>
		<createContent set="method" line="269" override="1"><f a=""><x path="Void"/></f></createContent>
		<onOpen set="method" line="273"><f a="pEvent">
	<t path="pixi.interaction.EventTarget"/>
	<x path="Void"/>
</f></onOpen>
		<onQuit set="method" line="278" override="1"><f a="pEvent">
	<t path="pixi.interaction.EventTarget"/>
	<x path="Void"/>
</f></onQuit>
		<new public="1" set="method" line="252"><f a="pId:pUrl:pTarget">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="com.isartdigital.services._Ads.AdMovie" params="" file="src/com/isartdigital/services/Ads.hx" private="1" module="com.isartdigital.services.Ads">
		<extends path="com.isartdigital.services._Ads.Ad"/>
		<onComplete set="method" line="290" override="1"><f a="?pEvent">
	<c path="pixi.loaders.Loader"/>
	<x path="Void"/>
</f></onComplete>
		<createContent set="method" line="298" override="1"><f a=""><x path="Void"/></f></createContent>
		<onQuit set="method" line="307" override="1"><f a="pEvent">
	<t path="pixi.interaction.EventTarget"/>
	<x path="Void"/>
</f></onQuit>
		<onEnded set="method" line="311"><f a=""><x path="Void"/></f></onEnded>
		<close public="1" set="method" line="315" override="1"><f a=""><x path="Void"/></f></close>
		<new public="1" set="method" line="285"><f a="pId:pUrl:pTarget">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="com.isartdigital.services.Bank" params="" file="src/com/isartdigital/services/Bank.hx">
		<account public="1" set="method" line="15" static="1">
			<f a="?pCallback">
				<f a="">
					<d/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc>* donne accès au total des revenus générés
	 * @param	pCallback fonction appelée au retour de l'information</haxe_doc>
		</account>
		<haxe_doc>* Service Bancaire
 * @author Mathieu Anthoine</haxe_doc>
	</class>
	<class path="haxe.Http" params="" file="C:\HaxeToolkit\haxe\std/haxe/Http.hx">
		<url public="1">
			<c path="String"/>
			<haxe_doc>The url of `this` request. It is used only by the request() method and
		can be changed in order to send the same request to different target
		Urls.</haxe_doc>
		</url>
		<responseData public="1" set="null"><t path="Null"><c path="String"/></t></responseData>
		<async public="1"><x path="Bool"/></async>
		<postData><c path="String"/></postData>
		<headers><c path="List"><a>
	<value><c path="String"/></value>
	<header><c path="String"/></header>
</a></c></headers>
		<params><c path="List"><a>
	<value><c path="String"/></value>
	<param><c path="String"/></param>
</a></c></params>
		<addParameter public="1" set="method" line="134"><f a="param:value">
	<c path="String"/>
	<c path="String"/>
	<c path="haxe.Http"/>
</f></addParameter>
		<req><c path="js.html.XMLHttpRequest"/></req>
		<request public="1" set="method" line="195">
			<f a="?post">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Sends `this` Http request to the Url specified by `this.url`.

		If `post` is true, the request is sent as POST request, otherwise it is
		sent as GET request.

		Depending on the outcome of the request, this method calls the
		onStatus(), onError() or onData() callback functions.

		If `this.url` is null, the result is unspecified.

		If `this.url` is an invalid or inaccessible Url, the onError() callback
		function is called.

		(Js) If `this.async` is false, the callback functions are called before
		this method returns.</haxe_doc>
		</request>
		<onData public="1" set="dynamic" line="740">
			<f a="data">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>This method is called upon a successful request, with `data` containing
		the result String.

		The intended usage is to bind it to a custom function:
		`httpInstance.onData = function(data) { // handle result }`</haxe_doc>
		</onData>
		<onError public="1" set="dynamic" line="750">
			<f a="msg">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>This method is called upon a request error, with `msg` containing the
		error description.

		The intended usage is to bind it to a custom function:
		`httpInstance.onError = function(msg) { // handle error }`</haxe_doc>
		</onError>
		<onStatus public="1" set="dynamic" line="760">
			<f a="status">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>This method is called upon a Http status change, with `status` being the
		new status.

		The intended usage is to bind it to a custom function:
		`httpInstance.onStatus = function(status) { // handle status }`</haxe_doc>
		</onStatus>
		<new public="1" set="method" line="88">
			<f a="url">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a new Http instance with `url` as parameter.

		This does not do a request until request() is called.

		If `url` is null, the field url must be set to a value before making the
		call to request(), or the result is unspecified.

		(Php) Https (SSL) connections are allowed only if the OpenSSL extension
		is enabled.</haxe_doc>
		</new>
		<haxe_doc>This class can be used to handle Http requests consistently across
	platforms. There are two intended usages:

	- call haxe.Http.requestUrl(url) and receive the result as a String (not
	available on flash)
	- create a new haxe.Http(url), register your callbacks for onData, onError
	and onStatus, then call request().</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="com.isartdigital.services.HttpService" params="" file="src/com/isartdigital/services/HttpService.hx">
		<extends path="haxe.Http"/>
		<SERVICE_PATH get="inline" set="null" line="15" static="1"><c path="String"/></SERVICE_PATH>
		<callback><f a="">
	<d/>
	<x path="Void"/>
</f></callback>
		<_onData set="method" line="28"><f a="pData">
	<c path="String"/>
	<x path="Void"/>
</f></_onData>
		<_onError set="method" line="33"><f a="pError">
	<c path="String"/>
	<x path="Void"/>
</f></_onError>
		<new public="1" set="method" line="17"><f a="?pCallback">
	<f a="">
		<d/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></new>
		<haxe_doc>* ...
 * @author Mathieu Anthoine</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="com.isartdigital.services.Users" params="" file="src/com/isartdigital/services/Users.hx">
		<infos public="1" set="accessor" static="1"><t path="com.isartdigital.builder.game.def.UserInfoDef"/></infos>
		<set_infos set="method" line="19" static="1"><f a="infosSource">
	<d/>
	<t path="com.isartdigital.builder.game.def.UserInfoDef"/>
</f></set_infos>
		<typeUserInfos set="method" line="25" static="1"><f a="userInfos">
	<d/>
	<t path="com.isartdigital.builder.game.def.UserInfoDef"/>
</f></typeUserInfos>
		<new public="1" set="method" line="13"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* ...
 * @author Dorian MILLIERE</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="com.isartdigital.services.Wallet" params="" file="src/com/isartdigital/services/Wallet.hx">
		<getMoney public="1" set="method" line="20" static="1">
			<f a="pMail:pCallback">
				<c path="String"/>
				<f a="">
					<d/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc>* Retourne le montant du porte maonnaie virtuel de l'utilisateur
	 * @param	pMail mail de l'utilisateur
	 * @param	pCallback fonction appelée au retour de l'information</haxe_doc>
		</getMoney>
		<buy public="1" set="method" line="29" static="1">
			<f a="pMail:pAmount:pCallback">
				<c path="String"/>
				<x path="Float"/>
				<f a="">
					<d/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc>* Retire une somme au porte monnaie virtuel de l'utilisateur
	 * @param	pMail mail de l'utilisateur
	 * @param	pCallback fonction appelée au retour de l'information</haxe_doc>
		</buy>
		<initService set="method" line="41" static="1"><f a="pMail:pCallback">
	<c path="String"/>
	<f a="">
		<d/>
		<x path="Void"/>
	</f>
	<c path="com.isartdigital.services.HttpService"/>
</f></initService>
		<haxe_doc>* Service permettant de créer un porte monnaie par joueur des Builder
 * Le porte monnaie est partagé entre tous les Builder
 * @author Mathieu Anthoine</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="com.isartdigital.utils.Config" params="" file="src/com/isartdigital/utils/Config.hx">
		<version public="1" get="accessor" set="null" static="1">
			<c path="String"/>
			<haxe_doc>* version de l'application</haxe_doc>
		</version>
		<language public="1" get="accessor" set="null" static="1">
			<c path="String"/>
			<haxe_doc>* langue courante</haxe_doc>
		</language>
		<languages public="1" get="accessor" set="null" static="1">
			<c path="Array"><c path="String"/></c>
			<haxe_doc>* langues disponibles</haxe_doc>
		</languages>
		<debug public="1" get="accessor" set="null" static="1">
			<x path="Bool"/>
			<haxe_doc>* défini si le jeu est en mode "debug" ou pas (si prévu dans le code du jeu)</haxe_doc>
		</debug>
		<fps public="1" get="accessor" set="null" static="1">
			<x path="Bool"/>
			<haxe_doc>* défini si il faut afficher les fps ou non</haxe_doc>
		</fps>
		<qrcode public="1" get="accessor" set="null" static="1">
			<x path="Bool"/>
			<haxe_doc>* défini si il faut afficher le qrcode ou non</haxe_doc>
		</qrcode>
		<langPath public="1" get="accessor" set="null" static="1">
			<c path="String"/>
			<haxe_doc>* chemin du dossier de langues</haxe_doc>
		</langPath>
		<txtsPath public="1" get="accessor" set="null" static="1">
			<c path="String"/>
			<haxe_doc>* chemin du dossier des fichiers textes</haxe_doc>
		</txtsPath>
		<assetsPath public="1" get="accessor" set="null" static="1">
			<c path="String"/>
			<haxe_doc>* chemin du dossier d'assets graphiques</haxe_doc>
		</assetsPath>
		<soundsPath public="1" get="accessor" set="null" static="1">
			<c path="String"/>
			<haxe_doc>* chemin du dossier de sons</haxe_doc>
		</soundsPath>
		<jsonPath public="1" get="accessor" set="null" static="1">
			<c path="String"/>
			<haxe_doc>* chemin du dossier de sons</haxe_doc>
		</jsonPath>
		<fontsPath public="1" get="accessor" set="null" static="1">
			<c path="String"/>
			<haxe_doc>* chemin du dossier des polices de caractères</haxe_doc>
		</fontsPath>
		<tileWidth public="1" line="81" static="1">
			<x path="UInt"/>
			<haxe_doc>* Tailles (en px) des tiles</haxe_doc>
		</tileWidth>
		<tileHeight public="1" line="82" static="1"><x path="UInt"/></tileHeight>
		<data public="1" get="accessor" set="null" static="1">
			<d/>
			<haxe_doc>* conteneur des données de configuration</haxe_doc>
		</data>
		<_data line="88" static="1"><d/></_data>
		<init public="1" set="method" line="90" static="1"><f a="pConfig">
	<c path="haxe.Json"/>
	<x path="Void"/>
</f></init>
		<get_data set="method" line="110" static="1"><f a=""><d/></f></get_data>
		<get_version set="method" line="114" static="1"><f a=""><c path="String"/></f></get_version>
		<get_language set="method" line="118" static="1"><f a=""><c path="String"/></f></get_language>
		<get_languages set="method" line="122" static="1"><f a=""><c path="Array"><c path="String"/></c></f></get_languages>
		<get_debug set="method" line="126" static="1"><f a=""><x path="Bool"/></f></get_debug>
		<get_fps set="method" line="130" static="1"><f a=""><x path="Bool"/></f></get_fps>
		<get_qrcode set="method" line="134" static="1"><f a=""><x path="Bool"/></f></get_qrcode>
		<get_langPath set="method" line="138" static="1"><f a=""><c path="String"/></f></get_langPath>
		<get_txtsPath set="method" line="142" static="1"><f a=""><c path="String"/></f></get_txtsPath>
		<get_assetsPath set="method" line="146" static="1"><f a=""><c path="String"/></f></get_assetsPath>
		<get_fontsPath set="method" line="150" static="1"><f a=""><c path="String"/></f></get_fontsPath>
		<get_soundsPath set="method" line="154" static="1"><f a=""><c path="String"/></f></get_soundsPath>
		<get_jsonPath set="method" line="158" static="1"><f a=""><c path="String"/></f></get_jsonPath>
		<haxe_doc>* Classe utilitaire contenant les données de configuration du jeu
 * @author Mathieu ANTHOINE</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="com.isartdigital.utils.Debug" params="" file="src/com/isartdigital/utils/Debug.hx">
		<instance static="1">
			<c path="com.isartdigital.utils.Debug"/>
			<haxe_doc>* instance unique de la classe Main</haxe_doc>
		</instance>
		<QR_SIZE get="inline" set="null" line="23" static="1"><x path="Float"/></QR_SIZE>
		<getInstance public="1" set="method" line="30" static="1">
			<f a=""><c path="com.isartdigital.utils.Debug"/></f>
			<haxe_doc>* Retourne l'instance unique de la classe, et la crée si elle n'existait pas au préalable
	 * @return instance unique</haxe_doc>
		</getInstance>
		<error public="1" set="method" line="71" static="1">
			<f a="pArg">
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</error>
		<warn public="1" set="method" line="75" static="1">
			<f a="pArg">
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</warn>
		<table public="1" set="method" line="79" static="1">
			<f a="pArg">
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</table>
		<info public="1" set="method" line="83" static="1">
			<f a="pArg">
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</info>
		<fps public="1"><c path="jsfps.fpsmeter.FPSMeter"/></fps>
		<ticker><c path="pixi.core.ticker.Ticker"/></ticker>
		<init public="1" set="method" line="41">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* initialisation du débogueur
	 * @param	pGameDispatcher</haxe_doc>
		</init>
		<updateFps set="method" line="66"><f a=""><x path="Void"/></f></updateFps>
		<destroy public="1" set="method" line="87"><f a=""><x path="Void"/></f></destroy>
		<new set="method" line="35"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* Classe de Debug
 * @author Mathieu ANTHOINE</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="com.isartdigital.utils.Localization" params="" file="src/com/isartdigital/utils/Localization.hx">
		<LANG_EN public="1" get="inline" set="null" line="19" static="1"><c path="String"/></LANG_EN>
		<LANG_FR public="1" get="inline" set="null" line="20" static="1"><c path="String"/></LANG_FR>
		<instance static="1">
			<c path="com.isartdigital.utils.Localization"/>
			<haxe_doc>* instance unique de la classe Localization</haxe_doc>
		</instance>
		<getInstance public="1" set="method" line="30" static="1">
			<f a=""><c path="com.isartdigital.utils.Localization"/></f>
			<haxe_doc>* Retourne l'instance unique de la classe, et la crée si elle n'existait pas au préalable
	 * @return instance unique</haxe_doc>
		</getInstance>
		<myJson><x path="Map">
	<c path="String"/>
	<c path="String"/>
</x></myJson>
		<json><c path="haxe.Json"/></json>
		<selectJson public="1" set="method" line="43"><f a="pLang">
	<c path="String"/>
	<x path="Void"/>
</f></selectJson>
		<getText public="1" set="method" line="47"><f a="pLabel">
	<c path="String"/>
	<x path="Void"/>
</f></getText>
		<setDataLocalization public="1" set="method" line="51"><f a="pData">
	<c path="String"/>
	<x path="Void"/>
</f></setDataLocalization>
		<destroy public="1" set="method" line="59">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* détruit l'instance unique et met sa référence interne à null</haxe_doc>
		</destroy>
		<new set="method" line="38">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* constructeur privé pour éviter qu'une instance soit créée directement</haxe_doc>
		</new>
		<haxe_doc>* ...
 * @author Thorcal</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="com.isartdigital.utils.events.EventType" params="" file="src/com/isartdigital/utils/events/EventType.hx">
		<GAME_LOOP public="1" get="inline" set="null" line="10" static="1"><c path="String"/></GAME_LOOP>
		<RESIZE public="1" get="inline" set="null" line="11" static="1"><c path="String"/></RESIZE>
		<ADDED public="1" get="inline" set="null" line="13" static="1"><c path="String"/></ADDED>
		<REMOVED public="1" get="inline" set="null" line="14" static="1"><c path="String"/></REMOVED>
		<haxe_doc>* @author Mathieu ANTHOINE</haxe_doc>
	</class>
	<class path="com.isartdigital.utils.events.FacebookEventType" params="" file="src/com/isartdigital/utils/events/FacebookEventType.hx">
		<extends path="com.isartdigital.utils.events.EventType"/>
		<CONNECTED public="1" get="inline" set="null" line="10" static="1"><c path="String"/></CONNECTED>
		<NOT_AUTHORIZED public="1" get="inline" set="null" line="11" static="1"><c path="String"/></NOT_AUTHORIZED>
		<UNKNOWN public="1" get="inline" set="null" line="12" static="1"><c path="String"/></UNKNOWN>
		<haxe_doc>* ...
 * @author Mathieu Anthoine</haxe_doc>
	</class>
	<class path="com.isartdigital.utils.events.LoadEventType" params="" file="src/com/isartdigital/utils/events/LoadEventType.hx">
		<extends path="com.isartdigital.utils.events.EventType"/>
		<COMPLETE public="1" get="inline" set="null" line="10" static="1"><c path="String"/></COMPLETE>
		<LOADED public="1" get="inline" set="null" line="11" static="1"><c path="String"/></LOADED>
		<PROGRESS public="1" get="inline" set="null" line="12" static="1"><c path="String"/></PROGRESS>
		<haxe_doc>* ...
 * @author Mathieu ANTHOINE</haxe_doc>
	</class>
	<class path="com.isartdigital.utils.events.MouseEventType" params="" file="src/com/isartdigital/utils/events/MouseEventType.hx">
		<extends path="com.isartdigital.utils.events.EventType"/>
		<MOUSE_MOVE public="1" get="inline" set="null" line="10" static="1"><c path="String"/></MOUSE_MOVE>
		<MOUSE_DOWN public="1" get="inline" set="null" line="11" static="1"><c path="String"/></MOUSE_DOWN>
		<MOUSE_OUT public="1" get="inline" set="null" line="12" static="1"><c path="String"/></MOUSE_OUT>
		<MOUSE_OVER public="1" get="inline" set="null" line="13" static="1"><c path="String"/></MOUSE_OVER>
		<MOUSE_UP public="1" get="inline" set="null" line="14" static="1"><c path="String"/></MOUSE_UP>
		<MOUSE_UP_OUTSIDE public="1" get="inline" set="null" line="15" static="1"><c path="String"/></MOUSE_UP_OUTSIDE>
		<CLICK public="1" get="inline" set="null" line="16" static="1"><c path="String"/></CLICK>
		<RIGHT_DOWN public="1" get="inline" set="null" line="18" static="1"><c path="String"/></RIGHT_DOWN>
		<RIGHT_UP public="1" get="inline" set="null" line="19" static="1"><c path="String"/></RIGHT_UP>
		<RIGHT_UP_OUTSIDE public="1" get="inline" set="null" line="20" static="1"><c path="String"/></RIGHT_UP_OUTSIDE>
		<RIGHT_CLICK public="1" get="inline" set="null" line="21" static="1"><c path="String"/></RIGHT_CLICK>
		<haxe_doc>* ...
 * @author Mathieu ANTHOINE</haxe_doc>
	</class>
	<class path="com.isartdigital.utils.events.TouchEventType" params="" file="src/com/isartdigital/utils/events/TouchEventType.hx">
		<extends path="com.isartdigital.utils.events.EventType"/>
		<TOUCH_START public="1" get="inline" set="null" line="10" static="1"><c path="String"/></TOUCH_START>
		<TOUCH_MOVE public="1" get="inline" set="null" line="11" static="1"><c path="String"/></TOUCH_MOVE>
		<TOUCH_END public="1" get="inline" set="null" line="12" static="1"><c path="String"/></TOUCH_END>
		<TOUCH_END_OUTSIDE public="1" get="inline" set="null" line="13" static="1"><c path="String"/></TOUCH_END_OUTSIDE>
		<TAP public="1" get="inline" set="null" line="14" static="1"><c path="String"/></TAP>
		<haxe_doc>* ...
 * @author Mathieu ANTHOINE</haxe_doc>
	</class>
	<typedef path="com.isartdigital.utils.facebook.AuthResponse" params="" file="src/com/isartdigital/utils/facebook/AuthResponse.hx">
		<a>
			<userID><c path="String"/></userID>
			<signedRequest><c path="String"/></signedRequest>
			<expiresIn><c path="String"/></expiresIn>
			<accessToken><c path="String"/></accessToken>
		</a>
		<haxe_doc>* @author Mathieu Anthoine</haxe_doc>
	</typedef>
	<class path="com.isartdigital.utils.facebook.Facebook" params="" file="src/com/isartdigital/utils/facebook/Facebook.hx">
		<appId static="1">
			<c path="String"/>
			<haxe_doc>* id de l'app</haxe_doc>
		</appId>
		<authResponse static="1">
			<t path="com.isartdigital.utils.facebook.AuthResponse"/>
			<haxe_doc>* informations de l'application une fois connectée</haxe_doc>
		</authResponse>
		<token public="1" set="null" static="1">
			<c path="String"/>
			<haxe_doc>* access token</haxe_doc>
		</token>
		<uid public="1" set="null" static="1">
			<c path="String"/>
			<haxe_doc>* user id</haxe_doc>
		</uid>
		<permissions line="40" static="1">
			<t path="com.isartdigital.utils.facebook.Permissions"/>
			<haxe_doc>* permissions de l'application</haxe_doc>
		</permissions>
		<onLogin public="1" static="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* callback de connexion</haxe_doc>
		</onLogin>
		<init set="method" line="50" static="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>* Initialisation asynchrone de la lib Facebook</haxe_doc>
		</init>
		<load public="1" set="method" line="66" static="1">
			<f a="pAppId:?pPermissions">
				<c path="String"/>
				<t path="com.isartdigital.utils.facebook.Permissions"/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>* Chargement et connexion à l'app Facebook
	 * @param	pAppId</haxe_doc>
		</load>
		<getLoginStatus set="method" line="91" static="1">
			<f a="pResponse">
				<t path="com.isartdigital.utils.facebook.Response"/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>* Permet de déterminer su un utilisateur est loggé dans Facebook
	 * @param	pResponse</haxe_doc>
		</getLoginStatus>
		<api public="1" set="method" line="115" static="1">
			<f a="pPath:pMethod:?pParams:?pCallBack">
				<c path="String"/>
				<d/>
				<d/>
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>* permet un appel à Graph API
	 * La méthode peut être appelée de différentes facons:
	 * 
	 * Facebook.api (pPath,pCallBack);
	 * Facebook.api (pPath,pParams,pCallBack);
	 * Facebook.api (pPath,pMethod,pParams,pCallBack);
	 * 
	 * @param	pPath path de la graph API
	 * @param	pMethod méthode HTTP ("get","post", "delete")
	 * @param	pParams paramètres à passer à l'appel
	 * @param	pCallBack fonction de retour</haxe_doc>
		</api>
		<ui public="1" set="method" line="124" static="1">
			<f a="pParams:?pCallBack">
				<d/>
				<f a="">
					<d/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>* permet de déclencher l'apparition de différentes fenêtres de dialogue UI
	 * @param	pParams paramètres de la fenêtre appelée
	 * @param	pCallBack function appelée à la fermeture de la fenêtre de dialogue</haxe_doc>
		</ui>
		<haxe_doc>* Classe haxe permettant l'accès à l'api Facebook 
 * @author Mathieu Anthoine</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="com.isartdigital.utils.facebook.Permissions" params="" file="src/com/isartdigital/utils/facebook/Permissions.hx">
		<a>
			<scope><c path="String"/></scope>
			<return_scopes>
				<t path="Null"><x path="Bool"/></t>
				<meta><m n=":optional"/></meta>
			</return_scopes>
			<profile_selector_ids>
				<t path="Null"><x path="Bool"/></t>
				<meta><m n=":optional"/></meta>
			</profile_selector_ids>
			<enable_profile_selector>
				<t path="Null"><x path="Bool"/></t>
				<meta><m n=":optional"/></meta>
			</enable_profile_selector>
			<auth_type>
				<t path="Null"><c path="String"/></t>
				<meta><m n=":optional"/></meta>
			</auth_type>
		</a>
		<haxe_doc>* @author Mathieu Anthoine</haxe_doc>
	</typedef>
	<typedef path="com.isartdigital.utils.facebook.Response" params="" file="src/com/isartdigital/utils/facebook/Response.hx">
		<a>
			<status><c path="String"/></status>
			<authResponse>
				<t path="Null"><t path="com.isartdigital.utils.facebook.AuthResponse"/></t>
				<meta><m n=":optional"/></meta>
			</authResponse>
		</a>
		<haxe_doc>* @author Mathieu Anthoine</haxe_doc>
	</typedef>
	<enum path="com.isartdigital.utils.game.BoxType" params="" file="src/com/isartdigital/utils/game/BoxType.hx">
		<NONE/>
		<SIMPLE/>
		<MULTIPLE/>
		<SELF/>
		<haxe_doc>* @author Mathieu ANTHOINE</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<class path="com.isartdigital.utils.game.Camera" params="" file="src/com/isartdigital/utils/game/Camera.hx">
		<instance static="1">
			<c path="com.isartdigital.utils.game.Camera"/>
			<haxe_doc>* instance unique de la classe GamePlane</haxe_doc>
		</instance>
		<getInstance public="1" set="method" line="53" static="1">
			<f a=""><c path="com.isartdigital.utils.game.Camera"/></f>
			<haxe_doc>* Retourne l'instance unique de la classe, et la crée si elle n'existait pas au préalable
	 * @return instance unique</haxe_doc>
		</getInstance>
		<render><d/></render>
		<target public="1" set="null"><c path="pixi.core.display.DisplayObject"/></target>
		<focus public="1" set="null"><c path="pixi.core.display.DisplayObject"/></focus>
		<cameraFocus public="1"><c path="com.isartdigital.utils.game.GameObject"/></cameraFocus>
		<inertiaMax><x path="Float"/></inertiaMax>
		<inertiaMin><x path="Float"/></inertiaMin>
		<countH><x path="UInt"/></countH>
		<delayH><x path="UInt"/></delayH>
		<countV><x path="UInt"/></countV>
		<delayV><x path="UInt"/></delayV>
		<startPosition><c path="pixi.core.math.Point"/></startPosition>
		<positionLayer><c path="pixi.core.math.Point"/></positionLayer>
		<speedLimite><x path="Float"/></speedLimite>
		<refreshMouseCoordinates set="method" line="65"><f a="pEvent">
	<c path="js.html.MouseEvent"/>
	<x path="Void"/>
</f></refreshMouseCoordinates>
		<onDrag set="method" line="70"><f a="?pEvent">
	<c path="js.html.MouseEvent"/>
	<x path="Void"/>
</f></onDrag>
		<onUp set="method" line="76"><f a="pEvent">
	<c path="js.html.MouseEvent"/>
	<x path="Void"/>
</f></onUp>
		<centerView public="1" set="method" line="80"><f a=""><x path="Void"/></f></centerView>
		<setTarget public="1" set="method" line="92">
			<f a="pTarget">
				<c path="pixi.core.display.DisplayObject"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Défini la cible de la caméra
	 * @param	pTarget cible</haxe_doc>
		</setTarget>
		<setFocus public="1" set="method" line="100">
			<f a="pFocus">
				<c path="pixi.core.display.DisplayObject"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Défini l'élement à repositionner au centre de l'écran
	 * @param	pFocus focus</haxe_doc>
		</setFocus>
		<changePosition set="method" line="108">
			<f a="?pDelay">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* recadre la caméra
	 * @param	pDelay si false, la caméra est recadrée instantannément</haxe_doc>
		</changePosition>
		<checkSpeedLimit set="method" line="131"><f a="pSpeed">
	<x path="Float"/>
	<x path="Float"/>
</f></checkSpeedLimit>
		<getInertiaX set="method" line="142">
			<f a=""><x path="Float"/></f>
			<haxe_doc>* retourne une inertie en X variable suivant le temps
	 * @return inertie en X</haxe_doc>
		</getInertiaX>
		<getInertiaY set="method" line="151">
			<f a=""><x path="Float"/></f>
			<haxe_doc>* retourne une inertie en Y variable suivant le temps
	 * @return inertie en Y</haxe_doc>
		</getInertiaY>
		<setPosition public="1" set="method" line="159">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* cadre instantannément la caméra sur le focus</haxe_doc>
		</setPosition>
		<isInLimit set="method" line="169">
			<f a="pPosition">
				<c path="pixi.core.math.Point"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Vérifie que la position donné est dans les limites du jeu
	 * @param	pPosition
	 * @return</haxe_doc>
		</isInLimit>
		<move public="1" set="method" line="180">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* cadre la caméra sur le focus avec de l'inertie</haxe_doc>
		</move>
		<resetX public="1" set="method" line="195">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* remet à zéro le compteur qui fait passer la caméra de l'inertie en X maximum à minimum</haxe_doc>
		</resetX>
		<resetY public="1" set="method" line="202">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* remet à zéro le compteur qui fait passer la caméra de l'inertie en Y maximum à minimum</haxe_doc>
		</resetY>
		<getFocusCoord public="1" set="method" line="209">
			<f a=""><c path="pixi.core.math.Point"/></f>
			<haxe_doc>* retourne les coordonnées du focus dans le repère de la target</haxe_doc>
		</getFocusCoord>
		<destroy public="1" set="method" line="216">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* détruit l'instance unique et met sa référence interne à null</haxe_doc>
		</destroy>
		<new set="method" line="58"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* Classe Camera
 * @author Mathieu ANTHOINE</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="com.isartdigital.utils.game.CollisionManager" params="" file="src/com/isartdigital/utils/game/CollisionManager.hx">
		<hitTestObject public="1" set="method" line="27" static="1">
			<f a="pObjectA:pObjectB">
				<c path="pixi.core.display.DisplayObject"/>
				<c path="pixi.core.display.DisplayObject"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* test la collision entre les boites englobantes de deux DisplayObject
	 * @param	pObjectA objet à tester
	 * @param	pObjectB objet à tester
	 * @return résultat du test de collision</haxe_doc>
		</hitTestObject>
		<hitTestPoint public="1" set="method" line="39" static="1">
			<f a="pItem:pGlobalPoint">
				<c path="pixi.core.display.DisplayObject"/>
				<c path="pixi.core.math.Point"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>* test la collision entre l'objet et un point (prend en compte la hitArea si elle est définie). Légère adaptation de la méthode hitTest de la classe InteractionManager
	 * @param	pObject objet à tester
	 * @param	pPoint point exprimé en coordonnées globales
	 * @return	résultat du test de collision</haxe_doc>
		</hitTestPoint>
		<hasCollision public="1" set="method" line="92" static="1">
			<f a="pHitBoxA:pHitBoxB:?pPointsA:?pPointsB">
				<c path="pixi.core.display.DisplayObject"/>
				<c path="pixi.core.display.DisplayObject"/>
				<c path="Array"><c path="pixi.core.math.Point"/></c>
				<c path="Array"><c path="pixi.core.math.Point"/></c>
				<x path="Bool"/>
			</f>
			<haxe_doc>* 
	 * @param	pHitBoxA boite englobante principale
	 * @param	pHitBoxB boite englobante principale
	 * @param	pPointsA liste de points de collision
	 * @param	pPointsB liste de points de collision
	 * @return  résultat de la collision</haxe_doc>
		</hasCollision>
		<getIntersection set="method" line="115" static="1">
			<f a="pRectA:pRectB">
				<c path="pixi.core.math.shapes.Rectangle"/>
				<c path="pixi.core.math.shapes.Rectangle"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* teste l'intersection des boites englobantes
	 * @param	pRectA rectangle à tester
	 * @param	pRectB rectangle à tester
	 * @return résultat de l'intersection</haxe_doc>
		</getIntersection>
		<testPoints set="method" line="125" static="1">
			<f a="pHitPoints:pHitBox">
				<c path="Array"><c path="pixi.core.math.Point"/></c>
				<c path="pixi.core.display.DisplayObject"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* 
	 * @param	pHitPoints liste de points de collision (dont le repère est déjà converti en global)
	 * @param	pHitBox boite englobante
	 * @return  résultat de la collision</haxe_doc>
		</testPoints>
		<new set="method" line="19"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* Classe utilitaire permettant de tester diverses collisions entre boites, formes et points
 * @author Mathieu ANTHOINE
 * @version 0.9.0</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="com.isartdigital.utils.game.GameStage" params="" file="src/com/isartdigital/utils/game/GameStage.hx">
		<extends path="pixi.core.display.Container"/>
		<instance static="1">
			<c path="com.isartdigital.utils.game.GameStage"/>
			<haxe_doc>* instance unique de la classe GameStage</haxe_doc>
		</instance>
		<SAFE_ZONE_WIDTH get="inline" set="null" line="35" static="1">
			<x path="Int"/>
			<haxe_doc>* largeur minimum pour le contenu visible par défaut</haxe_doc>
		</SAFE_ZONE_WIDTH>
		<SAFE_ZONE_HEIGHT get="inline" set="null" line="40" static="1">
			<x path="Int"/>
			<haxe_doc>* hauteur minimum pour le contenu visible par défaut</haxe_doc>
		</SAFE_ZONE_HEIGHT>
		<getInstance public="1" set="method" line="140" static="1">
			<f a=""><c path="com.isartdigital.utils.game.GameStage"/></f>
			<haxe_doc>* Retourne l'instance unique de la classe, et la crée si elle n'existait pas au préalable
	 * @return instance unique</haxe_doc>
		</getInstance>
		<_alignMode><e path="com.isartdigital.utils.game.GameStageAlign"/></_alignMode>
		<_scaleMode><e path="com.isartdigital.utils.game.GameStageScale"/></_scaleMode>
		<_safeZone><c path="pixi.core.math.shapes.Rectangle"/></_safeZone>
		<_render>
			<f a=""><x path="Void"/></f>
			<haxe_doc>* callback de render</haxe_doc>
		</_render>
		<popinsContainer>
			<c path="pixi.core.display.Container"/>
			<haxe_doc>* conteneur des pop-in</haxe_doc>
		</popinsContainer>
		<hudContainer>
			<c path="pixi.core.display.Container"/>
			<haxe_doc>* conteneur du Hud</haxe_doc>
		</hudContainer>
		<screensContainer>
			<c path="pixi.core.display.Container"/>
			<haxe_doc>* conteneur des écrans d'interface</haxe_doc>
		</screensContainer>
		<gameContainer>
			<c path="pixi.core.display.Container"/>
			<haxe_doc>* conteneur du jeu</haxe_doc>
		</gameContainer>
		<tilesContainer>
			<c path="pixi.core.display.Container"/>
			<haxe_doc>* conteneur des tiles</haxe_doc>
		</tilesContainer>
		<buildingsContainer>
			<c path="pixi.core.display.Container"/>
			<haxe_doc>* conteneur des buildings</haxe_doc>
		</buildingsContainer>
		<backgroundContainer>
			<c path="pixi.core.display.Container"/>
			<haxe_doc>* conteneur du background</haxe_doc>
		</backgroundContainer>
		<init public="1" set="method" line="113">
			<f a="pRender:?pSafeZoneWidth:?pSafeZoneHeight:?pCenterGameContainer:?pCenterScreensContainer:?pCenterPopinContainer">
				<f a=""><x path="Void"/></f>
				<x path="UInt"/>
				<x path="UInt"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Initialisation de la zone de jeu
	 * @param   pRender Callback qui fait le rendu pour mettre à jour le système de coordonnées avant de reconstruire d'éventuels éléments
	 * @param	pSafeZoneWidth largeur de la safeZone
	 * @param	pSafeZoneHeight hauteur de la safeZone
	 * @param	centerGameContainer centrer ou pas le conteneur des élements InGame
	 * @param	centerScreensContainer centrer ou pas le conteneur des Ecrans
	 * @param	centerPopinContainer centrer ou pas le conteneur des Popins</haxe_doc>
		</init>
		<resize public="1" set="method" line="148">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Redimensionne la scène du jeu en fonction de la taille disponible pour l'affichage</haxe_doc>
		</resize>
		<render public="1" set="method" line="176">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* fait le rendu de l'écran</haxe_doc>
		</render>
		<alignMode public="1" get="accessor" set="accessor"><e path="com.isartdigital.utils.game.GameStageAlign"/></alignMode>
		<get_alignMode set="method" line="185"><f a=""><e path="com.isartdigital.utils.game.GameStageAlign"/></f></get_alignMode>
		<set_alignMode set="method" line="189"><f a="pAlign">
	<e path="com.isartdigital.utils.game.GameStageAlign"/>
	<e path="com.isartdigital.utils.game.GameStageAlign"/>
</f></set_alignMode>
		<scaleMode public="1" get="accessor" set="accessor"><e path="com.isartdigital.utils.game.GameStageScale"/></scaleMode>
		<get_scaleMode set="method" line="200"><f a=""><e path="com.isartdigital.utils.game.GameStageScale"/></f></get_scaleMode>
		<set_scaleMode set="method" line="204"><f a="pScale">
	<e path="com.isartdigital.utils.game.GameStageScale"/>
	<e path="com.isartdigital.utils.game.GameStageScale"/>
</f></set_scaleMode>
		<safeZone public="1" get="accessor" set="null">
			<c path="pixi.core.math.shapes.Rectangle"/>
			<haxe_doc>* Rectangle délimitant le contenu minimum visible</haxe_doc>
		</safeZone>
		<get_safeZone set="method" line="215"><f a=""><c path="pixi.core.math.shapes.Rectangle"/></f></get_safeZone>
		<getGameContainer public="1" set="method" line="223">
			<f a=""><c path="pixi.core.display.Container"/></f>
			<haxe_doc>* accès en lecture au conteneur de jeu
	 * @return gameContainer</haxe_doc>
		</getGameContainer>
		<getScreensContainer public="1" set="method" line="231">
			<f a=""><c path="pixi.core.display.Container"/></f>
			<haxe_doc>* accès en lecture au conteneur d'écrans
	 * @return screensContainer</haxe_doc>
		</getScreensContainer>
		<getHudContainer public="1" set="method" line="239">
			<f a=""><c path="pixi.core.display.Container"/></f>
			<haxe_doc>* accès en lecture au conteneur de hud
	 * @return hudContainer</haxe_doc>
		</getHudContainer>
		<getPopinsContainer public="1" set="method" line="247">
			<f a=""><c path="pixi.core.display.Container"/></f>
			<haxe_doc>* accès en lecture au conteneur de PopIn
	 * @return popinContainer</haxe_doc>
		</getPopinsContainer>
		<getTilesContainer public="1" set="method" line="256">
			<f a=""><c path="pixi.core.display.Container"/></f>
			<haxe_doc>* Accès en lecture au contenaure de tiles		
	 * @return conteneur de tiles</haxe_doc>
		</getTilesContainer>
		<getBuildingsContainer public="1" set="method" line="264">
			<f a=""><c path="pixi.core.display.Container"/></f>
			<haxe_doc>* Accès en lecture au contenaure de buildings		
	 * @return conteneur de buildings</haxe_doc>
		</getBuildingsContainer>
		<getBackgroundContainer public="1" set="method" line="272">
			<f a=""><c path="pixi.core.display.Container"/></f>
			<haxe_doc>* Accès en lecture au contenaure de buildings		
	 * @return conteneur de background</haxe_doc>
		</getBackgroundContainer>
		<destroy public="1" set="method" line="279" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* détruit l'instance unique et met sa référence interne à null</haxe_doc>
		</destroy>
		<new public="1" set="method" line="78"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* Classe en charge de mettre en place la structure graphique du jeu (conteneurs divers)
 * et la gestion du redimensionnement de la zone de jeu en fonction du contexte
 * @author Mathieu ANTHOINE</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<enum path="com.isartdigital.utils.game.GameStageAlign" params="" file="src/com/isartdigital/utils/game/GameStageAlign.hx">
		<TOP/>
		<TOP_LEFT/>
		<TOP_RIGHT/>
		<CENTER/>
		<LEFT/>
		<RIGHT/>
		<BOTTOM/>
		<BOTTOM_LEFT/>
		<BOTTOM_RIGHT/>
		<haxe_doc>* Type d'alignement possible du GameStage
 * @author Mathieu ANTHOINE</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<enum path="com.isartdigital.utils.game.GameStageScale" params="" file="src/com/isartdigital/utils/game/GameStageScale.hx">
		<NO_SCALE/>
		<SHOW_ALL/>
		<haxe_doc>* Type de mode de redimensionnement du GameStage
 * @author Mathieu ANTHOINE</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<class path="com.isartdigital.utils.game.factory.AnimFactory" params="" file="src/com/isartdigital/utils/game/factory/AnimFactory.hx">
		<anim><c path="pixi.core.display.Container"/></anim>
		<getAnim public="1" set="method" line="19"><f a=""><c path="pixi.core.display.Container"/></f></getAnim>
		<create public="1" set="method" line="23"><f a="pID">
	<c path="String"/>
	<c path="pixi.core.display.Container"/>
</f></create>
		<update public="1" set="method" line="27"><f a="pId">
	<c path="String"/>
	<x path="Void"/>
</f></update>
		<setFrame public="1" set="method" line="31"><f a="?pAutoPlay:?pStart">
	<x path="Bool"/>
	<x path="UInt"/>
	<x path="Void"/>
</f></setFrame>
		<new set="method" line="14"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* ...
 * @author Mathieu Anthoine</haxe_doc>
	</class>
	<class path="com.isartdigital.utils.game.factory.FlumpMovieAnimFactory" params="" file="src/com/isartdigital/utils/game/factory/FlumpMovieAnimFactory.hx">
		<extends path="com.isartdigital.utils.game.factory.AnimFactory"/>
		<getAnim public="1" set="method" line="20" override="1"><f a=""><c path="pixi.core.display.Container"/></f></getAnim>
		<create public="1" set="method" line="29" override="1"><f a="pID">
	<c path="String"/>
	<c path="pixi.core.display.Container"/>
</f></create>
		<setFrame public="1" set="method" line="34" override="1"><f a="?pAutoPlay:?pStart">
	<x path="Bool"/>
	<x path="UInt"/>
	<x path="Void"/>
</f></setFrame>
		<new public="1" set="method" line="15"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* ...
 * @author Mathieu Anthoine</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="com.isartdigital.utils.game.factory.FlumpSpriteAnimFactory" params="" file="src/com/isartdigital/utils/game/factory/FlumpSpriteAnimFactory.hx">
		<extends path="com.isartdigital.utils.game.factory.AnimFactory"/>
		<getAnim public="1" set="method" line="20" override="1"><f a=""><c path="pixi.core.display.Container"/></f></getAnim>
		<create public="1" set="method" line="29" override="1"><f a="pID">
	<c path="String"/>
	<c path="pixi.core.display.Container"/>
</f></create>
		<setFrame public="1" set="method" line="34" override="1"><f a="?pAutoPlay:?pStart">
	<x path="Bool"/>
	<x path="UInt"/>
	<x path="Void"/>
</f></setFrame>
		<new public="1" set="method" line="15"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* ...
 * @author Mathieu Anthoine</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="com.isartdigital.utils.game.factory.MovieClipAnimFactory" params="" file="src/com/isartdigital/utils/game/factory/MovieClipAnimFactory.hx">
		<extends path="com.isartdigital.utils.game.factory.AnimFactory"/>
		<textureDigits public="1" set="accessor" line="17" static="1">
			<x path="UInt"/>
			<haxe_doc>* longueur de la numérotation des textures</haxe_doc>
		</textureDigits>
		<set_textureDigits set="method" line="19" static="1"><f a="pDigits">
	<x path="UInt"/>
	<x path="UInt"/>
</f></set_textureDigits>
		<texturesDefinition static="1">
			<x path="Map">
				<c path="String"/>
				<x path="Int"/>
			</x>
			<haxe_doc>* définition des textures (nombre d'images)</haxe_doc>
		</texturesDefinition>
		<texturesCache static="1">
			<x path="Map">
				<c path="String"/>
				<c path="Array"><c path="pixi.core.textures.Texture"/></c>
			</x>
			<haxe_doc>* cache des textures de tous les StateGraphic</haxe_doc>
		</texturesCache>
		<digits static="1">
			<c path="String"/>
			<haxe_doc>* nombre de zéro a ajouter pour construire un nom de frame</haxe_doc>
		</digits>
		<addTextures public="1" set="method" line="44" static="1">
			<f a="pJson">
				<c path="haxe.Json"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Analyse et crée les définitions de textures
	 * @param	pJson objet contenant la description des assets</haxe_doc>
		</addTextures>
		<clearTextures public="1" set="method" line="72" static="1">
			<f a="pJson">
				<c path="haxe.Json"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Vide le cache de textures correspondant à la description passée en paramètres
	 * @param	pJson objet contenant la description des assets</haxe_doc>
		</clearTextures>
		<create public="1" set="method" line="99" override="1"><f a="pID">
	<c path="String"/>
	<c path="pixi.core.display.Container"/>
</f></create>
		<update public="1" set="method" line="104" override="1"><f a="pID">
	<c path="String"/>
	<x path="Void"/>
</f></update>
		<setFrame public="1" set="method" line="108" override="1"><f a="?pAutoPlay:?pStart">
	<x path="Bool"/>
	<x path="UInt"/>
	<x path="Void"/>
</f></setFrame>
		<getTextures set="method" line="121">
			<f a="pID">
				<c path="String"/>
				<c path="Array"><c path="pixi.core.textures.Texture"/></c>
			</f>
			<haxe_doc>* Cherche dans le cache général de textures le tableau de textures correspondant au state et le retourne.
	 * Si le tableau de texture n'éxiste pas, il le crée et le stocke dans le cache
	 * @param	pID ID complet de l'anim
	 * @return	le tableau de texture correspondant au state de l'instance</haxe_doc>
		</getTextures>
		<new public="1" set="method" line="93"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* ...
 * @author Mathieu Anthoine</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="com.isartdigital.utils.game.iso.IsoManager" params="" file="src/com/isartdigital/utils/game/iso/IsoManager.hx">
		<halfWidth static="1"><x path="Float"/></halfWidth>
		<halfHeight static="1"><x path="Float"/></halfHeight>
		<init public="1" set="method" line="20" static="1">
			<f a="pTileWidth:pTileHeight">
				<x path="UInt"/>
				<x path="UInt"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Initialisation du Manager Iso
	 * @param	pTileWidth largeur des tuiles
	 * @param	pTileHeight hauteur des tuiles</haxe_doc>
		</init>
		<modelToIsoView public="1" set="method" line="30" static="1">
			<f a="pPoint">
				<c path="pixi.core.math.Point"/>
				<c path="pixi.core.math.Point"/>
			</f>
			<haxe_doc>* Conversion du modèle à la vue Isométrique
	 * @param	pPoint colonne et ligne dans le modèle
	 * @return point en x, y dans la vue</haxe_doc>
		</modelToIsoView>
		<isoViewToModel public="1" set="method" line="42" static="1">
			<f a="pPoint">
				<c path="pixi.core.math.Point"/>
				<c path="pixi.core.math.Point"/>
			</f>
			<haxe_doc>* Conversion de la vue Isométrique au modèle
	 * @param	pPoint coordonnées dans la vue
	 * @return colonne et ligne dans le modèle (valeurs non arrondies)</haxe_doc>
		</isoViewToModel>
		<isInFrontOf public="1" set="method" line="55" static="1">
			<f a="pA:pB">
				<c path="com.isartdigital.utils.game.iso.IZSortable"/>
				<c path="com.isartdigital.utils.game.iso.IZSortable"/>
				<c path="com.isartdigital.utils.game.iso.IZSortable"/>
			</f>
			<haxe_doc>* détermine si l'objet A est devant l'objet B
     * @param    pA Objet "Zsortable" A
     * @param    pB Objet "Zsortable" B
     * @return pA, pB ou null si les objets ne se superposent pas</haxe_doc>
		</isInFrontOf>
		<getDepth public="1" set="method" line="85" static="1">
			<f a="pItem:pList">
				<c path="com.isartdigital.utils.game.iso.IZSortable"/>
				<c path="Array"><c path="com.isartdigital.utils.game.iso.IZSortable"/></c>
				<x path="UInt"/>
			</f>
			<haxe_doc>* Détermine la profondeur de l'objet 
	 * @param	pItem Objet "Zsortable"
	 * @param	pList tableau des objets "Zsortable" à l'écran
	 * @return	profondeur</haxe_doc>
		</getDepth>
		<getMousePositionIndex public="1" set="method" line="97" static="1">
			<f a=""><c path="pixi.core.math.Point"/></f>
			<haxe_doc>* Récupère l'index de la position de la souris dans la grille
	 * @return</haxe_doc>
		</getMousePositionIndex>
		<sortAll public="1" set="method" line="107" static="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Tri tous les objet du jeu</haxe_doc>
		</sortAll>
		<haxe_doc>* Manager Iso
 * @author Mathieu Anthoine</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="pixi.loaders.ResourceLoader" params="" file="C:\HaxeToolkit\haxe\lib\pixijs/3,0,25/pixi/loaders/ResourceLoader.hx" extern="1">
		<extends path="pixi.interaction.EventEmitter"/>
		<baseUrl public="1">
			<c path="String"/>
			<haxe_doc>* The base url for all resources loaded by this loader.
     *
     * @member {String}</haxe_doc>
		</baseUrl>
		<progress public="1">
			<x path="Float"/>
			<haxe_doc>* The progress percent of the loader going through the queue.
     *
     * @member {Float}</haxe_doc>
		</progress>
		<loading public="1">
			<x path="Bool"/>
			<haxe_doc>* Loading state of the loader, true if it is currently loading resources.
     *
     * @member {Bool}</haxe_doc>
		</loading>
		<resources public="1">
			<d/>
			<haxe_doc><![CDATA[* All the resources for this loader keyed by name.
     *
     * @member {object<string, Resource>}]]></haxe_doc>
		</resources>
		<add public="1" set="method">
			<f a="name:url:?options:?callback">
				<c path="String"/>
				<c path="String"/>
				<t path="pixi.loaders.LoaderOptions"/>
				<f a="">
					<c path="pixi.loaders.Resource"/>
					<x path="Void"/>
				</f>
				<c path="pixi.loaders.ResourceLoader"/>
			</f>
			<haxe_doc>* Adds a resource (or multiple resources) to the loader queue.
	 *
	 * This function can take a wide variety of different parameters. The only thing that is always
	 * required the url to load. All the following will work:
	 *
	 * ```js
	 * loader
	 *     // normal param syntax
	 *     .add('key', 'http://...', 	function () {})
	 *     .add('http://...', 	function () {})
	 *     .add('http://...')
	 *
	 *     // object syntax
	 *     .add({
	 *         name: 'key2',
	 *         url: 'http://...'
	 *     }, 	function () {})
	 *     .add({
	 *         url: 'http://...'
	 *     }, function () {})
	 *     .add({
	 *         name: 'key3',
	 *         url: 'http://...'
	 *         onComplete: function () {}
	 *     })
	 *     .add({
	 *         url: 'https://...',
	 *         onComplete: function () {},
	 *         crossOrigin: true
	 *     })
	 *
	 *     // you can also pass an array of objects or urls or both
	 *     .add([
	 *         { name: 'key4', url: 'http://...', onComplete: function () {} },
	 *         { url: 'http://...', onComplete: function () {} },
	 *         'http://...'
	 *     ]);
	 * ```
	 *
	 * @alias enqueue
	 * @param [name] {string} The name of the resource to load, if not passed the url is used.
	 * @param url {string} The url for this resource, relative to the baseUrl of this loader.
	 * @param [options] {object} The options for the load.
	 * @param [options.crossOrigin] {boolean} Is this request cross-origin? Default is to determine automatically.
	 * @param [options.loadType=Resource.LOAD_TYPE.XHR] {Resource.XHR_LOAD_TYPE} How should this resource be loaded?
	 * @param [options.xhrType=Resource.XHR_RESPONSE_TYPE.DEFAULT] {Resource.XHR_RESPONSE_TYPE} How should the data being
	 *      loaded be interpreted when using XHR?
	 * @param [callback] {function} function to call when this specific resource completes loading.
	 * @return {Loader}</haxe_doc>
			<overloads>
				<add public="1" set="method">
					<f a="obj">
						<t path="pixi.loaders.ResourceObject"/>
						<c path="pixi.loaders.ResourceLoader"/>
					</f>
					<haxe_doc>* Adds a resource (or multiple resources) to the loader queue.
	 *
	 * This function can take a wide variety of different parameters. The only thing that is always
	 * required the url to load. All the following will work:
	 *
	 * ```js
	 * loader
	 *     // normal param syntax
	 *     .add('key', 'http://...', 	function () {})
	 *     .add('http://...', 	function () {})
	 *     .add('http://...')
	 *
	 *     // object syntax
	 *     .add({
	 *         name: 'key2',
	 *         url: 'http://...'
	 *     }, 	function () {})
	 *     .add({
	 *         url: 'http://...'
	 *     }, function () {})
	 *     .add({
	 *         name: 'key3',
	 *         url: 'http://...'
	 *         onComplete: function () {}
	 *     })
	 *     .add({
	 *         url: 'https://...',
	 *         onComplete: function () {},
	 *         crossOrigin: true
	 *     })
	 *
	 *     // you can also pass an array of objects or urls or both
	 *     .add([
	 *         { name: 'key4', url: 'http://...', onComplete: function () {} },
	 *         { url: 'http://...', onComplete: function () {} },
	 *         'http://...'
	 *     ]);
	 * ```
	 *
	 * @alias enqueue
	 * @param [name] {string} The name of the resource to load, if not passed the url is used.
	 * @param url {string} The url for this resource, relative to the baseUrl of this loader.
	 * @param [options] {object} The options for the load.
	 * @param [options.crossOrigin] {boolean} Is this request cross-origin? Default is to determine automatically.
	 * @param [options.loadType=Resource.LOAD_TYPE.XHR] {Resource.XHR_LOAD_TYPE} How should this resource be loaded?
	 * @param [options.xhrType=Resource.XHR_RESPONSE_TYPE.DEFAULT] {Resource.XHR_RESPONSE_TYPE} How should the data being
	 *      loaded be interpreted when using XHR?
	 * @param [callback] {function} function to call when this specific resource completes loading.
	 * @return {Loader}</haxe_doc>
				</add>
				<add public="1" set="method">
					<f a="urls">
						<c path="Array"><t path="pixi.loaders.ResourceObject"/></c>
						<c path="pixi.loaders.ResourceLoader"/>
					</f>
					<haxe_doc>* Adds a resource (or multiple resources) to the loader queue.
	 *
	 * This function can take a wide variety of different parameters. The only thing that is always
	 * required the url to load. All the following will work:
	 *
	 * ```js
	 * loader
	 *     // normal param syntax
	 *     .add('key', 'http://...', 	function () {})
	 *     .add('http://...', 	function () {})
	 *     .add('http://...')
	 *
	 *     // object syntax
	 *     .add({
	 *         name: 'key2',
	 *         url: 'http://...'
	 *     }, 	function () {})
	 *     .add({
	 *         url: 'http://...'
	 *     }, function () {})
	 *     .add({
	 *         name: 'key3',
	 *         url: 'http://...'
	 *         onComplete: function () {}
	 *     })
	 *     .add({
	 *         url: 'https://...',
	 *         onComplete: function () {},
	 *         crossOrigin: true
	 *     })
	 *
	 *     // you can also pass an array of objects or urls or both
	 *     .add([
	 *         { name: 'key4', url: 'http://...', onComplete: function () {} },
	 *         { url: 'http://...', onComplete: function () {} },
	 *         'http://...'
	 *     ]);
	 * ```
	 *
	 * @alias enqueue
	 * @param [name] {string} The name of the resource to load, if not passed the url is used.
	 * @param url {string} The url for this resource, relative to the baseUrl of this loader.
	 * @param [options] {object} The options for the load.
	 * @param [options.crossOrigin] {boolean} Is this request cross-origin? Default is to determine automatically.
	 * @param [options.loadType=Resource.LOAD_TYPE.XHR] {Resource.XHR_LOAD_TYPE} How should this resource be loaded?
	 * @param [options.xhrType=Resource.XHR_RESPONSE_TYPE.DEFAULT] {Resource.XHR_RESPONSE_TYPE} How should the data being
	 *      loaded be interpreted when using XHR?
	 * @param [callback] {function} function to call when this specific resource completes loading.
	 * @return {Loader}</haxe_doc>
				</add>
				<add public="1" set="method">
					<f a="urls">
						<c path="Array"><c path="String"/></c>
						<c path="pixi.loaders.ResourceLoader"/>
					</f>
					<haxe_doc>* Adds a resource (or multiple resources) to the loader queue.
	 *
	 * This function can take a wide variety of different parameters. The only thing that is always
	 * required the url to load. All the following will work:
	 *
	 * ```js
	 * loader
	 *     // normal param syntax
	 *     .add('key', 'http://...', 	function () {})
	 *     .add('http://...', 	function () {})
	 *     .add('http://...')
	 *
	 *     // object syntax
	 *     .add({
	 *         name: 'key2',
	 *         url: 'http://...'
	 *     }, 	function () {})
	 *     .add({
	 *         url: 'http://...'
	 *     }, function () {})
	 *     .add({
	 *         name: 'key3',
	 *         url: 'http://...'
	 *         onComplete: function () {}
	 *     })
	 *     .add({
	 *         url: 'https://...',
	 *         onComplete: function () {},
	 *         crossOrigin: true
	 *     })
	 *
	 *     // you can also pass an array of objects or urls or both
	 *     .add([
	 *         { name: 'key4', url: 'http://...', onComplete: function () {} },
	 *         { url: 'http://...', onComplete: function () {} },
	 *         'http://...'
	 *     ]);
	 * ```
	 *
	 * @alias enqueue
	 * @param [name] {string} The name of the resource to load, if not passed the url is used.
	 * @param url {string} The url for this resource, relative to the baseUrl of this loader.
	 * @param [options] {object} The options for the load.
	 * @param [options.crossOrigin] {boolean} Is this request cross-origin? Default is to determine automatically.
	 * @param [options.loadType=Resource.LOAD_TYPE.XHR] {Resource.XHR_LOAD_TYPE} How should this resource be loaded?
	 * @param [options.xhrType=Resource.XHR_RESPONSE_TYPE.DEFAULT] {Resource.XHR_RESPONSE_TYPE} How should the data being
	 *      loaded be interpreted when using XHR?
	 * @param [callback] {function} function to call when this specific resource completes loading.
	 * @return {Loader}</haxe_doc>
				</add>
				<add public="1" set="method">
					<f a="url:?options:?callback">
						<c path="String"/>
						<t path="pixi.loaders.LoaderOptions"/>
						<f a="">
							<c path="pixi.loaders.Resource"/>
							<x path="Void"/>
						</f>
						<c path="pixi.loaders.ResourceLoader"/>
					</f>
					<haxe_doc>* Adds a resource (or multiple resources) to the loader queue.
	 *
	 * This function can take a wide variety of different parameters. The only thing that is always
	 * required the url to load. All the following will work:
	 *
	 * ```js
	 * loader
	 *     // normal param syntax
	 *     .add('key', 'http://...', 	function () {})
	 *     .add('http://...', 	function () {})
	 *     .add('http://...')
	 *
	 *     // object syntax
	 *     .add({
	 *         name: 'key2',
	 *         url: 'http://...'
	 *     }, 	function () {})
	 *     .add({
	 *         url: 'http://...'
	 *     }, function () {})
	 *     .add({
	 *         name: 'key3',
	 *         url: 'http://...'
	 *         onComplete: function () {}
	 *     })
	 *     .add({
	 *         url: 'https://...',
	 *         onComplete: function () {},
	 *         crossOrigin: true
	 *     })
	 *
	 *     // you can also pass an array of objects or urls or both
	 *     .add([
	 *         { name: 'key4', url: 'http://...', onComplete: function () {} },
	 *         { url: 'http://...', onComplete: function () {} },
	 *         'http://...'
	 *     ]);
	 * ```
	 *
	 * @alias enqueue
	 * @param [name] {string} The name of the resource to load, if not passed the url is used.
	 * @param url {string} The url for this resource, relative to the baseUrl of this loader.
	 * @param [options] {object} The options for the load.
	 * @param [options.crossOrigin] {boolean} Is this request cross-origin? Default is to determine automatically.
	 * @param [options.loadType=Resource.LOAD_TYPE.XHR] {Resource.XHR_LOAD_TYPE} How should this resource be loaded?
	 * @param [options.xhrType=Resource.XHR_RESPONSE_TYPE.DEFAULT] {Resource.XHR_RESPONSE_TYPE} How should the data being
	 *      loaded be interpreted when using XHR?
	 * @param [callback] {function} function to call when this specific resource completes loading.
	 * @return {Loader}</haxe_doc>
				</add>
			</overloads>
		</add>
		<after public="1" set="method">
			<f a="fn">
				<f a=":">
					<c path="pixi.loaders.Resource"/>
					<d/>
					<x path="Void"/>
				</f>
				<c path="pixi.loaders.ResourceLoader"/>
			</f>
			<haxe_doc>* Sets up a middleware function that will run *after* the
	 * resource is loaded.
	 *
	 * @alias use
	 * @param middleware {function} The middleware function to register.
	 * @return {Loader}</haxe_doc>
		</after>
		<before public="1" set="method">
			<f a="fn">
				<f a=":">
					<c path="pixi.loaders.Resource"/>
					<d/>
					<x path="Void"/>
				</f>
				<c path="pixi.loaders.ResourceLoader"/>
			</f>
			<haxe_doc>* Sets up a middleware function that will run *before* the
	 * resource is loaded.
	 *
	 * @alias pre
	 * @param middleware {function} The middleware function to register.
	 * @return {Loader}</haxe_doc>
		</before>
		<reset public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Resets the queue of the loader to prepare for a new load.</haxe_doc>
		</reset>
		<load public="1" set="method">
			<f a="?cb">
				<f a=""><x path="Void"/></f>
				<c path="pixi.loaders.ResourceLoader"/>
			</f>
			<haxe_doc>* Starts loading the queued resources.
	 *
	 * @fires start
	 * @param [callback] {function} Optional callback that will be bound to the `complete` event.
	 * @return {Loader}</haxe_doc>
		</load>
		<loadResource public="1" set="method">
			<f a="resource:?cb">
				<c path="String"/>
				<f a=""><x path="Void"/></f>
				<c path="pixi.loaders.ResourceLoader"/>
			</f>
			<haxe_doc>* Loads a single resource.
	 *
	 * @fires progress</haxe_doc>
		</loadResource>
		<use public="1" set="method">
			<f a="fn">
				<f a=":">
					<c path="pixi.loaders.Resource"/>
					<d/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc>* Middleware function to use
	 *
	 * @param {function} function to call</haxe_doc>
		</use>
		<pre public="1" set="method">
			<f a="fn">
				<f a=":">
					<c path="pixi.loaders.Resource"/>
					<d/>
					<x path="Void"/>
				</f>
				<c path="pixi.loaders.ResourceLoader"/>
			</f>
			<haxe_doc>* Middleware function
	 *
	 * @param {function} function to call</haxe_doc>
		</pre>
		<new public="1" set="method">
			<f a="?baseUrl:?concurrency">
				<c path="String"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Manages the state and loading of multiple resources to load.
	 *
	 * @class
	 * @param [baseUrl=''] {string} The base url for all resources loaded by this loader.
	 * @param [concurrency=10] {number} The number of resources to load concurrently.</haxe_doc>
		</new>
	</class>
	<class path="pixi.loaders.Loader" params="" file="C:\HaxeToolkit\haxe\lib\pixijs/3,0,25/pixi/loaders/Loader.hx" extern="1">
		<extends path="pixi.loaders.ResourceLoader"/>
		<new public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>*
	 * The new loader, extends Resource Loader by Chad Engler : https://github.com/englercj/resource-loader
	 *
	 * ```js
	 * 	var loader = new PIXI.loader();
	 *
	 * loader.add('spineboy',"data/spineboy.json");
	 *
	 * loader.once('complete',onAssetsLoaded);
	 *
	 * loader.load();
	 * ```
	 *
	 * @class
	 * @extends ResourceLoader
	 * @memberof PIXI.loaders</haxe_doc>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":native"><e>"PIXI.loaders.Loader"</e></m>
		</meta>
	</class>
	<class path="com.isartdigital.utils.loader.GameLoader" params="" file="src/com/isartdigital/utils/loader/GameLoader.hx">
		<extends path="pixi.loaders.Loader"/>
		<txtLoaded line="33" static="1">
			<x path="Map">
				<c path="String"/>
				<d/>
			</x>
			<haxe_doc>* liste des fichiers chargés</haxe_doc>
		</txtLoaded>
		<getContent public="1" set="method" line="40" static="1">
			<f a="pFile">
				<c path="String"/>
				<c path="haxe.Json"/>
			</f>
			<haxe_doc>* retourne le contenu chargé pour le chemin de fichier passé en paramètre
	* @param	pFile chemin du fichier
	* @return	fichier Json</haxe_doc>
		</getContent>
		<soundsList>
			<c path="Array"><c path="String"/></c>
			<haxe_doc>* liste des fichiers sons à charger</haxe_doc>
		</soundsList>
		<soundsSpecs><x path="Map">
	<c path="String"/>
	<t path="howler.HowlOptions"/>
</x></soundsSpecs>
		<addTxtFile public="1" set="method" line="55">
			<f a="pUrl">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* ajoute un fichier de type texte à la liste de chargement (actuellement seuls les JSon sont supportés)
	* @param	pUrl chaine de caractères spécifiant le chemin vers le fichier</haxe_doc>
		</addTxtFile>
		<addAssetFile public="1" set="method" line="64">
			<f a="pUrl">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* ajoute un fichier d'assets à la liste de chargement
	* @param	pUrl chaine de caractère spécifiant le nom du fichier</haxe_doc>
		</addAssetFile>
		<addSoundFile public="1" set="method" line="73">
			<f a="pUrl">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* ajoute une liste de sons à la liste de chargement
	* @param	pUrl chaine de caractère spécifiant le nom du fichier</haxe_doc>
		</addSoundFile>
		<addFontFile public="1" set="method" line="83">
			<f a="pUrl">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* ajoute un fichier css de polices de caractère
	* @param	pUrl chaine de caractère spécifiant le nom du fichier</haxe_doc>
		</addFontFile>
		<parseData set="method" line="88"><f a="pResource:pNext">
	<c path="pixi.loaders.Resource"/>
	<f a=""><x path="Void"/></f>
	<x path="Void"/>
</f></parseData>
		<addSounds set="method" line="151"><f a="pList:pLoop:pExtensions:pCodec">
	<d/>
	<x path="Bool"/>
	<c path="Array"><c path="String"/></c>
	<c path="String"/>
	<x path="Void"/>
</f></addSounds>
		<load public="1" set="method" line="160" override="1"><f a="?cb">
	<f a=""><x path="Void"/></f>
	<c path="pixi.loaders.ResourceLoader"/>
</f></load>
		<onComplete set="method" line="166"><f a=""><x path="Void"/></f></onComplete>
		<new public="1" set="method" line="44"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* Classe de chargement
 * Cette classe permet de gérer des chargements par lot aussi bien de fichiers textes que de ressources graphiques ou du son
 * @author Mathieu ANTHOINE
 * @version 0.2.0</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="com.isartdigital.utils.sounds.SoundDef" params="" file="src/com/isartdigital/utils/sounds/SoundDef.hx">
		<a>
			<musics><d><x path="UInt"/></d></musics>
			<fxs><d><x path="UInt"/></d></fxs>
			<extensions><c path="Array"><c path="String"/></c></extensions>
		</a>
		<haxe_doc>* @author Mathieu Anthoine</haxe_doc>
	</typedef>
	<class path="com.isartdigital.utils.sounds.SoundManager" params="" file="src/com/isartdigital/utils/sounds/SoundManager.hx">
		<list set="null" static="1">
			<x path="Map">
				<c path="String"/>
				<c path="howler.Howl"/>
			</x>
			<haxe_doc>* liste de tous les sons du jeu</haxe_doc>
		</list>
		<addSound public="1" set="method" line="25" static="1">
			<f a="pName:pSound">
				<c path="String"/>
				<c path="howler.Howl"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* ajoute un son à la liste
	 * @param	pName identifiant du son
	 * @param	pSound son</haxe_doc>
		</addSound>
		<getSound public="1" set="method" line="35" static="1">
			<f a="pName">
				<c path="String"/>
				<c path="howler.Howl"/>
			</f>
			<haxe_doc>* retourne une référence vers le son par l'intermédiaire de son identifiant
	 * @param	pName identifiant du son
	 * @return le son</haxe_doc>
		</getSound>
		<new set="method" line="17"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* Manager centralisé de Sons Howler
 * @author Mathieu ANTHOINE</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="com.isartdigital.utils.system.DeviceCapabilities" params="" file="src/com/isartdigital/utils/system/DeviceCapabilities.hx">
		<SYSTEM_ANDROID public="1" get="inline" set="null" line="22" static="1"><c path="String"/></SYSTEM_ANDROID>
		<SYSTEM_IOS public="1" get="inline" set="null" line="23" static="1"><c path="String"/></SYSTEM_IOS>
		<SYSTEM_BLACKBERRY public="1" get="inline" set="null" line="24" static="1"><c path="String"/></SYSTEM_BLACKBERRY>
		<SYSTEM_BB_PLAYBOOK public="1" get="inline" set="null" line="25" static="1"><c path="String"/></SYSTEM_BB_PLAYBOOK>
		<SYSTEM_WINDOWS_MOBILE public="1" get="inline" set="null" line="26" static="1"><c path="String"/></SYSTEM_WINDOWS_MOBILE>
		<SYSTEM_DESKTOP public="1" get="inline" set="null" line="27" static="1"><c path="String"/></SYSTEM_DESKTOP>
		<fullScreenButton static="1"><c path="js.html.Image"/></fullScreenButton>
		<ICON_SIZE get="inline" set="null" line="30" static="1"><x path="Float"/></ICON_SIZE>
		<TEXTURE_NO_SCALE public="1" get="inline" set="null" line="32" static="1"><c path="String"/></TEXTURE_NO_SCALE>
		<TEXTURE_HD public="1" get="inline" set="null" line="33" static="1"><c path="String"/></TEXTURE_HD>
		<TEXTURE_MD public="1" get="inline" set="null" line="34" static="1"><c path="String"/></TEXTURE_MD>
		<TEXTURE_LD public="1" get="inline" set="null" line="35" static="1"><c path="String"/></TEXTURE_LD>
		<texturesRatios line="37" static="1"><x path="Map">
	<c path="String"/>
	<x path="Float"/>
</x></texturesRatios>
		<textureRatio public="1" set="null" line="39" static="1"><x path="Float"/></textureRatio>
		<textureType public="1" set="null" line="40" static="1"><c path="String"/></textureType>
		<screenRatio line="42" static="1"><x path="Float"/></screenRatio>
		<height public="1" get="accessor" set="null" static="1">
			<x path="UInt"/>
			<haxe_doc>* hauteur du Canvas (change avec l'orientation)</haxe_doc>
		</height>
		<get_height set="method" line="49" static="1"><f a=""><x path="Int"/></f></get_height>
		<width public="1" get="accessor" set="null" static="1">
			<x path="UInt"/>
			<haxe_doc>* largeur du Canvas (change avec l'orientation)</haxe_doc>
		</width>
		<get_width set="method" line="58" static="1"><f a=""><x path="Int"/></f></get_width>
		<system public="1" get="accessor" set="null" static="1">
			<c path="String"/>
			<haxe_doc>* Système d'exploitation du Device</haxe_doc>
		</system>
		<get_system set="method" line="67" static="1"><f a=""><c path="String"/></f></get_system>
		<displayFullScreenButton public="1" set="method" line="79" static="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>* affiche le bouton de fullscreen</haxe_doc>
		</displayFullScreenButton>
		<enterFullscreen set="method" line="107" static="1">
			<f a="pEvent">
				<c path="js.html.Event"/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>* entre dans le mode fullscreen
	 * @param	pEvent</haxe_doc>
		</enterFullscreen>
		<exitFullscreen set="method" line="119" static="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>* sort du mode fullscreen</haxe_doc>
		</exitFullscreen>
		<onChangeFullScreen set="method" line="130" static="1">
			<f a="pEvent">
				<c path="js.html.Event"/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>* callback appelée sur changement d'état fullscreen
	 * @param	pEvent</haxe_doc>
		</onChangeFullScreen>
		<getSizeFactor public="1" set="method" line="144" static="1">
			<f a=""><x path="Float"/></f>
			<haxe_doc>* Calcul la dimension idéale du bouton en fonction du device
	 * @return fullscreen ideal size</haxe_doc>
		</getSizeFactor>
		<getScreenRect public="1" set="method" line="156" static="1">
			<f a="pTarget">
				<c path="pixi.core.display.DisplayObject"/>
				<c path="pixi.core.math.shapes.Rectangle"/>
			</f>
			<haxe_doc>* retourne un objet Rectangle correspondant aux dimensions de l'écran dans le repère du DisplayObject passé en paramètre
	 * @param pTarget repère cible
	 * @return objet Rectangle</haxe_doc>
		</getScreenRect>
		<scaleViewport public="1" set="method" line="170" static="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Calibre le viewport pour que le Browser affiche la résolution réeelle du Device</haxe_doc>
		</scaleViewport>
		<init public="1" set="method" line="184" static="1">
			<f a="?pHd:?pMd:?pLd">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Défini les ratios de texture
	 * @param	pHd ratio texture pour HD
	 * @param	pMd ratio texture pour MD
	 * @param	pLd ratio texture pour LD</haxe_doc>
		</init>
		<haxe_doc>* Classe Utilitaire donnant accès à des propriétés du périphérique cible
 * Tous les périphériques ne se comportant pas comme on l'attend, DeviceCapabilities permet de
 * masquer les comportement différents et présenter une facade unique au reste du code
 * @version 0.3.0
 * @author Mathieu ANTHOINE</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="com.isartdigital.utils.ui.UIAsset" params="" file="src/com/isartdigital/utils/ui/UIAsset.hx">
		<extends path="com.isartdigital.utils.game.StateGraphic"/>
		<new public="1" set="method" line="13"><f a="pAssetName">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* ...
 * @author Mathieu Anthoine</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="com.isartdigital.utils.ui.UIBuilder" params="" file="src/com/isartdigital/utils/ui/UIBuilder.hx">
		<description static="1">
			<c path="String"/>
			<haxe_doc>* fichier de description des assuets d'UI au format Flump</haxe_doc>
		</description>
		<TXT_SUFFIX get="inline" set="null" line="29" static="1">
			<c path="String"/>
			<haxe_doc>* suffixe des FlumpSprite "texte"</haxe_doc>
		</TXT_SUFFIX>
		<BTN_SUFFIX get="inline" set="null" line="34" static="1">
			<c path="String"/>
			<haxe_doc>* suffixe des FlumpButton</haxe_doc>
		</BTN_SUFFIX>
		<CURRENCY_SUFFIX get="inline" set="null" line="39" static="1">
			<c path="String"/>
			<haxe_doc>* suffixe des Currencys</haxe_doc>
		</CURRENCY_SUFFIX>
		<BUILDING_HUD_SUFFIX get="inline" set="null" line="44" static="1">
			<c path="String"/>
			<haxe_doc>* suffixe des buildingHUD</haxe_doc>
		</BUILDING_HUD_SUFFIX>
		<btnPackage static="1">
			<c path="String"/>
			<haxe_doc>* package des classes Button du projet</haxe_doc>
		</btnPackage>
		<hudPackage static="1"><c path="String"/></hudPackage>
		<textStyle line="52" static="1"><x path="Map">
	<c path="String"/>
	<t path="com.isartdigital.utils.ui.UITextStyle"/>
</x></textStyle>
		<uiPos line="58" static="1">
			<x path="Map">
				<c path="String"/>
				<c path="String"/>
			</x>
			<haxe_doc>* wrapper vers UIPosition</haxe_doc>
		</uiPos>
		<addTextStyle public="1" set="method" line="74" static="1"><f a="pData">
	<c path="String"/>
	<x path="Void"/>
</f></addTextStyle>
		<init public="1" set="method" line="87" static="1">
			<f a="pFile:pPackage:pPackageCurrency">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Initialise le parseur
	 * @param	pFile nom du fichier qui contient les données de mise en forme de l'UI
	 * @param	pPackage nom du package des boutons</haxe_doc>
		</init>
		<build public="1" set="method" line="97" static="1">
			<f a="pId">
				<c path="String"/>
				<c path="Array"><t path="com.isartdigital.utils.ui.UIPositionable"/></c>
			</f>
			<haxe_doc>* Crée les éléments composant un Screen
	 * @param	pId assetName de l'écran</haxe_doc>
		</build>
		<getTextFromJson set="method" line="141" static="1"><f a="pName">
	<c path="String"/>
	<c path="pixi.core.text.Text"/>
</f></getTextFromJson>
		<getUIPositionable set="method" line="159" static="1">
			<f a="pObj:pPosition">
				<c path="pixi.core.display.Container"/>
				<c path="String"/>
				<t path="com.isartdigital.utils.ui.UIPositionable"/>
			</f>
			<haxe_doc>* retourne un UIPositionable correctement construit
	 * @param	pObj Item d'interface
	 * @param	pPosition ancrage "UIPosition"
	 * @return un UIPositionable</haxe_doc>
		</getUIPositionable>
		<new set="method" line="72"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* ...
 * @author Mathieu Anthoine</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="com.isartdigital.utils.ui.UIPosition" params="" file="src/com/isartdigital/utils/ui/UIPosition.hx">
		<LEFT public="1" get="inline" set="null" line="14" static="1"><c path="String"/></LEFT>
		<RIGHT public="1" get="inline" set="null" line="15" static="1"><c path="String"/></RIGHT>
		<TOP public="1" get="inline" set="null" line="16" static="1"><c path="String"/></TOP>
		<BOTTOM public="1" get="inline" set="null" line="17" static="1"><c path="String"/></BOTTOM>
		<TOP_LEFT public="1" get="inline" set="null" line="18" static="1"><c path="String"/></TOP_LEFT>
		<TOP_RIGHT public="1" get="inline" set="null" line="19" static="1"><c path="String"/></TOP_RIGHT>
		<BOTTOM_LEFT public="1" get="inline" set="null" line="20" static="1"><c path="String"/></BOTTOM_LEFT>
		<BOTTOM_RIGHT public="1" get="inline" set="null" line="21" static="1"><c path="String"/></BOTTOM_RIGHT>
		<FIT_WIDTH public="1" get="inline" set="null" line="23" static="1"><c path="String"/></FIT_WIDTH>
		<FIT_HEIGHT public="1" get="inline" set="null" line="24" static="1"><c path="String"/></FIT_HEIGHT>
		<FIT_SCREEN public="1" get="inline" set="null" line="25" static="1"><c path="String"/></FIT_SCREEN>
		<setPosition public="1" set="method" line="36" static="1">
			<f a="pTarget:pPosition:?pOffsetX:?pOffsetY">
				<c path="pixi.core.display.DisplayObject"/>
				<c path="String"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>* 
	* @param	pTarget DisplayObject à positionner
	* @param	pPosition type de positionnement
	* @param	pOffsetX décalage en X (positif si c'est vers l'interieur de la zone de jeu sinon en négatif)
	* @param	pOffsetY décalage en Y (positif si c'est vers l'interieur de la zone de jeu sinon en négatif)</haxe_doc>
		</setPosition>
		<new set="method" line="27"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* Classe utilitaire permettant de gérer le repositionnement des élements d'interface dans l'écran
 * @author Mathieu ANTHOINE</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="com.isartdigital.utils.ui.UIPositionable" params="" file="src/com/isartdigital/utils/ui/UIPositionable.hx">
		<a>
			<update>
				<t path="Null"><x path="Bool"/></t>
				<meta><m n=":optional"/></meta>
			</update>
			<offsetY><x path="Float"/></offsetY>
			<offsetX><x path="Float"/></offsetX>
			<item><c path="pixi.core.display.Container"/></item>
			<align><c path="String"/></align>
		</a>
		<haxe_doc>* @author Mathieu Anthoine</haxe_doc>
	</typedef>
	<typedef path="com.isartdigital.utils.ui.UITextStyle" params="" file="src/com/isartdigital/utils/ui/UITextStyle.hx">
		<a>
			<y><x path="Float"/></y>
			<x><x path="Float"/></x>
			<width><x path="Float"/></width>
			<text><c path="String"/></text>
			<size><x path="Float"/></size>
			<italic><x path="Bool"/></italic>
			<height><x path="Float"/></height>
			<font><c path="String"/></font>
			<color><x path="Int"/></color>
			<bold><x path="Bool"/></bold>
			<align><c path="String"/></align>
		</a>
		<haxe_doc>* @author Mathieu Anthoine
 * Informations concernant les Texts récupérés depuis le fichier textsUI.json</haxe_doc>
	</typedef>
	<class path="dat.controllers.Controller" params="" file="C:\HaxeToolkit\haxe\lib\dat,GUI/1,1,0/src/dat/controllers/Controller.hx" extern="1">
		<min public="1" set="method">
			<f a="value">
				<x path="Float"/>
				<c path="dat.controllers.Controller"/>
			</f>
			<haxe_doc>* 
	 * @param value minimum value
	 * @return the Controller instance</haxe_doc>
		</min>
		<max public="1" set="method">
			<f a="value">
				<x path="Float"/>
				<c path="dat.controllers.Controller"/>
			</f>
			<haxe_doc>* 
	 * @param value maximum value
	 * @return the Controller instance</haxe_doc>
		</max>
		<step public="1" set="method">
			<f a="value">
				<x path="Float"/>
				<c path="dat.controllers.Controller"/>
			</f>
			<haxe_doc>* 
	 * @param value increment amount
	 * @return the Controller instance</haxe_doc>
		</step>
		<onChange public="1" set="method">
			<f a="callBack">
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Fires on every change, drag, keypress, etc.
	 * @param {Dynamic} Function to execute</haxe_doc>
		</onChange>
		<onFinishChange public="1" set="method">
			<f a="callBack">
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Fires when a controller loses focus.
	 * @param {Dynamic} Function to execute</haxe_doc>
		</onFinishChange>
		<listen public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* listen to a Controller to react to changes made outside of the GUI</haxe_doc>
		</listen>
		<new public="1" set="method">
			<f a="object:property">
				<d/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* @class An "abstract" class that represents a given property of an object.
	 *
	 * @param {Dynamic} object The object to be manipulated
	 * @param {string} property The name of the property to be manipulated
	 *</haxe_doc>
		</new>
		<haxe_doc>* dat-gui JavaScript Controller Library
 * http://code.google.com/p/dat-gui
 *
 * Copyright 2011 Data Arts Team, Google Creative Lab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0</haxe_doc>
		<meta><m n=":native"><e>"dat.controllers.Controller"</e></m></meta>
	</class>
	<class path="dat.controllers.ColorController" params="" file="C:\HaxeToolkit\haxe\lib\dat,GUI/1,1,0/src/dat/controllers/ColorController.hx" extern="1">
		<extends path="dat.controllers.Controller"/>
		<haxe_doc>* dat-gui JavaScript Controller Library
 * http://code.google.com/p/dat-gui
 *
 * Copyright 2011 Data Arts Team, Google Creative Lab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0</haxe_doc>
		<meta><m n=":native"><e>"dat.controllers.ColorController"</e></m></meta>
	</class>
	<class path="dat.gui.GUI" params="" file="C:\HaxeToolkit\haxe\lib\dat,GUI/1,1,0/src/dat/gui/GUI.hx" extern="1">
		<toggleHide public="1" set="method" static="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* switch between visible and invisible mode</haxe_doc>
		</toggleHide>
		<add public="1" set="method">
			<f a="object:property">
				<d/>
				<c path="String"/>
				<c path="dat.controllers.Controller"/>
			</f>
			<haxe_doc>* Add a controller in this GUI
	 *
	 * @method add
	 * @param {Dynamic} object The object to be manipulated
	 * @param {string} property The name of the property to be manipulated
	 * @returns {Controller} The new controller that was added.</haxe_doc>
			<overloads>
				<add public="1" set="method">
					<f a="object:property:min:max">
						<d/>
						<c path="String"/>
						<x path="Float"/>
						<x path="Float"/>
						<c path="dat.controllers.Controller"/>
					</f>
					<haxe_doc>* Add a controller in this GUI
	 *
	 * @method add
	 * @param {Dynamic} object The object to be manipulated
	 * @param {string} property The name of the property to be manipulated
	 * @returns {Controller} The new controller that was added.</haxe_doc>
				</add>
				<add public="1" set="method">
					<f a="object:property:values">
						<d/>
						<c path="String"/>
						<c path="Array"><c path="String"/></c>
						<c path="dat.controllers.Controller"/>
					</f>
					<haxe_doc>* Add a controller in this GUI
	 *
	 * @method add
	 * @param {Dynamic} object The object to be manipulated
	 * @param {string} property The name of the property to be manipulated
	 * @returns {Controller} The new controller that was added.</haxe_doc>
				</add>
				<add public="1" set="method">
					<f a="object:property:values">
						<d/>
						<c path="String"/>
						<d/>
						<c path="dat.controllers.Controller"/>
					</f>
					<haxe_doc>* Add a controller in this GUI
	 *
	 * @method add
	 * @param {Dynamic} object The object to be manipulated
	 * @param {string} property The name of the property to be manipulated
	 * @returns {Controller} The new controller that was added.</haxe_doc>
				</add>
			</overloads>
		</add>
		<remove public="1" set="method">
			<f a="controller">
				<c path="dat.controllers.Controller"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Remove a controller in this GUI
	 * 
	 * @param controller</haxe_doc>
		</remove>
		<addFolder public="1" set="method">
			<f a="name">
				<c path="String"/>
				<c path="dat.gui.GUI"/>
			</f>
			<haxe_doc>* Add folder in this GUI
	 * 
	 * @param name
	 * @returns {GUI} The new folder.
	 * @throws {Error} if this GUI already has a folder by the specified name</haxe_doc>
		</addFolder>
		<addColor public="1" set="method">
			<f a="object:property">
				<d/>
				<c path="String"/>
				<c path="dat.controllers.ColorController"/>
			</f>
			<haxe_doc>* Set a colorpicker to a controller
	 * 
	 * @param object
	 * @param property
	 * @returns {ColorController} The new ColorController that was added.</haxe_doc>
		</addColor>
		<remember public="1" set="method">
			<f a="object">
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Mark objects for saving. The order of these objects cannot change as
	 * the GUI grows. When remembering new objects, append them to the end
	 * of the list.
	 *
	 * @param {Dynamic} object to remember
	 * @throws {Error} if not called on a top level GUI.e</haxe_doc>
		</remember>
		<open public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* open this GUI</haxe_doc>
		</open>
		<close public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* close this GUI</haxe_doc>
		</close>
		<destroy public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* destroy this GUI</haxe_doc>
		</destroy>
		<new public="1" set="method">
			<f a="?options">
				<t path="dat.gui.GUIOptions"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* A lightweight controller library for JavaScript. It allows you to easily
	 * manipulate variables and fire functions on the fly.
	 * @class GUI
	 * @param {GUIOptions} [options]
	 * @param {String} [options.name] The name of this GUI.
	 * @param {JSON} [options.load] JSON object representing the saved state of this GUI
	 * @param {String} [options.preset] name of the settings preset
	 * @param {Bool} [options.autoPlace=true] automatic position of this GUI 
	 * 
	 * @param {Bool} [options.auto] ???
	 * @param {parent} [params.parent] parent of this GUI
	 * @param {Boolean} [params.closed=false] GUI stars closed</haxe_doc>
		</new>
		<haxe_doc>* dat-gui JavaScript Controller Library
 * http://code.google.com/p/dat-gui
 *
 * Copyright 2011 Data Arts Team, Google Creative Lab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":native"><e>"dat.gui.GUI"</e></m>
		</meta>
	</class>
	<typedef path="dat.gui.GUIOptions" params="" file="C:\HaxeToolkit\haxe\lib\dat,GUI/1,1,0/src/dat/gui/GUI.hx" module="dat.gui.GUI"><a>
	<preset>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</preset>
	<load>
		<t path="Null"><c path="haxe.Json"/></t>
		<meta><m n=":optional"/></meta>
	</load>
	<autoPlace>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</autoPlace>
</a></typedef>
	<class path="flump.DisplayObjectKey" params="" file="C:\HaxeToolkit\haxe\lib\pixi-flump-runtime/0,1,1/src/flump/DisplayObjectKey.hx">
		<symbolId public="1"><c path="String"/></symbolId>
		<new public="1" set="method" line="11"><f a="symbolId">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flump.IFlumpMovie" params="" file="C:\HaxeToolkit\haxe\lib\pixi-flump-runtime/0,1,1/src/flump/IFlumpMovie.hx" interface="1">
		<createLayer set="method"><f a="layer">
	<c path="flump.library.Layer"/>
	<x path="Void"/>
</f></createLayer>
		<createFlumpChild set="method"><f a="displayKey">
	<c path="flump.DisplayObjectKey"/>
	<x path="Void"/>
</f></createFlumpChild>
		<removeFlumpChild set="method"><f a="layer:displayKey">
	<c path="flump.library.Layer"/>
	<c path="flump.DisplayObjectKey"/>
	<x path="Void"/>
</f></removeFlumpChild>
		<addFlumpChild set="method"><f a="layer:displayKey">
	<c path="flump.library.Layer"/>
	<c path="flump.DisplayObjectKey"/>
	<x path="Void"/>
</f></addFlumpChild>
		<renderFrame set="method"><f a="keyframe:x:y:scaleX:scaleY:skewX:skewY">
	<c path="flump.library.Keyframe"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></renderFrame>
		<getChildPlayer set="method"><f a="keyframe">
	<c path="flump.library.Keyframe"/>
	<c path="flump.MoviePlayer"/>
</f></getChildPlayer>
		<onAnimationComplete set="method"><f a=""><x path="Void"/></f></onAnimationComplete>
		<labelPassed set="method"><f a="label">
	<c path="flump.library.Label"/>
	<x path="Void"/>
</f></labelPassed>
		<meta><m n=":allow"><e>flump</e></m></meta>
	</class>
	<class path="flump.MoviePlayer" params="" file="C:\HaxeToolkit\haxe\lib\pixi-flump-runtime/0,1,1/src/flump/MoviePlayer.hx">
		<symbol><c path="flump.library.MovieSymbol"/></symbol>
		<movie><c path="flump.IFlumpMovie"/></movie>
		<elapsed><x path="Float"/></elapsed>
		<previousElapsed><x path="Float"/></previousElapsed>
		<advanced><x path="Float"/></advanced>
		<independantTimeline public="1"><x path="Bool"/></independantTimeline>
		<independantControl public="1"><x path="Bool"/></independantControl>
		<state><c path="String"/></state>
		<STATE_PLAYING><c path="String"/></STATE_PLAYING>
		<STATE_LOOPING><c path="String"/></STATE_LOOPING>
		<STATE_STOPPED><c path="String"/></STATE_STOPPED>
		<currentChildrenKey><x path="Map">
	<c path="flump.library.Layer"/>
	<c path="flump.DisplayObjectKey"/>
</x></currentChildrenKey>
		<createdChildren><x path="Map">
	<c path="flump.DisplayObjectKey"/>
	<x path="Bool"/>
</x></createdChildren>
		<childPlayers><x path="Map">
	<c path="flump.DisplayObjectKey"/>
	<c path="flump.MoviePlayer"/>
</x></childPlayers>
		<labelsToFire><c path="Array"><c path="flump.library.Label"/></c></labelsToFire>
		<dirty><x path="Bool"/></dirty>
		<fullyGenerated><x path="Bool"/></fullyGenerated>
		<getDisplayKey public="1" set="method" line="50"><f a="layerId:?keyframeIndex">
	<c path="String"/>
	<x path="UInt"/>
	<c path="flump.DisplayObjectKey"/>
</f></getDisplayKey>
		<reset set="method" line="60"><f a=""><x path="Void"/></f></reset>
		<position get="accessor" set="null"><x path="Float"/></position>
		<get_position public="1" set="method" line="67"><f a=""><x path="Float"/></f></get_position>
		<totalFrames public="1" get="accessor" set="null"><x path="UInt"/></totalFrames>
		<get_totalFrames set="method" line="73"><f a=""><x path="UInt"/></f></get_totalFrames>
		<play public="1" set="method" line="78"><f a=""><c path="flump.MoviePlayer"/></f></play>
		<loop public="1" set="method" line="84"><f a=""><c path="flump.MoviePlayer"/></f></loop>
		<stop public="1" set="method" line="90"><f a=""><c path="flump.MoviePlayer"/></f></stop>
		<goToLabel public="1" set="method" line="96"><f a="label">
	<c path="String"/>
	<c path="flump.MoviePlayer"/>
</f></goToLabel>
		<goToFrame public="1" set="method" line="103"><f a="frame">
	<x path="Int"/>
	<c path="flump.MoviePlayer"/>
</f></goToFrame>
		<goToPosition public="1" set="method" line="109"><f a="time">
	<x path="Float"/>
	<c path="flump.MoviePlayer"/>
</f></goToPosition>
		<playing public="1" get="accessor" set="null"><x path="Bool"/></playing>
		<get_playing set="method" line="119"><f a=""><x path="Bool"/></f></get_playing>
		<looping public="1" get="accessor" set="null"><x path="Bool"/></looping>
		<get_looping set="method" line="125"><f a=""><x path="Bool"/></f></get_looping>
		<stopped public="1" get="accessor" set="null"><x path="Bool"/></stopped>
		<get_stopped set="method" line="131"><f a=""><x path="Bool"/></f></get_stopped>
		<getLabelFrame public="1" set="method" line="136"><f a="label">
	<c path="String"/>
	<x path="UInt"/>
</f></getLabelFrame>
		<currentFrame public="1" get="accessor" set="accessor"><x path="Int"/></currentFrame>
		<get_currentFrame set="method" line="143"><f a=""><x path="Int"/></f></get_currentFrame>
		<set_currentFrame set="method" line="146"><f a="value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_currentFrame>
		<labelExists public="1" set="method" line="152"><f a="label">
	<c path="String"/>
	<x path="Bool"/>
</f></labelExists>
		<advanceTime public="1" set="method" line="157"><f a="ms">
	<x path="Float"/>
	<x path="Void"/>
</f></advanceTime>
		<clearLabels set="method" line="172"><f a=""><x path="Void"/></f></clearLabels>
		<fireLabels set="method" line="177"><f a=""><x path="Void"/></f></fireLabels>
		<render set="method" line="225"><f a=""><x path="Void"/></f></render>
		<createChildIfNessessary set="method" line="285"><f a="keyframe">
	<c path="flump.library.Keyframe"/>
	<x path="Void"/>
</f></createChildIfNessessary>
		<removeChildIfNessessary set="method" line="294"><f a="keyframe">
	<c path="flump.library.Keyframe"/>
	<x path="Void"/>
</f></removeChildIfNessessary>
		<addChildIfNessessary set="method" line="302"><f a="keyframe">
	<c path="flump.library.Keyframe"/>
	<x path="Void"/>
</f></addChildIfNessessary>
		<setState set="method" line="316"><f a="state">
	<c path="String"/>
	<x path="Void"/>
</f></setState>
		<timeForLabel set="method" line="333"><f a="label">
	<c path="String"/>
	<x path="Float"/>
</f></timeForLabel>
		<getInterpolation set="method" line="338"><f a="keyframe:time">
	<c path="flump.library.Keyframe"/>
	<x path="Float"/>
	<x path="Float"/>
</f></getInterpolation>
		<new public="1" set="method" line="38"><f a="symbol:movie">
	<c path="flump.library.MovieSymbol"/>
	<c path="flump.IFlumpMovie"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="flump.json.FlumpJSON" params="" file="C:\HaxeToolkit\haxe\lib\pixi-flump-runtime/0,1,1/src/flump/json/FlumpJSON.hx"><a>
	<textureGroups><c path="Array"><t path="flump.json.TextureGroupSpec"/></c></textureGroups>
	<movies><c path="Array"><t path="flump.json.MovieSpec"/></c></movies>
	<md5><c path="String"/></md5>
	<frameRate><x path="UInt"/></frameRate>
</a></typedef>
	<abstract path="flump.json.FlumpPointSpec" params="" file="C:\HaxeToolkit\haxe\lib\pixi-flump-runtime/0,1,1/src/flump/json/FlumpJSON.hx" module="flump.json.FlumpJSON">
		<this><c path="Array"><x path="Float"/></c></this>
		<impl><class path="flump.json._FlumpJSON.FlumpPointSpec_Impl_" params="" file="C:\HaxeToolkit\haxe\lib\pixi-flump-runtime/0,1,1/src/flump/json/FlumpJSON.hx" private="1" module="flump.json.FlumpJSON">
	<x public="1" get="accessor" set="null" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</x>
	<y public="1" get="accessor" set="null" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</y>
	<get_x public="1" get="inline" set="null" line="16" static="1">
		<f a="this">
			<c path="Array"><x path="Float"/></c>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_x>
	<get_y public="1" get="inline" set="null" line="20" static="1">
		<f a="this">
			<c path="Array"><x path="Float"/></c>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_y>
</class></impl>
	</abstract>
	<class path="flump.json._FlumpJSON.FlumpPointSpec_Impl_" params="" file="C:\HaxeToolkit\haxe\lib\pixi-flump-runtime/0,1,1/src/flump/json/FlumpJSON.hx" private="1" module="flump.json.FlumpJSON">
		<x public="1" get="accessor" set="null" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</x>
		<y public="1" get="accessor" set="null" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</y>
		<get_x public="1" get="inline" set="null" line="16" static="1">
			<f a="this">
				<c path="Array"><x path="Float"/></c>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_x>
		<get_y public="1" get="inline" set="null" line="20" static="1">
			<f a="this">
				<c path="Array"><x path="Float"/></c>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_y>
	</class>
	<abstract path="flump.json.FlumpRectSpec" params="" file="C:\HaxeToolkit\haxe\lib\pixi-flump-runtime/0,1,1/src/flump/json/FlumpJSON.hx" module="flump.json.FlumpJSON">
		<this><c path="Array"><x path="Float"/></c></this>
		<impl><class path="flump.json._FlumpJSON.FlumpRectSpec_Impl_" params="" file="C:\HaxeToolkit\haxe\lib\pixi-flump-runtime/0,1,1/src/flump/json/FlumpJSON.hx" private="1" module="flump.json.FlumpJSON">
	<x public="1" get="accessor" set="null" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</x>
	<y public="1" get="accessor" set="null" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</y>
	<width public="1" get="accessor" set="null" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</width>
	<height public="1" get="accessor" set="null" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</height>
	<get_x public="1" get="inline" set="null" line="33" static="1">
		<f a="this">
			<c path="Array"><x path="Float"/></c>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_x>
	<get_y public="1" get="inline" set="null" line="37" static="1">
		<f a="this">
			<c path="Array"><x path="Float"/></c>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_y>
	<get_width public="1" get="inline" set="null" line="41" static="1">
		<f a="this">
			<c path="Array"><x path="Float"/></c>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_width>
	<get_height public="1" get="inline" set="null" line="45" static="1">
		<f a="this">
			<c path="Array"><x path="Float"/></c>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_height>
</class></impl>
	</abstract>
	<class path="flump.json._FlumpJSON.FlumpRectSpec_Impl_" params="" file="C:\HaxeToolkit\haxe\lib\pixi-flump-runtime/0,1,1/src/flump/json/FlumpJSON.hx" private="1" module="flump.json.FlumpJSON">
		<x public="1" get="accessor" set="null" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</x>
		<y public="1" get="accessor" set="null" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</y>
		<width public="1" get="accessor" set="null" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</width>
		<height public="1" get="accessor" set="null" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</height>
		<get_x public="1" get="inline" set="null" line="33" static="1">
			<f a="this">
				<c path="Array"><x path="Float"/></c>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_x>
		<get_y public="1" get="inline" set="null" line="37" static="1">
			<f a="this">
				<c path="Array"><x path="Float"/></c>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_y>
		<get_width public="1" get="inline" set="null" line="41" static="1">
			<f a="this">
				<c path="Array"><x path="Float"/></c>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_width>
		<get_height public="1" get="inline" set="null" line="45" static="1">
			<f a="this">
				<c path="Array"><x path="Float"/></c>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_height>
	</class>
	<typedef path="flump.json.MovieSpec" params="" file="C:\HaxeToolkit\haxe\lib\pixi-flump-runtime/0,1,1/src/flump/json/FlumpJSON.hx" module="flump.json.FlumpJSON"><a>
	<layers><c path="Array"><t path="flump.json.LayerSpec"/></c></layers>
	<id><t path="flump.json.ReferenceSpec"/></id>
</a></typedef>
	<typedef path="flump.json.ReferenceSpec" params="" file="C:\HaxeToolkit\haxe\lib\pixi-flump-runtime/0,1,1/src/flump/json/FlumpJSON.hx" module="flump.json.FlumpJSON"><c path="String"/></typedef>
	<typedef path="flump.json.KeyframeSpec" params="" file="C:\HaxeToolkit\haxe\lib\pixi-flump-runtime/0,1,1/src/flump/json/FlumpJSON.hx" module="flump.json.FlumpJSON"><a>
	<tweened><x path="Bool"/></tweened>
	<skew><x path="flump.json.FlumpPointSpec"/></skew>
	<scale><x path="flump.json.FlumpPointSpec"/></scale>
	<ref><t path="flump.json.ReferenceSpec"/></ref>
	<pivot><x path="flump.json.FlumpPointSpec"/></pivot>
	<loc><x path="flump.json.FlumpPointSpec"/></loc>
	<label><c path="String"/></label>
	<index><x path="UInt"/></index>
	<ease><x path="Float"/></ease>
	<duration><x path="UInt"/></duration>
</a></typedef>
	<typedef path="flump.json.TextureSpec" params="" file="C:\HaxeToolkit\haxe\lib\pixi-flump-runtime/0,1,1/src/flump/json/FlumpJSON.hx" module="flump.json.FlumpJSON"><a>
	<symbol><t path="flump.json.ReferenceSpec"/></symbol>
	<rect><x path="flump.json.FlumpRectSpec"/></rect>
	<origin><x path="flump.json.FlumpPointSpec"/></origin>
</a></typedef>
	<typedef path="flump.json.TextureGroupSpec" params="" file="C:\HaxeToolkit\haxe\lib\pixi-flump-runtime/0,1,1/src/flump/json/FlumpJSON.hx" module="flump.json.FlumpJSON"><a>
	<scaleFactor><x path="UInt"/></scaleFactor>
	<atlases><c path="Array"><t path="flump.json.AtlasSpec"/></c></atlases>
</a></typedef>
	<typedef path="flump.json.AtlasSpec" params="" file="C:\HaxeToolkit\haxe\lib\pixi-flump-runtime/0,1,1/src/flump/json/FlumpJSON.hx" module="flump.json.FlumpJSON"><a>
	<textures><c path="Array"><t path="flump.json.TextureSpec"/></c></textures>
	<file><c path="String"/></file>
</a></typedef>
	<typedef path="flump.json.LayerSpec" params="" file="C:\HaxeToolkit\haxe\lib\pixi-flump-runtime/0,1,1/src/flump/json/FlumpJSON.hx" module="flump.json.FlumpJSON"><a>
	<name><c path="String"/></name>
	<keyframes><c path="Array"><t path="flump.json.KeyframeSpec"/></c></keyframes>
</a></typedef>
	<class path="flump.library.FlumpLibrary" params="" file="C:\HaxeToolkit\haxe\lib\pixi-flump-runtime/0,1,1/src/flump/library/FlumpLibrary.hx">
		<create public="1" set="method" line="21" static="1"><f a="flumpData">
	<d/>
	<c path="flump.library.FlumpLibrary"/>
</f></create>
		<sortLabel set="method" line="197" static="1"><f a="a:b">
	<c path="flump.library.Label"/>
	<c path="flump.library.Label"/>
	<x path="Int"/>
</f></sortLabel>
		<movies public="1"><x path="Map">
	<c path="String"/>
	<c path="flump.library.MovieSymbol"/>
</x></movies>
		<sprites public="1"><x path="Map">
	<c path="String"/>
	<c path="flump.library.SpriteSymbol"/>
</x></sprites>
		<atlases public="1"><c path="Array"><t path="flump.json.AtlasSpec"/></c></atlases>
		<framerate public="1"><x path="Float"/></framerate>
		<frameTime public="1"><x path="Float"/></frameTime>
		<md5 public="1"><c path="String"/></md5>
		<new set="method" line="18"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flump.library.Keyframe" params="" file="C:\HaxeToolkit\haxe\lib\pixi-flump-runtime/0,1,1/src/flump/library/Keyframe.hx">
		<layer public="1"><c path="flump.library.Layer"/></layer>
		<symbolId public="1"><c path="String"/></symbolId>
		<pivot public="1"><c path="flump.library.Point"/></pivot>
		<location public="1"><c path="flump.library.Point"/></location>
		<tweened public="1"><x path="Bool"/></tweened>
		<index public="1"><x path="UInt"/></index>
		<numFrames public="1"><x path="UInt"/></numFrames>
		<time public="1"><x path="Float"/></time>
		<duration public="1"><x path="Float"/></duration>
		<symbol public="1"><c path="flump.library.Symbol"/></symbol>
		<scale public="1"><c path="flump.library.Point"/></scale>
		<skew public="1"><c path="flump.library.Point"/></skew>
		<ease public="1"><x path="Float"/></ease>
		<label public="1"><c path="flump.library.Label"/></label>
		<isEmpty public="1"><x path="Bool"/></isEmpty>
		<next public="1"><c path="flump.library.Keyframe"/></next>
		<prev public="1"><c path="flump.library.Keyframe"/></prev>
		<nextNonEmptyKeyframe public="1"><c path="flump.library.Keyframe"/></nextNonEmptyKeyframe>
		<prevNonEmptyKeyframe public="1"><c path="flump.library.Keyframe"/></prevNonEmptyKeyframe>
		<displayKey public="1"><c path="flump.DisplayObjectKey"/></displayKey>
		<timeInside public="1" set="method" line="35"><f a="time">
	<x path="Float"/>
	<x path="Bool"/>
</f></timeInside>
		<rangeInside public="1" set="method" line="40"><f a="from:to">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Bool"/>
</f></rangeInside>
		<rangeIntersect public="1" set="method" line="45"><f a="from:to">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Bool"/>
</f></rangeIntersect>
		<insideRangeStart public="1" set="method" line="50"><f a="from:to">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Bool"/>
</f></insideRangeStart>
		<insideRangeEnd public="1" set="method" line="58"><f a="from:to">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Bool"/>
</f></insideRangeEnd>
		<new public="1" set="method" line="32"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flump.library.Label" params="" file="C:\HaxeToolkit\haxe\lib\pixi-flump-runtime/0,1,1/src/flump/library/Label.hx">
		<LABEL_ENTER public="1" line="10" static="1"><c path="String"/></LABEL_ENTER>
		<LABEL_EXIT public="1" line="11" static="1"><c path="String"/></LABEL_EXIT>
		<LABEL_UPDATE public="1" line="12" static="1"><c path="String"/></LABEL_UPDATE>
		<name public="1"><c path="String"/></name>
		<keyframe public="1"><c path="flump.library.Keyframe"/></keyframe>
		<next public="1"><c path="flump.library.Label"/></next>
		<prev public="1"><c path="flump.library.Label"/></prev>
		<new public="1" set="method" line="14"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flump.library.Layer" params="" file="C:\HaxeToolkit\haxe\lib\pixi-flump-runtime/0,1,1/src/flump/library/Layer.hx">
		<keyframes public="1"><c path="Array"><c path="flump.library.Keyframe"/></c></keyframes>
		<duration public="1"><x path="Float"/></duration>
		<name public="1"><c path="String"/></name>
		<movie public="1"><c path="flump.library.MovieSymbol"/></movie>
		<numFrames public="1"><x path="UInt"/></numFrames>
		<firstKeyframe public="1"><c path="flump.library.Keyframe"/></firstKeyframe>
		<lastKeyframe public="1"><c path="flump.library.Keyframe"/></lastKeyframe>
		<getKeyframeForFrame public="1" set="method" line="20"><f a="index">
	<x path="UInt"/>
	<c path="flump.library.Keyframe"/>
</f></getKeyframeForFrame>
		<getKeyframeForTime public="1" set="method" line="26"><f a="time">
	<x path="Float"/>
	<c path="flump.library.Keyframe"/>
</f></getKeyframeForTime>
		<new public="1" set="method" line="15"><f a="name">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flump.library.Symbol" params="" file="C:\HaxeToolkit\haxe\lib\pixi-flump-runtime/0,1,1/src/flump/library/Symbol.hx">
		<name public="1"><c path="String"/></name>
		<origin public="1"><c path="flump.library.Point"/></origin>
		<new public="1" set="method" line="9"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="flump.library.MovieSymbol" params="" file="C:\HaxeToolkit\haxe\lib\pixi-flump-runtime/0,1,1/src/flump/library/MovieSymbol.hx">
		<extends path="flump.library.Symbol"/>
		<layers public="1"><c path="Array"><c path="flump.library.Layer"/></c></layers>
		<labels public="1"><x path="Map">
	<c path="String"/>
	<c path="flump.library.Label"/>
</x></labels>
		<library public="1"><c path="flump.library.FlumpLibrary"/></library>
		<duration public="1"><x path="Float"/></duration>
		<totalFrames public="1"><x path="UInt"/></totalFrames>
		<firstLabel public="1"><c path="flump.library.Label"/></firstLabel>
		<lastLabel public="1"><c path="flump.library.Label"/></lastLabel>
		<getLayer public="1" set="method" line="23"><f a="name">
	<c path="String"/>
	<c path="flump.library.Layer"/>
</f></getLayer>
		<debug public="1" set="method" line="29"><f a=""><c path="String"/></f></debug>
		<new public="1" set="method" line="18"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flump.library.Point" params="" file="C:\HaxeToolkit\haxe\lib\pixi-flump-runtime/0,1,1/src/flump/library/Point.hx">
		<x public="1"><x path="Float"/></x>
		<y public="1"><x path="Float"/></y>
		<new public="1" set="method" line="9"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flump.library.Rectangle" params="" file="C:\HaxeToolkit\haxe\lib\pixi-flump-runtime/0,1,1/src/flump/library/Rectangle.hx">
		<x public="1"><x path="Float"/></x>
		<y public="1"><x path="Float"/></y>
		<width public="1"><x path="Float"/></width>
		<height public="1"><x path="Float"/></height>
		<new public="1" set="method" line="11"><f a="x:y:width:height">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flump.library.SpriteSymbol" params="" file="C:\HaxeToolkit\haxe\lib\pixi-flump-runtime/0,1,1/src/flump/library/SpriteSymbol.hx">
		<extends path="flump.library.Symbol"/>
		<texture public="1"><c path="String"/></texture>
		<new public="1" set="method" line="8"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="haxe.Function" params="" file="C:\HaxeToolkit\haxe\std/haxe/Constraints.hx" module="haxe.Constraints">
		<this><d/></this>
		<haxe_doc>This type unifies with any function type.

	It is intended to be used as a type parameter constraint. If used as a real
	type, the underlying type will be `Dynamic`.</haxe_doc>
		<meta><m n=":callable"/></meta>
		<impl><class path="haxe._Constraints.Function_Impl_" params="" file="C:\HaxeToolkit\haxe\std/haxe/Constraints.hx" private="1" module="haxe.Constraints"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<abstract path="haxe.FlatEnum" params="" file="C:\HaxeToolkit\haxe\std/haxe/Constraints.hx" module="haxe.Constraints">
		<this><d/></this>
		<haxe_doc>This type unifies with an enum instance if all constructors of the enum
	require no arguments.

	It is intended to be used as a type parameter constraint. If used as a real
	type, the underlying type will be `Dynamic`.</haxe_doc>
		<impl><class path="haxe._Constraints.FlatEnum_Impl_" params="" file="C:\HaxeToolkit\haxe\std/haxe/Constraints.hx" private="1" module="haxe.Constraints"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<class path="haxe.IMap" params="K:V" file="C:\HaxeToolkit\haxe\std/haxe/Constraints.hx" module="haxe.Constraints" interface="1">
		<get public="1" set="method"><f a="k">
	<c path="haxe.IMap.K"/>
	<t path="Null"><c path="haxe.IMap.V"/></t>
</f></get>
		<set public="1" set="method"><f a="k:v">
	<c path="haxe.IMap.K"/>
	<c path="haxe.IMap.V"/>
	<x path="Void"/>
</f></set>
		<exists public="1" set="method"><f a="k">
	<c path="haxe.IMap.K"/>
	<x path="Bool"/>
</f></exists>
		<meta><m n=":keep"/></meta>
	</class>
	<class path="haxe.EnumTools" params="" file="C:\HaxeToolkit\haxe\std/haxe/EnumTools.hx" extern="1">
		<getName public="1" params="T" get="inline" set="null" line="41" static="1">
			<f a="e">
				<x path="Enum"><c path="getName.T"/></x>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the name of enum `e`, including its path.

		If `e` is inside a package, the package structure is returned dot-
		separated, with another dot separating the enum name:
			pack1.pack2.(...).packN.EnumName
		If `e` is a sub-type of a haxe module, that module is not part of the
		package structure.

		If `e` has no package, the enum name is returned.

		If `e` is null, the result is unspecified.

		The enum name does not include any type parameters.</haxe_doc>
		</getName>
		<createByName public="1" params="T" get="inline" set="null" line="54" static="1">
			<f a="e:constr:?params">
				<x path="Enum"><c path="createByName.T"/></x>
				<c path="String"/>
				<c path="Array"><d/></c>
				<c path="createByName.T"/>
			</f>
			<haxe_doc>Creates an instance of enum `e` by calling its constructor `constr` with
		arguments `params`.

		If `e` or `constr` is null, or if enum `e` has no constructor named
		`constr`, or if the number of elements in `params` does not match the
		expected number of constructor arguments, or if any argument has an
		invalid type, the result is unspecified.</haxe_doc>
		</createByName>
		<createByIndex public="1" params="T" get="inline" set="null" line="70" static="1">
			<f a="e:index:?params">
				<x path="Enum"><c path="createByIndex.T"/></x>
				<x path="Int"/>
				<c path="Array"><d/></c>
				<c path="createByIndex.T"/>
			</f>
			<haxe_doc>Creates an instance of enum `e` by calling its constructor number
		`index` with arguments `params`.

		The constructor indices are preserved from haxe syntax, so the first
		declared is index 0, the next index 1 etc.

		If `e` or `index` is null, or if enum `e` has no constructor
		corresponding to index `index`, or if the number of elements in `params`
		does not match the expected number of constructor arguments, or if any
		argument has an invalid type, the result is unspecified.</haxe_doc>
		</createByIndex>
		<createAll public="1" params="T" get="inline" set="null" line="87" static="1">
			<f a="e">
				<x path="Enum"><c path="createAll.T"/></x>
				<c path="Array"><c path="createAll.T"/></c>
			</f>
			<haxe_doc>Returns a list of all constructors of enum `e` that require no
		arguments.

		This may return the empty Array [] if all constructors of `e` require
		arguments.

		Otherwise an instance of `e` constructed through each of its non-
		argument constructors is returned, in the order of the constructor
		declaration.

		If `e` is null, the result is unspecified.</haxe_doc>
		</createAll>
		<getConstructors public="1" params="T" get="inline" set="null" line="99" static="1">
			<f a="e">
				<x path="Enum"><c path="getConstructors.T"/></x>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns a list of the names of all constructors of enum `e`.

		The order of the constructor names in the returned Array is preserved
		from the original syntax.

		If `c` is null, the result is unspecified.</haxe_doc>
		</getConstructors>
	</class>
	<class path="haxe.EnumValueTools" params="" file="C:\HaxeToolkit\haxe\std/haxe/EnumTools.hx" module="haxe.EnumTools" extern="1">
		<equals public="1" params="T" get="inline" set="null" line="114" static="1">
			<f a="a:b">
				<c path="equals.T"/>
				<c path="equals.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Recursively compares two enum instances `a` and `b` by value.

		Unlike `a == b`, this function performs a deep equality check on the
		arguments of the constructors, if exists.

		If `a` or `b` are null, the result is unspecified.</haxe_doc>
		</equals>
		<getName public="1" get="inline" set="null" line="125" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the constructor name of enum instance `e`.

		The result String does not contain any constructor arguments.

		If `e` is null, the result is unspecified.</haxe_doc>
		</getName>
		<getParameters public="1" get="inline" set="null" line="139" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<c path="Array"><d/></c>
			</f>
			<haxe_doc>Returns a list of the constructor arguments of enum instance `e`.

		If `e` has no arguments, the result is [].

		Otherwise the result are the values that were used as arguments to `e`,
		in the order of their declaration.

		If `e` is null, the result is unspecified.</haxe_doc>
		</getParameters>
		<getIndex public="1" get="inline" set="null" line="151" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the index of enum instance `e`.

		This corresponds to the original syntactic position of `e`. The index of
		the first declared constructor is 0, the next one is 1 etc.

		If `e` is null, the result is unspecified.</haxe_doc>
		</getIndex>
		<match public="1" set="method" static="1">
			<f a="e:pattern">
				<x path="EnumValue"/>
				<d/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Matches enum instance `e` against pattern `pattern`, returning true if
		matching succeeded and false otherwise.

		Example usage:

		```
		if (e.match(pattern)) {
			// codeIfTrue
		} else {
			// codeIfFalse
		}
		```

		This is equivalent to the following code:

		```
		switch (e) {
			case pattern:
				// codeIfTrue
			case _:
				// codeIfFalse
		}
		```

		This method is implemented in the compiler. This definition exists only
		for documentation.</haxe_doc>
		</match>
	</class>
	<class path="haxe.Json" params="" file="C:\HaxeToolkit\haxe\std/js/_std/haxe/Json.hx" extern="1">
		<parse public="1" set="method" static="1">
			<f a="text">
				<c path="String"/>
				<d/>
			</f>
			<haxe_doc><![CDATA[Parses given JSON-encoded `text` and returns the resulting object.

		JSON objects are parsed into anonymous structures and JSON arrays
		are parsed into Array<Dynamic>.

		If given `text` is not valid JSON, an exception will be thrown.]]></haxe_doc>
		</parse>
		<stringify public="1" set="method" static="1">
			<f a="value:?replacer:?space">
				<d/>
				<f a=":">
					<d/>
					<d/>
					<d/>
				</f>
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Encodes given `value` and returns the resulting JSON string.

		If `replacer` is given and is not null, it is used to retrieve
		actual object to be encoded. The `replacer` function two parameters,
		the key and the value being encoded. Initial key value is an empty string.
		
		If `space` is given and is not null, the result will be pretty-printed.
		Successive levels will be indented by this string.</haxe_doc>
		</stringify>
		<haxe_doc>Crossplatform JSON API : it will automatically use the optimized native API if available.
	Use -D haxeJSON to force usage of the Haxe implementation even if a native API is found : this will provide
	extra encoding features such as enums (replaced by their index) and StringMaps.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
			<m n=":native"><e>"JSON"</e></m>
		</meta>
	</class>
	<typedef path="haxe.PosInfos" params="" file="C:\HaxeToolkit\haxe\std/haxe/PosInfos.hx">
		<a>
			<methodName><c path="String"/></methodName>
			<lineNumber><x path="Int"/></lineNumber>
			<fileName><c path="String"/></fileName>
			<customParams>
				<t path="Null"><c path="Array"><d/></c></t>
				<meta><m n=":optional"/></meta>
			</customParams>
			<className><c path="String"/></className>
		</a>
		<haxe_doc>PosInfos is a magic type which can be used to generate position information
	into the output for debugging use.

	If a function has a final optional argument of this type, i.e.
	(..., ?pos:haxe.PosInfos), each call to that function which does not assign
	a value to that argument has its position added as call argument.

	This can be used to track positions of calls in e.g. a unit testing
	framework.</haxe_doc>
	</typedef>
	<class path="haxe.Timer" params="" file="C:\HaxeToolkit\haxe\std/haxe/Timer.hx">
		<stamp public="1" set="method" line="156" static="1">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Returns a timestamp, in seconds with fractions.

		The value itself might differ depending on platforms, only differences
		between two values make sense.</haxe_doc>
		</stamp>
		<id><t path="Null"><x path="Int"/></t></id>
		<stop public="1" set="method" line="80">
			<f a=""><x path="Void"/></f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Stops `this` Timer.

		After calling this method, no additional invocations of `this.run`
		will occur.

		It is not possible to restart `this` Timer once stopped.</haxe_doc>
		</stop>
		<run public="1" set="dynamic" line="108">
			<f a=""><x path="Void"/></f>
			<haxe_doc>This method is invoked repeatedly on `this` Timer.

		It can be overridden in a subclass, or rebound directly to a custom
		function:
			var timer = new haxe.Timer(1000); // 1000ms delay
			timer.run = function() { ... }

		Once bound, it can still be rebound to different functions until `this`
		Timer is stopped through a call to `this.stop`.</haxe_doc>
		</run>
		<new public="1" set="method" line="59">
			<f a="time_ms">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Creates a new timer that will run every `time_ms` milliseconds.

		After creating the Timer instance, it calls `this].run` repeatedly,
		with delays of `time_ms` milliseconds, until `this.stop` is called.

		The first invocation occurs after `time_ms` milliseconds, not
		immediately.

		The accuracy of this may be platform-dependent.</haxe_doc>
		</new>
		<haxe_doc>The Timer class allows you to create asynchronous timers on platforms that
	support events.

	The intended usage is to create an instance of the Timer class with a given
	interval, set its run() method to a custom function to be invoked and
	eventually call stop() to stop the Timer.

	Note that a running Timer may or may not prevent the program to exit
	automatically when main() returns.

	It is also possible to extend this class and override its run() method in
	the child class.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.ds.ArraySort" params="" file="C:\HaxeToolkit\haxe\std/haxe/ds/ArraySort.hx">
		<sort public="1" params="T" set="method" line="43" static="1">
			<f a="a:cmp">
				<c path="Array"><c path="sort.T"/></c>
				<f a=":">
					<c path="sort.T"/>
					<c path="sort.T"/>
					<x path="Int"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[Sorts Array `a` according to the comparison function `cmp`, where
		`cmp(x,y)` returns 0 if `x == y`, a positive Int if `x > y` and a
		negative Int if `x < y`.

		This operation modifies Array `a` in place.

		This operation is stable: The order of equal elements is preserved.

		If `a` or `cmp` are null, the result is unspecified.]]></haxe_doc>
		</sort>
		<rec params="T" set="method" line="47" static="1"><f a="a:cmp:from:to">
	<c path="Array"><c path="rec.T"/></c>
	<f a=":">
		<c path="rec.T"/>
		<c path="rec.T"/>
		<x path="Int"/>
	</f>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></rec>
		<doMerge params="T" set="method" line="68" static="1"><f a="a:cmp:from:pivot:to:len1:len2">
	<c path="Array"><c path="doMerge.T"/></c>
	<f a=":">
		<c path="doMerge.T"/>
		<c path="doMerge.T"/>
		<x path="Int"/>
	</f>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></doMerge>
		<rotate params="T" set="method" line="94" static="1"><f a="a:cmp:from:mid:to">
	<c path="Array"><c path="rotate.T"/></c>
	<f a=":">
		<c path="doMerge.T"/>
		<c path="doMerge.T"/>
		<x path="Int"/>
	</f>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></rotate>
		<gcd set="method" line="112" static="1"><f a="m:n">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></gcd>
		<upper params="T" set="method" line="121" static="1"><f a="a:cmp:from:to:val">
	<c path="Array"><c path="upper.T"/></c>
	<f a=":">
		<c path="upper.T"/>
		<c path="upper.T"/>
		<x path="Int"/>
	</f>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></upper>
		<lower params="T" set="method" line="136" static="1"><f a="a:cmp:from:to:val">
	<c path="Array"><c path="lower.T"/></c>
	<f a=":">
		<c path="lower.T"/>
		<c path="lower.T"/>
		<x path="Int"/>
	</f>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></lower>
		<swap params="T" set="method" line="150" static="1"><f a="a:i:j">
	<c path="Array"><c path="swap.T"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></swap>
		<haxe_doc>ArraySort provides a stable implementation of merge sort through its `sort`
	method. It should be used instead of `Array.sort` in cases where the order
	of equal elements has to be retained on all targets.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.ds.BalancedTree" params="K:V" file="C:\HaxeToolkit\haxe\std/haxe/ds/BalancedTree.hx">
		<root><c path="haxe.ds.TreeNode">
	<c path="haxe.ds.BalancedTree.K"/>
	<c path="haxe.ds.BalancedTree.V"/>
</c></root>
		<set public="1" set="method" line="50">
			<f a="key:value">
				<c path="haxe.ds.BalancedTree.K"/>
				<c path="haxe.ds.BalancedTree.V"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Binds `key` to `value`.

		If `key` is already bound to a value, that binding disappears.

		If `key` is null, the result is unspecified.</haxe_doc>
		</set>
		<get public="1" set="method" line="61">
			<f a="key">
				<c path="haxe.ds.BalancedTree.K"/>
				<t path="Null"><c path="haxe.ds.BalancedTree.V"/></t>
			</f>
			<haxe_doc>Returns the value `key` is bound to.

		If `key` is not bound to any value, `null` is returned.

		If `key` is null, the result is unspecified.</haxe_doc>
		</get>
		<exists public="1" set="method" line="99">
			<f a="key">
				<c path="haxe.ds.BalancedTree.K"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if `key` is bound to a value.

		This method returns true even if `key` is bound to null.

		If `key` is null, the result is unspecified.</haxe_doc>
		</exists>
		<setLoop set="method" line="132"><f a="k:v:node">
	<c path="haxe.ds.BalancedTree.K"/>
	<c path="haxe.ds.BalancedTree.V"/>
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
</f></setLoop>
		<balance set="method" line="187"><f a="l:k:v:r">
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
	<c path="haxe.ds.BalancedTree.K"/>
	<c path="haxe.ds.BalancedTree.V"/>
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
</f></balance>
		<compare set="method" line="201"><f a="k1:k2">
	<c path="haxe.ds.BalancedTree.K"/>
	<c path="haxe.ds.BalancedTree.K"/>
	<x path="Int"/>
</f></compare>
		<new public="1" set="method" line="41">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new BalancedTree, which is initially empty.</haxe_doc>
		</new>
		<haxe_doc>BalancedTree allows key-value mapping with arbitrary keys, as long as they
	can be ordered. By default, `Reflect.compare` is used in the `compare`
	method, which can be overridden in subclasses.

	Operations have a logarithmic average and worst-case cost.

	Iteration over keys and values, using `keys` and `iterator` respectively,
	are in-order.</haxe_doc>
		<meta><m n=":keep"/></meta>
	</class>
	<class path="haxe.ds.TreeNode" params="K:V" file="C:\HaxeToolkit\haxe\std/haxe/ds/BalancedTree.hx" module="haxe.ds.BalancedTree">
		<left public="1"><c path="haxe.ds.TreeNode">
	<c path="haxe.ds.TreeNode.K"/>
	<c path="haxe.ds.TreeNode.V"/>
</c></left>
		<right public="1"><c path="haxe.ds.TreeNode">
	<c path="haxe.ds.TreeNode.K"/>
	<c path="haxe.ds.TreeNode.V"/>
</c></right>
		<key public="1"><c path="haxe.ds.TreeNode.K"/></key>
		<value public="1"><c path="haxe.ds.TreeNode.V"/></value>
		<_height><x path="Int"/></_height>
		<new public="1" set="method" line="220"><f a="l:k:v:r:?h">
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.TreeNode.K"/>
		<c path="haxe.ds.TreeNode.V"/>
	</c>
	<c path="haxe.ds.TreeNode.K"/>
	<c path="haxe.ds.TreeNode.V"/>
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.TreeNode.K"/>
		<c path="haxe.ds.TreeNode.V"/>
	</c>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.ds.EnumValueMap" params="K:V" file="C:\HaxeToolkit\haxe\std/haxe/ds/EnumValueMap.hx">
		<extends path="haxe.ds.BalancedTree">
			<c path="haxe.ds.EnumValueMap.K"/>
			<c path="haxe.ds.EnumValueMap.V"/>
		</extends>
		<implements path="haxe.IMap">
			<c path="haxe.ds.EnumValueMap.K"/>
			<c path="haxe.ds.EnumValueMap.V"/>
		</implements>
		<compare set="method" line="33" override="1"><f a="k1:k2">
	<x path="EnumValue"/>
	<x path="EnumValue"/>
	<x path="Int"/>
</f></compare>
		<compareArgs set="method" line="42"><f a="a1:a2">
	<c path="Array"><d/></c>
	<c path="Array"><d/></c>
	<x path="Int"/>
</f></compareArgs>
		<compareArg set="method" line="52"><f a="v1:v2">
	<d/>
	<d/>
	<x path="Int"/>
</f></compareArg>
		<new public="1" set="method" line="31"><f a=""><x path="Void"/></f></new>
		<haxe_doc>EnumValueMap allows mapping of enum value keys to arbitrary values.

	Keys are compared by value and recursively over their parameters. If any
	parameter is not an enum value, `Reflect.compare` is used to compare them.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<abstract path="haxe.ds.HashMap" params="K:V" file="C:\HaxeToolkit\haxe\std/haxe/ds/HashMap.hx">
		<this><c path="haxe.ds._HashMap.HashMapData">
	<c path="haxe.ds.HashMap.K"/>
	<c path="haxe.ds.HashMap.V"/>
</c></this>
		<impl><class path="haxe.ds._HashMap.HashMap_Impl_" params="" file="C:\HaxeToolkit\haxe\std/haxe/ds/HashMap.hx" private="1" module="haxe.ds.HashMap"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<class path="haxe.ds.IntMap" params="T" file="C:\HaxeToolkit\haxe\std/js/_std/haxe/ds/IntMap.hx">
		<implements path="haxe.IMap">
			<x path="Int"/>
			<c path="haxe.ds.IntMap.T"/>
		</implements>
		<h><d/></h>
		<set public="1" get="inline" set="null" line="32">
			<f a="key:value">
				<x path="Int"/>
				<c path="haxe.ds.IntMap.T"/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>See `Map.set`</haxe_doc>
		</set>
		<get public="1" get="inline" set="null" line="36">
			<f a="key">
				<x path="Int"/>
				<t path="Null"><c path="haxe.ds.IntMap.T"/></t>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>See `Map.get`</haxe_doc>
		</get>
		<exists public="1" get="inline" set="null" line="40">
			<f a="key">
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>See `Map.exists`</haxe_doc>
		</exists>
		<new public="1" get="inline" set="null" line="28">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new IntMap.</haxe_doc>
		</new>
		<haxe_doc>IntMap allows mapping of Int keys to arbitrary values.

	See `Map` for documentation details.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="haxe.ds.ObjectMap" params="K:V" file="C:\HaxeToolkit\haxe\std/js/_std/haxe/ds/ObjectMap.hx">
		<implements path="haxe.IMap">
			<c path="haxe.ds.ObjectMap.K"/>
			<c path="haxe.ds.ObjectMap.V"/>
		</implements>
		<count line="28" static="1"><x path="Int"/></count>
		<h><a/></h>
		<set public="1" set="method" line="45">
			<f a="key:value">
				<c path="haxe.ds.ObjectMap.K"/>
				<c path="haxe.ds.ObjectMap.V"/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>See `Map.set`</haxe_doc>
		</set>
		<get public="1" get="inline" set="null" line="51">
			<f a="key">
				<c path="haxe.ds.ObjectMap.K"/>
				<t path="Null"><c path="haxe.ds.ObjectMap.V"/></t>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>See `Map.get`</haxe_doc>
		</get>
		<exists public="1" get="inline" set="null" line="55">
			<f a="key">
				<c path="haxe.ds.ObjectMap.K"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>See `Map.exists`</haxe_doc>
		</exists>
		<remove public="1" set="method" line="59">
			<f a="key">
				<c path="haxe.ds.ObjectMap.K"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>See `Map.remove`</haxe_doc>
		</remove>
		<keys public="1" set="method" line="67">
			<f a=""><t path="Iterator"><c path="haxe.ds.ObjectMap.K"/></t></f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>See `Map.keys`</haxe_doc>
		</keys>
		<iterator public="1" set="method" line="78">
			<f a=""><t path="Iterator"><c path="haxe.ds.ObjectMap.V"/></t></f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>See `Map.iterator`</haxe_doc>
		</iterator>
		<new public="1" set="method" line="40">
			<f a=""><x path="Void"/></f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Creates a new ObjectMap.</haxe_doc>
		</new>
		<haxe_doc>ObjectMap allows mapping of object keys to arbitrary values.

	On static targets, the keys are considered to be strong references. Refer
	to `haxe.ds.WeakMap` for a weak reference version.

	See `Map` for documentation details.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="haxe.ds._StringMap.StringMapIterator" params="T" file="C:\HaxeToolkit\haxe\std/js/_std/haxe/ds/StringMap.hx" private="1" module="haxe.ds.StringMap">
		<map><c path="haxe.ds.StringMap"><c path="haxe.ds._StringMap.StringMapIterator.T"/></c></map>
		<keys><c path="Array"><c path="String"/></c></keys>
		<index><x path="Int"/></index>
		<count><x path="Int"/></count>
		<hasNext public="1" get="inline" set="null" line="35"><f a=""><x path="Bool"/></f></hasNext>
		<next public="1" get="inline" set="null" line="38"><f a=""><t path="Null"><c path="haxe.ds._StringMap.StringMapIterator.T"/></t></f></next>
		<new public="1" get="inline" set="null" line="29"><f a="map:keys">
	<c path="haxe.ds.StringMap"><c path="haxe.ds._StringMap.StringMapIterator.T"/></c>
	<c path="Array"><c path="String"/></c>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.ds.StringMap" params="T" file="C:\HaxeToolkit\haxe\std/js/_std/haxe/ds/StringMap.hx">
		<implements path="haxe.IMap">
			<c path="String"/>
			<c path="haxe.ds.StringMap.T"/>
		</implements>
		<h><d/></h>
		<rh><d/></rh>
		<set public="1" get="inline" set="null" line="56">
			<f a="key:value">
				<c path="String"/>
				<c path="haxe.ds.StringMap.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>See `Map.set`</haxe_doc>
		</set>
		<get public="1" get="inline" set="null" line="63">
			<f a="key">
				<c path="String"/>
				<t path="Null"><c path="haxe.ds.StringMap.T"/></t>
			</f>
			<haxe_doc>See `Map.get`</haxe_doc>
		</get>
		<exists public="1" get="inline" set="null" line="69">
			<f a="key">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>See `Map.exists`</haxe_doc>
		</exists>
		<setReserved set="method" line="75"><f a="key:value">
	<c path="String"/>
	<c path="haxe.ds.StringMap.T"/>
	<x path="Void"/>
</f></setReserved>
		<getReserved set="method" line="80"><f a="key">
	<c path="String"/>
	<t path="Null"><c path="haxe.ds.StringMap.T"/></t>
</f></getReserved>
		<existsReserved set="method" line="84">
			<f a="key">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</existsReserved>
		<remove public="1" set="method" line="89">
			<f a="key">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>See `Map.remove`</haxe_doc>
		</remove>
		<keys public="1" set="method" line="103">
			<f a=""><t path="Iterator"><c path="String"/></t></f>
			<haxe_doc>See `Map.keys`</haxe_doc>
		</keys>
		<arrayKeys set="method" line="107">
			<f a=""><c path="Array"><c path="String"/></c></f>
			<meta><m n=":has_untyped"/></meta>
		</arrayKeys>
		<iterator public="1" get="inline" set="null" line="124">
			<f a=""><t path="Iterator"><c path="haxe.ds.StringMap.T"/></t></f>
			<haxe_doc>See `Map.iterator`</haxe_doc>
		</iterator>
		<new public="1" get="inline" set="null" line="48">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new StringMap.</haxe_doc>
		</new>
		<haxe_doc>StringMap allows mapping of String keys to arbitrary values.

	See `Map` for documentation details.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<abstract path="haxe.extern.EitherType" params="T1:T2" file="C:\HaxeToolkit\haxe\std/haxe/extern/EitherType.hx">
		<from>
			<icast><c path="haxe.extern.EitherType.T2"/></icast>
			<icast><c path="haxe.extern.EitherType.T1"/></icast>
		</from>
		<this><d/></this>
		<to>
			<icast><c path="haxe.extern.EitherType.T2"/></icast>
			<icast><c path="haxe.extern.EitherType.T1"/></icast>
		</to>
		<haxe_doc>An abstract type allowing values to be either of `T1` or `T2` type.
    Supports implicit casts from/to either types.

    It is useful for interfacing with external code on dynamic platforms
    such as JavaScript or Python.

    Otherwise, use of this type is discouraged.</haxe_doc>
		<impl><class path="haxe.extern._EitherType.EitherType_Impl_" params="" file="C:\HaxeToolkit\haxe\std/haxe/extern/EitherType.hx" private="1" module="haxe.extern.EitherType"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<abstract path="haxe.extern.Rest" params="T" file="C:\HaxeToolkit\haxe\std/haxe/extern/Rest.hx">
		<this><c path="Array"><c path="haxe.extern.Rest.T"/></c></this>
		<haxe_doc>A special abstract type that represents "rest" function argument.

    Should be used as a type for the last argument of an extern method,
    representing that arbitrary number of arguments of given type can be
    passed to that method.</haxe_doc>
		<impl><class path="haxe.extern._Rest.Rest_Impl_" params="" file="C:\HaxeToolkit\haxe\std/haxe/extern/Rest.hx" private="1" module="haxe.extern.Rest"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<typedef path="haxe.macro.Position" params="" file="C:\HaxeToolkit\haxe\std/haxe/macro/Expr.hx" module="haxe.macro.Expr"><a>
	<min><x path="Int"/></min>
	<max><x path="Int"/></max>
	<file><c path="String"/></file>
</a></typedef>
	<typedef path="haxe.macro.Expr" params="" file="C:\HaxeToolkit\haxe\std/haxe/macro/Expr.hx"><a>
	<pos><t path="haxe.macro.Position"/></pos>
	<expr><e path="haxe.macro.ExprDef"/></expr>
</a></typedef>
	<typedef path="haxe.macro.ExprOf" params="T" file="C:\HaxeToolkit\haxe\std/haxe/macro/Expr.hx" module="haxe.macro.Expr"><t path="haxe.macro.Expr"/></typedef>
	<typedef path="haxe.macro.Case" params="" file="C:\HaxeToolkit\haxe\std/haxe/macro/Expr.hx" module="haxe.macro.Expr"><a>
	<values><c path="Array"><t path="haxe.macro.Expr"/></c></values>
	<guard>
		<t path="Null"><t path="Null"><t path="haxe.macro.Expr"/></t></t>
		<meta><m n=":optional"/></meta>
	</guard>
	<expr><t path="Null"><t path="haxe.macro.Expr"/></t></expr>
</a></typedef>
	<typedef path="haxe.macro.Var" params="" file="C:\HaxeToolkit\haxe\std/haxe/macro/Expr.hx" module="haxe.macro.Expr"><a>
	<type><t path="Null"><e path="haxe.macro.ComplexType"/></t></type>
	<name><c path="String"/></name>
	<expr><t path="Null"><t path="haxe.macro.Expr"/></t></expr>
</a></typedef>
	<typedef path="haxe.macro.Catch" params="" file="C:\HaxeToolkit\haxe\std/haxe/macro/Expr.hx" module="haxe.macro.Expr"><a>
	<type><e path="haxe.macro.ComplexType"/></type>
	<name><c path="String"/></name>
	<expr><t path="haxe.macro.Expr"/></expr>
</a></typedef>
	<typedef path="haxe.macro.TypePath" params="" file="C:\HaxeToolkit\haxe\std/haxe/macro/Expr.hx" module="haxe.macro.Expr"><a>
	<sub>
		<t path="Null"><t path="Null"><c path="String"/></t></t>
		<meta><m n=":optional"/></meta>
	</sub>
	<params>
		<t path="Null"><c path="Array"><e path="haxe.macro.TypeParam"/></c></t>
		<meta><m n=":optional"/></meta>
	</params>
	<pack><c path="Array"><c path="String"/></c></pack>
	<name><c path="String"/></name>
</a></typedef>
	<typedef path="haxe.macro.TypeParamDecl" params="" file="C:\HaxeToolkit\haxe\std/haxe/macro/Expr.hx" module="haxe.macro.Expr"><a>
	<params>
		<t path="Null"><c path="Array"><t path="haxe.macro.TypeParamDecl"/></c></t>
		<meta><m n=":optional"/></meta>
	</params>
	<name><c path="String"/></name>
	<constraints>
		<t path="Null"><c path="Array"><e path="haxe.macro.ComplexType"/></c></t>
		<meta><m n=":optional"/></meta>
	</constraints>
</a></typedef>
	<typedef path="haxe.macro.Function" params="" file="C:\HaxeToolkit\haxe\std/haxe/macro/Expr.hx" module="haxe.macro.Expr"><a>
	<ret><t path="Null"><e path="haxe.macro.ComplexType"/></t></ret>
	<params>
		<t path="Null"><c path="Array"><t path="haxe.macro.TypeParamDecl"/></c></t>
		<meta><m n=":optional"/></meta>
	</params>
	<expr><t path="Null"><t path="haxe.macro.Expr"/></t></expr>
	<args><c path="Array"><t path="haxe.macro.FunctionArg"/></c></args>
</a></typedef>
	<typedef path="haxe.macro.FunctionArg" params="" file="C:\HaxeToolkit\haxe\std/haxe/macro/Expr.hx" module="haxe.macro.Expr"><a>
	<value>
		<t path="Null"><t path="Null"><t path="haxe.macro.Expr"/></t></t>
		<meta><m n=":optional"/></meta>
	</value>
	<type><t path="Null"><e path="haxe.macro.ComplexType"/></t></type>
	<opt>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</opt>
	<name><c path="String"/></name>
</a></typedef>
	<typedef path="haxe.macro.MetadataEntry" params="" file="C:\HaxeToolkit\haxe\std/haxe/macro/Expr.hx" module="haxe.macro.Expr"><a>
	<pos><t path="haxe.macro.Position"/></pos>
	<params>
		<t path="Null"><c path="Array"><t path="haxe.macro.Expr"/></c></t>
		<meta><m n=":optional"/></meta>
	</params>
	<name><c path="String"/></name>
</a></typedef>
	<typedef path="haxe.macro.Metadata" params="" file="C:\HaxeToolkit\haxe\std/haxe/macro/Expr.hx" module="haxe.macro.Expr"><c path="Array"><t path="haxe.macro.MetadataEntry"/></c></typedef>
	<typedef path="haxe.macro.Field" params="" file="C:\HaxeToolkit\haxe\std/haxe/macro/Expr.hx" module="haxe.macro.Expr"><a>
	<pos><t path="haxe.macro.Position"/></pos>
	<name><c path="String"/></name>
	<meta>
		<t path="Null"><t path="haxe.macro.Metadata"/></t>
		<meta><m n=":optional"/></meta>
	</meta>
	<kind><e path="haxe.macro.FieldType"/></kind>
	<doc>
		<t path="Null"><t path="Null"><c path="String"/></t></t>
		<meta><m n=":optional"/></meta>
	</doc>
	<access>
		<t path="Null"><c path="Array"><e path="haxe.macro.Access"/></c></t>
		<meta><m n=":optional"/></meta>
	</access>
</a></typedef>
	<typedef path="haxe.macro.TypeDefinition" params="" file="C:\HaxeToolkit\haxe\std/haxe/macro/Expr.hx" module="haxe.macro.Expr"><a>
	<pos><t path="haxe.macro.Position"/></pos>
	<params>
		<t path="Null"><c path="Array"><t path="haxe.macro.TypeParamDecl"/></c></t>
		<meta><m n=":optional"/></meta>
	</params>
	<pack><c path="Array"><c path="String"/></c></pack>
	<name><c path="String"/></name>
	<meta>
		<t path="Null"><t path="haxe.macro.Metadata"/></t>
		<meta><m n=":optional"/></meta>
	</meta>
	<kind><e path="haxe.macro.TypeDefKind"/></kind>
	<isExtern>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</isExtern>
	<fields><c path="Array"><t path="haxe.macro.Field"/></c></fields>
</a></typedef>
	<typedef path="haxe.macro.ImportExpr" params="" file="C:\HaxeToolkit\haxe\std/haxe/macro/Expr.hx" module="haxe.macro.Expr"><a>
	<path><c path="Array"><a>
	<pos><t path="haxe.macro.Position"/></pos>
	<name><c path="String"/></name>
</a></c></path>
	<mode><e path="haxe.macro.ImportMode"/></mode>
</a></typedef>
	<class path="howler.Howl" params="" file="C:\HaxeToolkit\haxe\lib\howlerjs/1,1,25/howler/Howl.hx" extern="1">
		<load public="1" set="method"><f a=""><c path="howler.Howl"/></f></load>
		<urls public="1" set="method">
			<f a="urls">
				<c path="Array"><c path="String"/></c>
				<c path="Array"><c path="String"/></c>
			</f>
			<overloads><urls public="1" set="method"><f a="urls">
	<c path="Array"><c path="String"/></c>
	<c path="howler.Howl"/>
</f></urls></overloads>
		</urls>
		<play public="1" set="method"><f a="?sprite:?callBack">
	<c path="String"/>
	<f a="">
		<c path="String"/>
		<x path="Void"/>
	</f>
	<c path="howler.Howl"/>
</f></play>
		<pause public="1" set="method"><f a="?id">
	<c path="String"/>
	<c path="howler.Howl"/>
</f></pause>
		<stop public="1" set="method"><f a="?id">
	<c path="String"/>
	<c path="howler.Howl"/>
</f></stop>
		<mute public="1" set="method"><f a="?id">
	<c path="String"/>
	<c path="howler.Howl"/>
</f></mute>
		<unmute public="1" set="method"><f a="?id">
	<c path="String"/>
	<c path="howler.Howl"/>
</f></unmute>
		<volume public="1" set="method">
			<f a="vol:?id">
				<x path="Float"/>
				<c path="String"/>
				<x path="Float"/>
			</f>
			<overloads><volume public="1" set="method"><f a="vol:?id">
	<x path="Float"/>
	<c path="String"/>
	<c path="howler.Howl"/>
</f></volume></overloads>
		</volume>
		<loop public="1" set="method">
			<f a="loop">
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<overloads><loop public="1" set="method"><f a="loop">
	<x path="Bool"/>
	<c path="howler.Howl"/>
</f></loop></overloads>
		</loop>
		<sprite public="1" set="method">
			<f a="sprite">
				<t path="howler.SpriteParams"/>
				<d/>
			</f>
			<overloads><sprite public="1" set="method"><f a="sprite">
	<t path="howler.SpriteParams"/>
	<c path="howler.Howl"/>
</f></sprite></overloads>
		</sprite>
		<pos public="1" set="method">
			<f a="pos:?id">
				<x path="Float"/>
				<c path="String"/>
				<x path="Float"/>
			</f>
			<overloads><pos public="1" set="method"><f a="pos:?id">
	<x path="Float"/>
	<c path="String"/>
	<c path="howler.Howl"/>
</f></pos></overloads>
		</pos>
		<pos3d public="1" set="method">
			<f a="x:y:z:?id">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="String"/>
				<c path="Array"><x path="Float"/></c>
			</f>
			<overloads><pos3d public="1" set="method"><f a="x:y:z:?id">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="String"/>
	<c path="howler.Howl"/>
</f></pos3d></overloads>
		</pos3d>
		<fade public="1" set="method"><f a="f:t:len:?callBack:?id">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<f a=""><x path="Void"/></f>
	<c path="String"/>
	<c path="howler.Howl"/>
</f></fade>
		<fadeIn public="1" set="method"><f a="t:len:callBack">
	<x path="Float"/>
	<x path="Float"/>
	<f a=""><x path="Void"/></f>
	<c path="howler.Howl"/>
</f></fadeIn>
		<fadeOut public="1" set="method"><f a="t:len:callBack:?id">
	<x path="Float"/>
	<x path="Float"/>
	<f a=""><x path="Void"/></f>
	<c path="String"/>
	<c path="howler.Howl"/>
</f></fadeOut>
		<on public="1" set="method"><f a="event:?fn">
	<c path="String"/>
	<f a=""><x path="Void"/></f>
	<c path="howler.Howl"/>
</f></on>
		<off public="1" set="method"><f a="event:?fn">
	<c path="String"/>
	<f a=""><x path="Void"/></f>
	<c path="howler.Howl"/>
</f></off>
		<unload public="1" set="method"><f a=""><x path="Void"/></f></unload>
		<decodeAudioData public="1" set="method"><f a="arraybuffer:obj:url">
	<c path="js.html.ArrayBuffer"/>
	<c path="howler.Howl"/>
	<c path="String"/>
	<c path="String"/>
</f></decodeAudioData>
		<loadBuffer public="1" set="method"><f a="obj:url">
	<c path="howler.Howl"/>
	<c path="String"/>
	<c path="String"/>
</f></loadBuffer>
		<loadSound public="1" set="method"><f a="obj:buffer">
	<c path="howler.Howl"/>
	<c path="js.html.audio.AudioBuffer"/>
	<c path="String"/>
</f></loadSound>
		<refreshBuffer public="1" set="method"><f a="obj:loop:?id">
	<c path="howler.Howl"/>
	<c path="Array"><t path="howler.RefreshBufferLoopParams"/></c>
	<c path="String"/>
	<x path="Void"/>
</f></refreshBuffer>
		<new public="1" set="method"><f a="options">
	<t path="howler.HowlOptions"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":native"><e>"window.Howl"</e></m>
		</meta>
	</class>
	<typedef path="howler.RefreshBufferLoopParams" params="" file="C:\HaxeToolkit\haxe\lib\howlerjs/1,1,25/howler/Howl.hx" module="howler.Howl"><a>
	<pos><x path="Float"/></pos>
	<loop><x path="Bool"/></loop>
	<duration><x path="Float"/></duration>
</a></typedef>
	<typedef path="howler.SpriteParams" params="" file="C:\HaxeToolkit\haxe\lib\howlerjs/1,1,25/howler/Howl.hx" module="howler.Howl"><a>
	<offset><x path="Int"/></offset>
	<loop>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</loop>
	<duration><x path="Int"/></duration>
</a></typedef>
	<typedef path="howler.HowlOptions" params="" file="C:\HaxeToolkit\haxe\lib\howlerjs/1,1,25/howler/Howl.hx" module="howler.Howl"><a>
	<volume>
		<t path="Null"><x path="Float"/></t>
		<meta><m n=":optional"/></meta>
	</volume>
	<urls>
		<t path="Null"><c path="Array"><c path="String"/></c></t>
		<meta><m n=":optional"/></meta>
	</urls>
	<src>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</src>
	<sprite>
		<t path="Null"><d/></t>
		<meta><m n=":optional"/></meta>
	</sprite>
	<rate>
		<t path="Null"><x path="Float"/></t>
		<meta><m n=":optional"/></meta>
	</rate>
	<pos3d>
		<t path="Null"><c path="Array"><x path="Float"/></c></t>
		<meta><m n=":optional"/></meta>
	</pos3d>
	<onplay>
		<t path="Null"><f a=""><x path="Void"/></f></t>
		<meta><m n=":optional"/></meta>
	</onplay>
	<onpause>
		<t path="Null"><f a=""><x path="Void"/></f></t>
		<meta><m n=":optional"/></meta>
	</onpause>
	<onloaderror>
		<t path="Null"><f a=""><x path="Void"/></f></t>
		<meta><m n=":optional"/></meta>
	</onloaderror>
	<onload>
		<t path="Null"><f a=""><x path="Void"/></f></t>
		<meta><m n=":optional"/></meta>
	</onload>
	<onend>
		<t path="Null"><f a=""><x path="Void"/></f></t>
		<meta><m n=":optional"/></meta>
	</onend>
	<model>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</model>
	<loop>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</loop>
	<format>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</format>
	<duration>
		<t path="Null"><x path="Float"/></t>
		<meta><m n=":optional"/></meta>
	</duration>
	<buffer>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</buffer>
	<autoplay>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</autoplay>
</a></typedef>
	<class path="howler.Howler" params="" file="C:\HaxeToolkit\haxe\lib\howlerjs/1,1,25/howler/Howler.hx" extern="1">
		<ctx public="1" static="1"><c path="js.html.audio.AudioContext"/></ctx>
		<usingWebAudio public="1" static="1"><x path="Bool"/></usingWebAudio>
		<codecs public="1" set="method" static="1"><f a="ext">
	<c path="String"/>
	<x path="Bool"/>
</f></codecs>
		<volume public="1" set="method" static="1">
			<f a="vol">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<overloads><volume public="1" set="method"><f a="vol">
	<x path="Float"/>
	<c path="howler.Howler"/>
</f></volume></overloads>
		</volume>
		<mute public="1" set="method" static="1"><f a=""><c path="howler.Howler"/></f></mute>
		<unmute public="1" set="method" static="1"><f a=""><c path="howler.Howler"/></f></unmute>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":native"><e>"window.Howler"</e></m>
		</meta>
	</class>
	<class path="js.Error" params="" file="C:\HaxeToolkit\haxe\std/js/Error.hx" extern="1">
		<message public="1"><c path="String"/></message>
		<name public="1"><c path="String"/></name>
		<stack public="1" set="null"><c path="String"/></stack>
		<new public="1" set="method"><f a="?message">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":native"><e>"Error"</e></m>
		</meta>
	</class>
	<class path="js._Boot.HaxeError" params="" file="C:\HaxeToolkit\haxe\std/js/Boot.hx" private="1" module="js.Boot">
		<extends path="js.Error"/>
		<val><d/></val>
		<new public="1" set="method" line="28">
			<f a="val">
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="js.Boot" params="" file="C:\HaxeToolkit\haxe\std/js/Boot.hx">
		<getClass set="method" line="83" static="1">
			<f a="o">
				<d/>
				<d/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</getClass>
		<__string_rec set="method" line="98" static="1">
			<f a="o:s">
				<a>
					<toString set="null"><f a=""><c path="String"/></f></toString>
					<length set="null"><x path="Int"/></length>
					<hasOwnProperty set="null"><f a="">
	<c path="String"/>
	<x path="Bool"/>
</f></hasOwnProperty>
					<__enum__ set="null"><x path="Bool"/></__enum__>
				</a>
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":ifFeature"><e>"has_enum"</e></m>
			</meta>
		</__string_rec>
		<__interfLoop set="method" line="170" static="1"><f a="cc:cl">
	<d/>
	<d/>
	<x path="Bool"/>
</f></__interfLoop>
		<__instanceof set="method" line="185" static="1">
			<f a="o:cl">
				<d/>
				<d/>
				<x path="Bool"/>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":ifFeature"><e>"typed_catch"</e></m>
			</meta>
		</__instanceof>
		<__cast set="method" line="224" static="1">
			<f a="o:t">
				<d/>
				<d/>
				<unknown/>
			</f>
			<meta><m n=":ifFeature"><e>"typed_cast"</e></m></meta>
		</__cast>
		<__toStr line="229" static="1">
			<a><call set="null"><f a="">
	<d/>
	<a><slice set="null"><f a=":">
	<x path="Int"/>
	<x path="Int"/>
	<unknown/>
</f></slice></a>
</f></call></a>
			<meta><m n=":has_untyped"/></meta>
		</__toStr>
		<__nativeClassName set="method" line="231" static="1">
			<f a="o">
				<d/>
				<c path="String"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</__nativeClassName>
		<__isNativeObj set="method" line="241" static="1"><f a="o">
	<d/>
	<x path="Bool"/>
</f></__isNativeObj>
		<__resolveNativeClass set="method" line="246" static="1">
			<f a="name">
				<c path="String"/>
				<unknown/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</__resolveNativeClass>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":dox"><e>hide</e></m>
		</meta>
	</class>
	<class path="js.Browser" params="" file="C:\HaxeToolkit\haxe\std/js/Browser.hx">
		<window public="1" get="null" set="null" static="1">
			<c path="js.html.Window"/>
			<haxe_doc>The global window object.</haxe_doc>
		</window>
		<document public="1" get="null" set="null" static="1">
			<c path="js.html.HTMLDocument"/>
			<haxe_doc>Shortcut to Window.document.</haxe_doc>
		</document>
		<location public="1" get="null" set="null" static="1">
			<c path="js.html.Location"/>
			<haxe_doc>Shortcut to Window.location.</haxe_doc>
		</location>
		<navigator public="1" get="null" set="null" static="1">
			<c path="js.html.Navigator"/>
			<haxe_doc>Shortcut to Window.navigator.</haxe_doc>
		</navigator>
		<console public="1" get="null" set="null" static="1">
			<c path="js.html.Console"/>
			<haxe_doc>Shortcut to Window.console.</haxe_doc>
		</console>
		<supported public="1" get="null" set="null" static="1">
			<x path="Bool"/>
			<haxe_doc>* True if a window object exists, false otherwise.
	 *
	 * This can be used to check if the code is being executed in a non-browser
	 * environment such as node.js.</haxe_doc>
		</supported>
		<getLocalStorage public="1" set="method" line="61" static="1">
			<f a=""><c path="js.html.Storage"/></f>
			<haxe_doc>* Safely gets the browser's local storage, or returns null if localStorage is unsupported or
	 * disabled.</haxe_doc>
		</getLocalStorage>
		<createXMLHttpRequest public="1" set="method" line="91" static="1">
			<f a=""><c path="js.html.XMLHttpRequest"/></f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>* Creates an XMLHttpRequest, with a fallback to ActiveXObject for ancient versions of Internet
	 * Explorer.</haxe_doc>
		</createXMLHttpRequest>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="js.EvalError" params="" file="C:\HaxeToolkit\haxe\std/js/Error.hx" module="js.Error" extern="1">
		<extends path="js.Error"/>
		<new public="1" set="method"><f a="?message">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":native"><e>"EvalError"</e></m></meta>
	</class>
	<class path="js.RangeError" params="" file="C:\HaxeToolkit\haxe\std/js/Error.hx" module="js.Error" extern="1">
		<extends path="js.Error"/>
		<new public="1" set="method"><f a="?message">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":native"><e>"RangeError"</e></m></meta>
	</class>
	<class path="js.ReferenceError" params="" file="C:\HaxeToolkit\haxe\std/js/Error.hx" module="js.Error" extern="1">
		<extends path="js.Error"/>
		<new public="1" set="method"><f a="?message">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":native"><e>"ReferenceError"</e></m></meta>
	</class>
	<class path="js.SyntaxError" params="" file="C:\HaxeToolkit\haxe\std/js/Error.hx" module="js.Error" extern="1">
		<extends path="js.Error"/>
		<new public="1" set="method"><f a="?message">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":native"><e>"SyntaxError"</e></m></meta>
	</class>
	<class path="js.TypeError" params="" file="C:\HaxeToolkit\haxe\std/js/Error.hx" module="js.Error" extern="1">
		<extends path="js.Error"/>
		<new public="1" set="method"><f a="?message">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":native"><e>"TypeError"</e></m></meta>
	</class>
	<class path="js.URIError" params="" file="C:\HaxeToolkit\haxe\std/js/Error.hx" module="js.Error" extern="1">
		<extends path="js.Error"/>
		<new public="1" set="method"><f a="?message">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":native"><e>"URIError"</e></m></meta>
	</class>
	<class path="js.Promise" params="T" file="C:\HaxeToolkit\haxe\std/js/Promise.hx" extern="1">
		<resolve public="1" params="T" set="method" static="1">
			<f a="value">
				<c path="resolve.T"/>
				<c path="js.Promise"><c path="resolve.T"/></c>
			</f>
			<overloads>
				<resolve public="1" params="T" set="method"><f a="promise">
	<c path="js.Promise"><c path="resolve.T"/></c>
	<c path="js.Promise"><c path="resolve.T"/></c>
</f></resolve>
				<resolve public="1" params="T" set="method"><f a="thenable">
	<t path="js.Thenable"><c path="resolve.T"/></t>
	<c path="js.Promise"><c path="resolve.T"/></c>
</f></resolve>
			</overloads>
		</resolve>
		<reject public="1" params="T" set="method" static="1"><f a="?value">
	<d/>
	<c path="js.Promise"><c path="reject.T"/></c>
</f></reject>
		<all public="1" set="method" static="1"><f a="iterable">
	<c path="Array"><d/></c>
	<c path="js.Promise"><c path="Array"><d/></c></c>
</f></all>
		<race public="1" set="method" static="1"><f a="iterable">
	<c path="Array"><d/></c>
	<c path="js.Promise"><d/></c>
</f></race>
		<then public="1" params="TOut" set="method"><f a="?fulfillCallback:?rejectCallback">
	<t path="js.PromiseCallback">
		<c path="js.Promise.T"/>
		<c path="then.TOut"/>
	</t>
	<x path="haxe.extern.EitherType">
		<f a="">
			<d/>
			<x path="Void"/>
		</f>
		<t path="js.PromiseCallback">
			<d/>
			<c path="then.TOut"/>
		</t>
	</x>
	<c path="js.Promise"><c path="then.TOut"/></c>
</f></then>
		<catchError public="1" params="TOut" set="method">
			<f a="rejectCallback">
				<x path="haxe.extern.EitherType">
					<f a="">
						<d/>
						<x path="Void"/>
					</f>
					<t path="js.PromiseCallback">
						<d/>
						<c path="catchError.TOut"/>
					</t>
				</x>
				<c path="js.Promise"><c path="catchError.TOut"/></c>
			</f>
			<meta><m n=":native"><e>"catch"</e></m></meta>
		</catchError>
		<new public="1" set="method">
			<f a="init">
				<f a=":">
					<f a="">
						<c path="js.Promise.T"/>
						<x path="Void"/>
					</f>
					<f a="">
						<d/>
						<x path="Void"/>
					</f>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</new>
		<meta><m n=":native"><e>"Promise"</e></m></meta>
	</class>
	<typedef path="js.PromiseCallback" params="T:TOut" file="C:\HaxeToolkit\haxe\std/js/Promise.hx" module="js.Promise"><x path="haxe.extern.EitherType">
	<f a="">
		<c path="js.PromiseCallback.T"/>
		<c path="js.PromiseCallback.TOut"/>
	</f>
	<f a="">
		<c path="js.PromiseCallback.T"/>
		<c path="js.Promise"><c path="js.PromiseCallback.TOut"/></c>
	</f>
</x></typedef>
	<typedef path="js.Thenable" params="T" file="C:\HaxeToolkit\haxe\std/js/Promise.hx" module="js.Promise"><a><then><x path="haxe.extern.EitherType">
	<f a=":">
		<f a="">
			<c path="js.Thenable.T"/>
			<x path="Void"/>
		</f>
		<f a="">
			<d/>
			<x path="Void"/>
		</f>
		<x path="Void"/>
	</f>
	<f a="">
		<f a="">
			<c path="js.Thenable.T"/>
			<x path="Void"/>
		</f>
		<x path="Void"/>
	</f>
</x></then></a></typedef>
	<class path="js.RegExpMatch" params="" file="C:\HaxeToolkit\haxe\std/js/RegExp.hx" module="js.RegExp" extern="1">
		<extends path="Array"><c path="String"/></extends>
		<index public="1"><x path="Int"/></index>
		<input public="1"><c path="String"/></input>
	</class>
	<abstract path="js.html.AlignSetting" params="" file="C:\HaxeToolkit\haxe\std/js/html/AlignSetting.hx">
		<this><c path="String"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="js.html._AlignSetting.AlignSetting_Impl_" params="" file="C:\HaxeToolkit\haxe\std/js/html/AlignSetting.hx" private="1" module="js.html.AlignSetting"><meta>
	<m n=":keep"/>
	<m n=":enum"/>
</meta></class></impl>
	</abstract>
	<class path="js.html.EventTarget" params="" file="C:\HaxeToolkit\haxe\std/js/html/EventTarget.hx" extern="1">
		<addEventListener public="1" set="method">
			<f a="type:listener:?capture" v="::false">
				<c path="String"/>
				<x path="haxe.Function"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{capture:false}</e></m></meta>
			<haxe_doc>@throws DOMError</haxe_doc>
			<overloads><addEventListener public="1" set="method">
	<f a="type:listener:?capture:?wantsUntrusted" v="::false:">
		<c path="String"/>
		<c path="js.html.EventListener"/>
		<x path="Bool"/>
		<x path="Bool"/>
		<x path="Void"/>
	</f>
	<meta><m n=":value"><e>{capture:false}</e></m></meta>
	<haxe_doc>@throws DOMError</haxe_doc>
</addEventListener></overloads>
		</addEventListener>
		<removeEventListener public="1" set="method">
			<f a="type:listener:?capture" v="::false">
				<c path="String"/>
				<x path="haxe.Function"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{capture:false}</e></m></meta>
			<haxe_doc>@throws DOMError</haxe_doc>
			<overloads><removeEventListener public="1" set="method">
	<f a="type:listener:?capture" v="::false">
		<c path="String"/>
		<c path="js.html.EventListener"/>
		<x path="Bool"/>
		<x path="Void"/>
	</f>
	<meta><m n=":value"><e>{capture:false}</e></m></meta>
	<haxe_doc>@throws DOMError</haxe_doc>
</removeEventListener></overloads>
		</removeEventListener>
		<dispatchEvent public="1" set="method">
			<f a="event">
				<c path="js.html.Event"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</dispatchEvent>
		<meta><m n=":native"><e>"EventTarget"</e></m></meta>
	</class>
	<class path="js.html.Node" params="" file="C:\HaxeToolkit\haxe\std/js/html/Node.hx" extern="1">
		<extends path="js.html.EventTarget"/>
		<ELEMENT_NODE public="1" get="inline" set="null" expr="1" line="30" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</ELEMENT_NODE>
		<ATTRIBUTE_NODE public="1" get="inline" set="null" expr="2" line="31" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2</e></m></meta>
		</ATTRIBUTE_NODE>
		<TEXT_NODE public="1" get="inline" set="null" expr="3" line="32" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3</e></m></meta>
		</TEXT_NODE>
		<CDATA_SECTION_NODE public="1" get="inline" set="null" expr="4" line="33" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>4</e></m></meta>
		</CDATA_SECTION_NODE>
		<ENTITY_REFERENCE_NODE public="1" get="inline" set="null" expr="5" line="34" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>5</e></m></meta>
		</ENTITY_REFERENCE_NODE>
		<ENTITY_NODE public="1" get="inline" set="null" expr="6" line="35" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>6</e></m></meta>
		</ENTITY_NODE>
		<PROCESSING_INSTRUCTION_NODE public="1" get="inline" set="null" expr="7" line="36" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>7</e></m></meta>
		</PROCESSING_INSTRUCTION_NODE>
		<COMMENT_NODE public="1" get="inline" set="null" expr="8" line="37" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>8</e></m></meta>
		</COMMENT_NODE>
		<DOCUMENT_NODE public="1" get="inline" set="null" expr="9" line="38" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>9</e></m></meta>
		</DOCUMENT_NODE>
		<DOCUMENT_TYPE_NODE public="1" get="inline" set="null" expr="10" line="39" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>10</e></m></meta>
		</DOCUMENT_TYPE_NODE>
		<DOCUMENT_FRAGMENT_NODE public="1" get="inline" set="null" expr="11" line="40" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>11</e></m></meta>
		</DOCUMENT_FRAGMENT_NODE>
		<NOTATION_NODE public="1" get="inline" set="null" expr="12" line="41" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>12</e></m></meta>
		</NOTATION_NODE>
		<DOCUMENT_POSITION_DISCONNECTED public="1" get="inline" set="null" expr="1" line="42" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</DOCUMENT_POSITION_DISCONNECTED>
		<DOCUMENT_POSITION_PRECEDING public="1" get="inline" set="null" expr="2" line="43" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2</e></m></meta>
		</DOCUMENT_POSITION_PRECEDING>
		<DOCUMENT_POSITION_FOLLOWING public="1" get="inline" set="null" expr="4" line="44" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>4</e></m></meta>
		</DOCUMENT_POSITION_FOLLOWING>
		<DOCUMENT_POSITION_CONTAINS public="1" get="inline" set="null" expr="8" line="45" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>8</e></m></meta>
		</DOCUMENT_POSITION_CONTAINS>
		<DOCUMENT_POSITION_CONTAINED_BY public="1" get="inline" set="null" expr="16" line="46" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>16</e></m></meta>
		</DOCUMENT_POSITION_CONTAINED_BY>
		<DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC public="1" get="inline" set="null" expr="32" line="47" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>32</e></m></meta>
		</DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC>
		<nodeType public="1" set="null"><x path="Int"/></nodeType>
		<nodeName public="1" set="null"><c path="String"/></nodeName>
		<baseURI public="1" set="null"><c path="String"/></baseURI>
		<ownerDocument public="1" set="null"><c path="js.html.HTMLDocument"/></ownerDocument>
		<parentNode public="1" set="null"><c path="js.html.Node"/></parentNode>
		<parentElement public="1" set="null"><c path="js.html.Element"/></parentElement>
		<childNodes public="1" set="null"><c path="js.html.NodeList"/></childNodes>
		<firstChild public="1" set="null"><c path="js.html.Node"/></firstChild>
		<lastChild public="1" set="null"><c path="js.html.Node"/></lastChild>
		<previousSibling public="1" set="null"><c path="js.html.Node"/></previousSibling>
		<nextSibling public="1" set="null"><c path="js.html.Node"/></nextSibling>
		<nodeValue public="1"><c path="String"/></nodeValue>
		<textContent public="1"><c path="String"/></textContent>
		<namespaceURI public="1" set="null"><c path="String"/></namespaceURI>
		<prefix public="1" set="null"><c path="String"/></prefix>
		<localName public="1" set="null"><c path="String"/></localName>
		<hasChildNodes public="1" set="method"><f a=""><x path="Bool"/></f></hasChildNodes>
		<insertBefore public="1" set="method">
			<f a="node:child">
				<c path="js.html.Node"/>
				<c path="js.html.Node"/>
				<c path="js.html.Node"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</insertBefore>
		<appendChild public="1" set="method">
			<f a="node">
				<c path="js.html.Node"/>
				<c path="js.html.Node"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</appendChild>
		<replaceChild public="1" set="method">
			<f a="node:child">
				<c path="js.html.Node"/>
				<c path="js.html.Node"/>
				<c path="js.html.Node"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</replaceChild>
		<removeChild public="1" set="method">
			<f a="child">
				<c path="js.html.Node"/>
				<c path="js.html.Node"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</removeChild>
		<normalize public="1" set="method"><f a=""><x path="Void"/></f></normalize>
		<cloneNode public="1" set="method">
			<f a="?deep" v="false">
				<x path="Bool"/>
				<c path="js.html.Node"/>
			</f>
			<meta><m n=":value"><e>{deep:false}</e></m></meta>
			<haxe_doc>@throws DOMError</haxe_doc>
		</cloneNode>
		<isEqualNode public="1" set="method"><f a="node">
	<c path="js.html.Node"/>
	<x path="Bool"/>
</f></isEqualNode>
		<compareDocumentPosition public="1" set="method"><f a="other">
	<c path="js.html.Node"/>
	<x path="Int"/>
</f></compareDocumentPosition>
		<contains public="1" set="method"><f a="other">
	<c path="js.html.Node"/>
	<x path="Bool"/>
</f></contains>
		<lookupPrefix public="1" set="method"><f a="namespace_">
	<c path="String"/>
	<c path="String"/>
</f></lookupPrefix>
		<lookupNamespaceURI public="1" set="method"><f a="prefix">
	<c path="String"/>
	<c path="String"/>
</f></lookupNamespaceURI>
		<isDefaultNamespace public="1" set="method"><f a="namespace_">
	<c path="String"/>
	<x path="Bool"/>
</f></isDefaultNamespace>
		<meta><m n=":native"><e>"Node"</e></m></meta>
	</class>
	<class path="js.html.DOMElement" params="" file="C:\HaxeToolkit\haxe\std/js/html/DOMElement.hx" extern="1">
		<extends path="js.html.Node"/>
		<tagName public="1" set="null"><c path="String"/></tagName>
		<id public="1"><c path="String"/></id>
		<className public="1"><c path="String"/></className>
		<classList public="1" set="null"><c path="js.html.DOMTokenList"/></classList>
		<attributes public="1" set="null"><c path="js.html.NamedNodeMap"/></attributes>
		<onwheel public="1"><x path="haxe.Function"/></onwheel>
		<title public="1"><c path="String"/></title>
		<lang public="1"><c path="String"/></lang>
		<dir public="1"><c path="String"/></dir>
		<dataset public="1" set="null"><c path="js.html.DOMStringMap"/></dataset>
		<itemScope public="1"><x path="Bool"/></itemScope>
		<itemType public="1" set="null"><c path="js.html.DOMSettableTokenList"/></itemType>
		<itemId public="1"><c path="String"/></itemId>
		<itemRef public="1" set="null"><c path="js.html.DOMSettableTokenList"/></itemRef>
		<itemProp public="1" set="null"><c path="js.html.DOMSettableTokenList"/></itemProp>
		<properties public="1" set="null"><c path="js.html.HTMLPropertiesCollection"/></properties>
		<itemValue public="1"><d/></itemValue>
		<hidden public="1"><x path="Bool"/></hidden>
		<tabIndex public="1"><x path="Int"/></tabIndex>
		<accessKey public="1"><c path="String"/></accessKey>
		<accessKeyLabel public="1" set="null"><c path="String"/></accessKeyLabel>
		<draggable public="1"><x path="Bool"/></draggable>
		<contentEditable public="1"><c path="String"/></contentEditable>
		<isContentEditable public="1" set="null"><x path="Bool"/></isContentEditable>
		<contextMenu public="1" set="null"><c path="js.html.MenuElement"/></contextMenu>
		<spellcheck public="1"><x path="Bool"/></spellcheck>
		<style public="1" set="null"><c path="js.html.CSSStyleDeclaration"/></style>
		<oncopy public="1"><x path="haxe.Function"/></oncopy>
		<oncut public="1"><x path="haxe.Function"/></oncut>
		<onpaste public="1"><x path="haxe.Function"/></onpaste>
		<innerText public="1"><c path="String"/></innerText>
		<offsetParent public="1" set="null"><c path="js.html.Element"/></offsetParent>
		<offsetTop public="1" set="null"><x path="Int"/></offsetTop>
		<offsetLeft public="1" set="null"><x path="Int"/></offsetLeft>
		<offsetWidth public="1" set="null"><x path="Int"/></offsetWidth>
		<offsetHeight public="1" set="null"><x path="Int"/></offsetHeight>
		<scrollTop public="1"><x path="Int"/></scrollTop>
		<scrollLeft public="1"><x path="Int"/></scrollLeft>
		<scrollWidth public="1" set="null"><x path="Int"/></scrollWidth>
		<scrollHeight public="1" set="null"><x path="Int"/></scrollHeight>
		<clientTop public="1" set="null"><x path="Int"/></clientTop>
		<clientLeft public="1" set="null"><x path="Int"/></clientLeft>
		<clientWidth public="1" set="null"><x path="Int"/></clientWidth>
		<clientHeight public="1" set="null"><x path="Int"/></clientHeight>
		<scrollTopMax public="1" set="null"><x path="Int"/></scrollTopMax>
		<scrollLeftMax public="1" set="null"><x path="Int"/></scrollLeftMax>
		<innerHTML public="1"><c path="String"/></innerHTML>
		<outerHTML public="1"><c path="String"/></outerHTML>
		<shadowRoot public="1" set="null"><c path="js.html.ShadowRoot"/></shadowRoot>
		<onabort public="1"><x path="haxe.Function"/></onabort>
		<onblur public="1"><x path="haxe.Function"/></onblur>
		<onfocus public="1"><x path="haxe.Function"/></onfocus>
		<oncanplay public="1"><x path="haxe.Function"/></oncanplay>
		<oncanplaythrough public="1"><x path="haxe.Function"/></oncanplaythrough>
		<onchange public="1"><x path="haxe.Function"/></onchange>
		<onclick public="1"><x path="haxe.Function"/></onclick>
		<oncontextmenu public="1"><x path="haxe.Function"/></oncontextmenu>
		<ondblclick public="1"><x path="haxe.Function"/></ondblclick>
		<ondrag public="1"><x path="haxe.Function"/></ondrag>
		<ondragend public="1"><x path="haxe.Function"/></ondragend>
		<ondragenter public="1"><x path="haxe.Function"/></ondragenter>
		<ondragleave public="1"><x path="haxe.Function"/></ondragleave>
		<ondragover public="1"><x path="haxe.Function"/></ondragover>
		<ondragstart public="1"><x path="haxe.Function"/></ondragstart>
		<ondrop public="1"><x path="haxe.Function"/></ondrop>
		<ondurationchange public="1"><x path="haxe.Function"/></ondurationchange>
		<onemptied public="1"><x path="haxe.Function"/></onemptied>
		<onended public="1"><x path="haxe.Function"/></onended>
		<oninput public="1"><x path="haxe.Function"/></oninput>
		<oninvalid public="1"><x path="haxe.Function"/></oninvalid>
		<onkeydown public="1"><x path="haxe.Function"/></onkeydown>
		<onkeypress public="1"><x path="haxe.Function"/></onkeypress>
		<onkeyup public="1"><x path="haxe.Function"/></onkeyup>
		<onload public="1"><x path="haxe.Function"/></onload>
		<onloadeddata public="1"><x path="haxe.Function"/></onloadeddata>
		<onloadedmetadata public="1"><x path="haxe.Function"/></onloadedmetadata>
		<onloadstart public="1"><x path="haxe.Function"/></onloadstart>
		<onmousedown public="1"><x path="haxe.Function"/></onmousedown>
		<onmouseenter public="1"><x path="haxe.Function"/></onmouseenter>
		<onmouseleave public="1"><x path="haxe.Function"/></onmouseleave>
		<onmousemove public="1"><x path="haxe.Function"/></onmousemove>
		<onmouseout public="1"><x path="haxe.Function"/></onmouseout>
		<onmouseover public="1"><x path="haxe.Function"/></onmouseover>
		<onmouseup public="1"><x path="haxe.Function"/></onmouseup>
		<onpause public="1"><x path="haxe.Function"/></onpause>
		<onplay public="1"><x path="haxe.Function"/></onplay>
		<onplaying public="1"><x path="haxe.Function"/></onplaying>
		<onprogress public="1"><x path="haxe.Function"/></onprogress>
		<onratechange public="1"><x path="haxe.Function"/></onratechange>
		<onreset public="1"><x path="haxe.Function"/></onreset>
		<onscroll public="1"><x path="haxe.Function"/></onscroll>
		<onseeked public="1"><x path="haxe.Function"/></onseeked>
		<onseeking public="1"><x path="haxe.Function"/></onseeking>
		<onselect public="1"><x path="haxe.Function"/></onselect>
		<onshow public="1"><x path="haxe.Function"/></onshow>
		<onstalled public="1"><x path="haxe.Function"/></onstalled>
		<onsubmit public="1"><x path="haxe.Function"/></onsubmit>
		<onsuspend public="1"><x path="haxe.Function"/></onsuspend>
		<ontimeupdate public="1"><x path="haxe.Function"/></ontimeupdate>
		<onvolumechange public="1"><x path="haxe.Function"/></onvolumechange>
		<onwaiting public="1"><x path="haxe.Function"/></onwaiting>
		<onpointercancel public="1"><x path="haxe.Function"/></onpointercancel>
		<onpointerdown public="1"><x path="haxe.Function"/></onpointerdown>
		<onpointerup public="1"><x path="haxe.Function"/></onpointerup>
		<onpointermove public="1"><x path="haxe.Function"/></onpointermove>
		<onpointerout public="1"><x path="haxe.Function"/></onpointerout>
		<onpointerover public="1"><x path="haxe.Function"/></onpointerover>
		<onpointerenter public="1"><x path="haxe.Function"/></onpointerenter>
		<onpointerleave public="1"><x path="haxe.Function"/></onpointerleave>
		<ongotpointercapture public="1"><x path="haxe.Function"/></ongotpointercapture>
		<onlostpointercapture public="1"><x path="haxe.Function"/></onlostpointercapture>
		<onpointerlockchange public="1"><x path="haxe.Function"/></onpointerlockchange>
		<onpointerlockerror public="1"><x path="haxe.Function"/></onpointerlockerror>
		<previousElementSibling public="1" set="null"><c path="js.html.Element"/></previousElementSibling>
		<nextElementSibling public="1" set="null"><c path="js.html.Element"/></nextElementSibling>
		<onerror public="1"><x path="haxe.Function"/></onerror>
		<children public="1" set="null"><c path="js.html.HTMLCollection"/></children>
		<firstElementChild public="1" set="null"><c path="js.html.Element"/></firstElementChild>
		<lastElementChild public="1" set="null"><c path="js.html.Element"/></lastElementChild>
		<childElementCount public="1" set="null"><x path="Int"/></childElementCount>
		<ontouchstart public="1"><x path="haxe.Function"/></ontouchstart>
		<ontouchend public="1"><x path="haxe.Function"/></ontouchend>
		<ontouchmove public="1"><x path="haxe.Function"/></ontouchmove>
		<ontouchcancel public="1"><x path="haxe.Function"/></ontouchcancel>
		<getAttribute public="1" set="method"><f a="name">
	<c path="String"/>
	<c path="String"/>
</f></getAttribute>
		<getAttributeNS public="1" set="method"><f a="namespace_:localName">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
</f></getAttributeNS>
		<setAttribute public="1" set="method">
			<f a="name:value">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</setAttribute>
		<setAttributeNS public="1" set="method">
			<f a="namespace_:name:value">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</setAttributeNS>
		<removeAttribute public="1" set="method">
			<f a="name">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</removeAttribute>
		<removeAttributeNS public="1" set="method">
			<f a="namespace_:localName">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</removeAttributeNS>
		<hasAttribute public="1" set="method"><f a="name">
	<c path="String"/>
	<x path="Bool"/>
</f></hasAttribute>
		<hasAttributeNS public="1" set="method"><f a="namespace_:localName">
	<c path="String"/>
	<c path="String"/>
	<x path="Bool"/>
</f></hasAttributeNS>
		<hasAttributes public="1" set="method"><f a=""><x path="Bool"/></f></hasAttributes>
		<closest public="1" set="method">
			<f a="selector">
				<c path="String"/>
				<c path="js.html.Element"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</closest>
		<matches public="1" set="method">
			<f a="selector">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</matches>
		<getElementsByTagName public="1" set="method"><f a="localName">
	<c path="String"/>
	<c path="js.html.HTMLCollection"/>
</f></getElementsByTagName>
		<getElementsByTagNameNS public="1" set="method">
			<f a="namespace_:localName">
				<c path="String"/>
				<c path="String"/>
				<c path="js.html.HTMLCollection"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</getElementsByTagNameNS>
		<getElementsByClassName public="1" set="method"><f a="classNames">
	<c path="String"/>
	<c path="js.html.HTMLCollection"/>
</f></getElementsByClassName>
		<setPointerCapture public="1" set="method">
			<f a="pointerId">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</setPointerCapture>
		<releasePointerCapture public="1" set="method">
			<f a="pointerId">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</releasePointerCapture>
		<setCapture public="1" set="method">
			<f a="?retargetToElement" v="false">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{retargetToElement:false}</e></m></meta>
		</setCapture>
		<releaseCapture public="1" set="method"><f a=""><x path="Void"/></f></releaseCapture>
		<requestPointerLock public="1" set="method"><f a=""><x path="Void"/></f></requestPointerLock>
		<getAttributeNode public="1" set="method"><f a="name">
	<c path="String"/>
	<c path="js.html.Attr"/>
</f></getAttributeNode>
		<setAttributeNode public="1" set="method">
			<f a="newAttr">
				<c path="js.html.Attr"/>
				<c path="js.html.Attr"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</setAttributeNode>
		<removeAttributeNode public="1" set="method">
			<f a="oldAttr">
				<c path="js.html.Attr"/>
				<c path="js.html.Attr"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</removeAttributeNode>
		<getAttributeNodeNS public="1" set="method"><f a="namespaceURI:localName">
	<c path="String"/>
	<c path="String"/>
	<c path="js.html.Attr"/>
</f></getAttributeNodeNS>
		<setAttributeNodeNS public="1" set="method">
			<f a="newAttr">
				<c path="js.html.Attr"/>
				<c path="js.html.Attr"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</setAttributeNodeNS>
		<requestFullscreen public="1" set="method"><f a=""><x path="Void"/></f></requestFullscreen>
		<click public="1" set="method"><f a=""><x path="Void"/></f></click>
		<focus public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</focus>
		<blur public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</blur>
		<getClientRects public="1" set="method"><f a=""><c path="js.html.DOMRectList"/></f></getClientRects>
		<getBoundingClientRect public="1" set="method"><f a=""><c path="js.html.DOMRect"/></f></getBoundingClientRect>
		<scrollIntoView public="1" set="method">
			<f a="?options">
				<t path="js.html.ScrollIntoViewOptions"/>
				<x path="Void"/>
			</f>
			<overloads><scrollIntoView public="1" set="method"><f a="top">
	<x path="Bool"/>
	<x path="Void"/>
</f></scrollIntoView></overloads>
		</scrollIntoView>
		<scroll public="1" set="method">
			<f a="?options">
				<t path="js.html.ScrollToOptions"/>
				<x path="Void"/>
			</f>
			<overloads><scroll public="1" set="method"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></scroll></overloads>
		</scroll>
		<scrollTo public="1" set="method">
			<f a="?options">
				<t path="js.html.ScrollToOptions"/>
				<x path="Void"/>
			</f>
			<overloads><scrollTo public="1" set="method"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></scrollTo></overloads>
		</scrollTo>
		<scrollBy public="1" set="method">
			<f a="?options">
				<t path="js.html.ScrollToOptions"/>
				<x path="Void"/>
			</f>
			<overloads><scrollBy public="1" set="method"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></scrollBy></overloads>
		</scrollBy>
		<insertAdjacentHTML public="1" set="method">
			<f a="position:text">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</insertAdjacentHTML>
		<querySelector public="1" set="method">
			<f a="selectors">
				<c path="String"/>
				<c path="js.html.Element"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</querySelector>
		<querySelectorAll public="1" set="method">
			<f a="selectors">
				<c path="String"/>
				<c path="js.html.NodeList"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</querySelectorAll>
		<createShadowRoot public="1" set="method">
			<f a=""><c path="js.html.ShadowRoot"/></f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</createShadowRoot>
		<getDestinationInsertionPoints public="1" set="method"><f a=""><c path="js.html.NodeList"/></f></getDestinationInsertionPoints>
		<getAnimationPlayers public="1" set="method"><f a=""><c path="Array"><c path="js.html.AnimationPlayer"/></c></f></getAnimationPlayers>
		<remove public="1" set="method"><f a=""><x path="Void"/></f></remove>
		<convertQuadFromNode public="1" set="method">
			<f a="quad:from:?options">
				<c path="js.html.DOMQuad"/>
				<x path="haxe.extern.EitherType">
					<c path="js.html.Text"/>
					<x path="haxe.extern.EitherType">
						<c path="js.html.Element"/>
						<c path="js.html.HTMLDocument"/>
					</x>
				</x>
				<t path="js.html.ConvertCoordinateOptions"/>
				<c path="js.html.DOMQuad"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</convertQuadFromNode>
		<convertRectFromNode public="1" set="method">
			<f a="rect:from:?options">
				<c path="js.html.DOMRectReadOnly"/>
				<x path="haxe.extern.EitherType">
					<c path="js.html.Text"/>
					<x path="haxe.extern.EitherType">
						<c path="js.html.Element"/>
						<c path="js.html.HTMLDocument"/>
					</x>
				</x>
				<t path="js.html.ConvertCoordinateOptions"/>
				<c path="js.html.DOMQuad"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</convertRectFromNode>
		<convertPointFromNode public="1" set="method">
			<f a="point:from:?options">
				<t path="js.html.DOMPointInit"/>
				<x path="haxe.extern.EitherType">
					<c path="js.html.Text"/>
					<x path="haxe.extern.EitherType">
						<c path="js.html.Element"/>
						<c path="js.html.HTMLDocument"/>
					</x>
				</x>
				<t path="js.html.ConvertCoordinateOptions"/>
				<c path="js.html.DOMPoint"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</convertPointFromNode>
		<meta><m n=":native"><e>"Element"</e></m></meta>
	</class>
	<class path="js.html.Element" params="" file="C:\HaxeToolkit\haxe\std/js/html/Element.hx" extern="1">
		<extends path="js.html.DOMElement"/>
		<meta><m n=":native"><e>"HTMLElement"</e></m></meta>
	</class>
	<class path="js.html.AnchorElement" params="" file="C:\HaxeToolkit\haxe\std/js/html/AnchorElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<target public="1"><c path="String"/></target>
		<download public="1"><c path="String"/></download>
		<ping public="1"><c path="String"/></ping>
		<rel public="1"><c path="String"/></rel>
		<relList public="1" set="null"><c path="js.html.DOMTokenList"/></relList>
		<hreflang public="1"><c path="String"/></hreflang>
		<type public="1"><c path="String"/></type>
		<text public="1"><c path="String"/></text>
		<coords public="1"><c path="String"/></coords>
		<charset public="1"><c path="String"/></charset>
		<name public="1"><c path="String"/></name>
		<rev public="1"><c path="String"/></rev>
		<shape public="1"><c path="String"/></shape>
		<href public="1"><c path="String"/></href>
		<origin public="1" set="null"><c path="String"/></origin>
		<protocol public="1"><c path="String"/></protocol>
		<username public="1"><c path="String"/></username>
		<password public="1"><c path="String"/></password>
		<host public="1"><c path="String"/></host>
		<hostname public="1"><c path="String"/></hostname>
		<port public="1"><c path="String"/></port>
		<pathname public="1"><c path="String"/></pathname>
		<search public="1"><c path="String"/></search>
		<hash public="1"><c path="String"/></hash>
		<searchParams public="1"><c path="js.html.URLSearchParams"/></searchParams>
		<meta><m n=":native"><e>"HTMLAnchorElement"</e></m></meta>
	</class>
	<class path="js.html.Animation" params="" file="C:\HaxeToolkit\haxe\std/js/html/Animation.hx" extern="1">
		<effect public="1" set="null"><c path="js.html.AnimationEffect"/></effect>
		<target public="1" set="null"><c path="js.html.Element"/></target>
		<meta><m n=":native"><e>"Animation"</e></m></meta>
	</class>
	<class path="js.html.AnimationEffect" params="" file="C:\HaxeToolkit\haxe\std/js/html/AnimationEffect.hx" extern="1">
		<name public="1" set="null"><c path="String"/></name>
		<meta><m n=":native"><e>"AnimationEffect"</e></m></meta>
	</class>
	<abstract path="js.html.AnimationPlayState" params="" file="C:\HaxeToolkit\haxe\std/js/html/AnimationPlayState.hx">
		<this><c path="String"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="js.html._AnimationPlayState.AnimationPlayState_Impl_" params="" file="C:\HaxeToolkit\haxe\std/js/html/AnimationPlayState.hx" private="1" module="js.html.AnimationPlayState"><meta>
	<m n=":keep"/>
	<m n=":enum"/>
</meta></class></impl>
	</abstract>
	<class path="js.html.AnimationPlayer" params="" file="C:\HaxeToolkit\haxe\std/js/html/AnimationPlayer.hx" extern="1">
		<source public="1" set="null"><c path="js.html.Animation"/></source>
		<timeline public="1" set="null"><c path="js.html.AnimationTimeline"/></timeline>
		<startTime public="1" set="null"><x path="Float"/></startTime>
		<currentTime public="1" set="null"><x path="Float"/></currentTime>
		<playState public="1" set="null"><x path="js.html.AnimationPlayState"/></playState>
		<play public="1" set="method"><f a=""><x path="Void"/></f></play>
		<pause public="1" set="method"><f a=""><x path="Void"/></f></pause>
		<meta><m n=":native"><e>"AnimationPlayer"</e></m></meta>
	</class>
	<class path="js.html.AnimationTimeline" params="" file="C:\HaxeToolkit\haxe\std/js/html/AnimationTimeline.hx" extern="1">
		<currentTime public="1" set="null"><x path="Float"/></currentTime>
		<meta><m n=":native"><e>"AnimationTimeline"</e></m></meta>
	</class>
	<class path="js.html.AppletElement" params="" file="C:\HaxeToolkit\haxe\std/js/html/AppletElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<align public="1"><c path="String"/></align>
		<alt public="1"><c path="String"/></alt>
		<archive public="1"><c path="String"/></archive>
		<code public="1"><c path="String"/></code>
		<codeBase public="1"><c path="String"/></codeBase>
		<height public="1"><c path="String"/></height>
		<hspace public="1"><x path="Int"/></hspace>
		<name public="1"><c path="String"/></name>
		<object public="1"><c path="String"/></object>
		<vspace public="1"><x path="Int"/></vspace>
		<width public="1"><c path="String"/></width>
		<meta><m n=":native"><e>"HTMLAppletElement"</e></m></meta>
	</class>
	<class path="js.html.ApplicationCache" params="" file="C:\HaxeToolkit\haxe\std/js/html/ApplicationCache.hx" extern="1">
		<extends path="js.html.EventTarget"/>
		<UNCACHED public="1" get="inline" set="null" expr="0" line="30" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</UNCACHED>
		<IDLE public="1" get="inline" set="null" expr="1" line="31" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</IDLE>
		<CHECKING public="1" get="inline" set="null" expr="2" line="32" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2</e></m></meta>
		</CHECKING>
		<DOWNLOADING public="1" get="inline" set="null" expr="3" line="33" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3</e></m></meta>
		</DOWNLOADING>
		<UPDATEREADY public="1" get="inline" set="null" expr="4" line="34" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>4</e></m></meta>
		</UPDATEREADY>
		<OBSOLETE public="1" get="inline" set="null" expr="5" line="35" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>5</e></m></meta>
		</OBSOLETE>
		<status public="1" set="null"><x path="Int"/></status>
		<onchecking public="1"><x path="haxe.Function"/></onchecking>
		<onerror public="1"><x path="haxe.Function"/></onerror>
		<onnoupdate public="1"><x path="haxe.Function"/></onnoupdate>
		<ondownloading public="1"><x path="haxe.Function"/></ondownloading>
		<onprogress public="1"><x path="haxe.Function"/></onprogress>
		<onupdateready public="1"><x path="haxe.Function"/></onupdateready>
		<oncached public="1"><x path="haxe.Function"/></oncached>
		<onobsolete public="1"><x path="haxe.Function"/></onobsolete>
		<update public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</update>
		<swapCache public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</swapCache>
		<meta><m n=":native"><e>"ApplicationCache"</e></m></meta>
	</class>
	<class path="js.html.AreaElement" params="" file="C:\HaxeToolkit\haxe\std/js/html/AreaElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<alt public="1"><c path="String"/></alt>
		<coords public="1"><c path="String"/></coords>
		<shape public="1"><c path="String"/></shape>
		<target public="1"><c path="String"/></target>
		<download public="1"><c path="String"/></download>
		<ping public="1"><c path="String"/></ping>
		<rel public="1"><c path="String"/></rel>
		<relList public="1" set="null"><c path="js.html.DOMTokenList"/></relList>
		<noHref public="1"><x path="Bool"/></noHref>
		<href public="1"><c path="String"/></href>
		<origin public="1" set="null"><c path="String"/></origin>
		<protocol public="1"><c path="String"/></protocol>
		<username public="1"><c path="String"/></username>
		<password public="1"><c path="String"/></password>
		<host public="1"><c path="String"/></host>
		<hostname public="1"><c path="String"/></hostname>
		<port public="1"><c path="String"/></port>
		<pathname public="1"><c path="String"/></pathname>
		<search public="1"><c path="String"/></search>
		<hash public="1"><c path="String"/></hash>
		<searchParams public="1"><c path="js.html.URLSearchParams"/></searchParams>
		<meta><m n=":native"><e>"HTMLAreaElement"</e></m></meta>
	</class>
	<class path="js.html.ArrayBuffer" params="" file="C:\HaxeToolkit\haxe\std/js/html/ArrayBuffer.hx" extern="1">
		<isView public="1" set="method" static="1"><f a="value">
	<d/>
	<x path="Bool"/>
</f></isView>
		<byteLength public="1" set="null"><x path="Int"/></byteLength>
		<slice public="1" set="method"><f a="begin:?end">
	<x path="Int"/>
	<x path="Int"/>
	<c path="js.html.ArrayBuffer"/>
</f></slice>
		<new public="1" set="method">
			<f a="length">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</new>
		<meta><m n=":native"><e>"ArrayBuffer"</e></m></meta>
	</class>
	<class path="js.html.ArrayBufferView" params="" file="C:\HaxeToolkit\haxe\std/js/html/ArrayBufferView.hx" extern="1">
		<buffer public="1" set="null"><c path="js.html.ArrayBuffer"/></buffer>
		<byteOffset public="1" set="null"><x path="Int"/></byteOffset>
		<byteLength public="1" set="null"><x path="Int"/></byteLength>
		<meta><m n=":native"><e>"ArrayBufferView"</e></m></meta>
	</class>
	<class path="js.html.Attr" params="" file="C:\HaxeToolkit\haxe\std/js/html/Attr.hx" extern="1">
		<extends path="js.html.Node"/>
		<value public="1"><c path="String"/></value>
		<name public="1" set="null"><c path="String"/></name>
		<specified public="1" set="null"><x path="Bool"/></specified>
		<ownerElement public="1" set="null"><c path="js.html.Element"/></ownerElement>
		<meta><m n=":native"><e>"Attr"</e></m></meta>
	</class>
	<abstract path="js.html.AudioChannel" params="" file="C:\HaxeToolkit\haxe\std/js/html/AudioChannel.hx">
		<this><c path="String"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="js.html._AudioChannel.AudioChannel_Impl_" params="" file="C:\HaxeToolkit\haxe\std/js/html/AudioChannel.hx" private="1" module="js.html.AudioChannel"><meta>
	<m n=":keep"/>
	<m n=":enum"/>
</meta></class></impl>
	</abstract>
	<class path="js.html.MediaElement" params="" file="C:\HaxeToolkit\haxe\std/js/html/MediaElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<NETWORK_EMPTY public="1" get="inline" set="null" expr="0" line="30" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</NETWORK_EMPTY>
		<NETWORK_IDLE public="1" get="inline" set="null" expr="1" line="31" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</NETWORK_IDLE>
		<NETWORK_LOADING public="1" get="inline" set="null" expr="2" line="32" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2</e></m></meta>
		</NETWORK_LOADING>
		<NETWORK_NO_SOURCE public="1" get="inline" set="null" expr="3" line="33" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3</e></m></meta>
		</NETWORK_NO_SOURCE>
		<HAVE_NOTHING public="1" get="inline" set="null" expr="0" line="34" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</HAVE_NOTHING>
		<HAVE_METADATA public="1" get="inline" set="null" expr="1" line="35" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</HAVE_METADATA>
		<HAVE_CURRENT_DATA public="1" get="inline" set="null" expr="2" line="36" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2</e></m></meta>
		</HAVE_CURRENT_DATA>
		<HAVE_FUTURE_DATA public="1" get="inline" set="null" expr="3" line="37" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3</e></m></meta>
		</HAVE_FUTURE_DATA>
		<HAVE_ENOUGH_DATA public="1" get="inline" set="null" expr="4" line="38" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>4</e></m></meta>
		</HAVE_ENOUGH_DATA>
		<error public="1" set="null"><c path="js.html.MediaError"/></error>
		<src public="1"><c path="String"/></src>
		<currentSrc public="1" set="null"><c path="String"/></currentSrc>
		<crossOrigin public="1"><c path="String"/></crossOrigin>
		<networkState public="1" set="null"><x path="Int"/></networkState>
		<preload public="1"><c path="String"/></preload>
		<buffered public="1" set="null"><c path="js.html.TimeRanges"/></buffered>
		<readyState public="1" set="null"><x path="Int"/></readyState>
		<seeking public="1" set="null"><x path="Bool"/></seeking>
		<currentTime public="1"><x path="Float"/></currentTime>
		<duration public="1" set="null"><x path="Float"/></duration>
		<paused public="1" set="null"><x path="Bool"/></paused>
		<defaultPlaybackRate public="1"><x path="Float"/></defaultPlaybackRate>
		<playbackRate public="1"><x path="Float"/></playbackRate>
		<played public="1" set="null"><c path="js.html.TimeRanges"/></played>
		<seekable public="1" set="null"><c path="js.html.TimeRanges"/></seekable>
		<ended public="1" set="null"><x path="Bool"/></ended>
		<autoplay public="1"><x path="Bool"/></autoplay>
		<loop public="1"><x path="Bool"/></loop>
		<controls public="1"><x path="Bool"/></controls>
		<volume public="1"><x path="Float"/></volume>
		<muted public="1"><x path="Bool"/></muted>
		<defaultMuted public="1"><x path="Bool"/></defaultMuted>
		<audioTracks public="1" set="null"><c path="js.html.AudioTrackList"/></audioTracks>
		<videoTracks public="1" set="null"><c path="js.html.VideoTrackList"/></videoTracks>
		<textTracks public="1" set="null"><c path="js.html.TextTrackList"/></textTracks>
		<mediaKeys public="1" set="null"><c path="js.html.MediaKeys"/></mediaKeys>
		<onencrypted public="1"><x path="haxe.Function"/></onencrypted>
		<waitingFor public="1" set="null"><x path="js.html.MediaWaitingFor"/></waitingFor>
		<load public="1" set="method"><f a=""><x path="Void"/></f></load>
		<canPlayType public="1" set="method"><f a="type">
	<c path="String"/>
	<c path="String"/>
</f></canPlayType>
		<fastSeek public="1" set="method">
			<f a="time">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</fastSeek>
		<play public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</play>
		<pause public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</pause>
		<addTextTrack public="1" set="method">
			<f a="kind:?label:?language" v=":&quot;&quot;:&quot;&quot;">
				<x path="js.html.TextTrackKind"/>
				<c path="String"/>
				<c path="String"/>
				<c path="js.html.TextTrack"/>
			</f>
			<meta><m n=":value"><e>{language:"",label:""}</e></m></meta>
		</addTextTrack>
		<setMediaKeys public="1" set="method"><f a="mediaKeys">
	<c path="js.html.MediaKeys"/>
	<c path="js.Promise"><x path="Void"/></c>
</f></setMediaKeys>
		<meta><m n=":native"><e>"HTMLMediaElement"</e></m></meta>
	</class>
	<class path="js.html.AudioElement" params="" file="C:\HaxeToolkit\haxe\std/js/html/AudioElement.hx" extern="1">
		<extends path="js.html.MediaElement"/>
		<meta><m n=":native"><e>"HTMLAudioElement"</e></m></meta>
	</class>
	<class path="js.html.MediaStreamTrack" params="" file="C:\HaxeToolkit\haxe\std/js/html/MediaStreamTrack.hx" extern="1">
		<kind public="1" set="null"><c path="String"/></kind>
		<id public="1" set="null"><c path="String"/></id>
		<label public="1" set="null"><c path="String"/></label>
		<enabled public="1"><x path="Bool"/></enabled>
		<stop public="1" set="method"><f a=""><x path="Void"/></f></stop>
		<meta><m n=":native"><e>"MediaStreamTrack"</e></m></meta>
	</class>
	<class path="js.html.AudioStreamTrack" params="" file="C:\HaxeToolkit\haxe\std/js/html/AudioStreamTrack.hx" extern="1">
		<extends path="js.html.MediaStreamTrack"/>
		<meta><m n=":native"><e>"AudioStreamTrack"</e></m></meta>
	</class>
	<class path="js.html.AudioTrack" params="" file="C:\HaxeToolkit\haxe\std/js/html/AudioTrack.hx" extern="1">
		<id public="1" set="null"><c path="String"/></id>
		<kind public="1" set="null"><c path="String"/></kind>
		<label public="1" set="null"><c path="String"/></label>
		<language public="1" set="null"><c path="String"/></language>
		<enabled public="1"><x path="Bool"/></enabled>
		<meta><m n=":native"><e>"AudioTrack"</e></m></meta>
	</class>
	<class path="js.html.AudioTrackList" params="" file="C:\HaxeToolkit\haxe\std/js/html/AudioTrackList.hx" extern="1">
		<extends path="js.html.EventTarget"/>
		<length public="1" set="null"><x path="Int"/></length>
		<onchange public="1"><x path="haxe.Function"/></onchange>
		<onaddtrack public="1"><x path="haxe.Function"/></onaddtrack>
		<onremovetrack public="1"><x path="haxe.Function"/></onremovetrack>
		<getTrackById public="1" set="method"><f a="id">
	<c path="String"/>
	<c path="js.html.AudioTrack"/>
</f></getTrackById>
		<meta><m n=":native"><e>"AudioTrackList"</e></m></meta>
	</class>
	<class path="js.html.BRElement" params="" file="C:\HaxeToolkit\haxe\std/js/html/BRElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<clear public="1"><c path="String"/></clear>
		<meta><m n=":native"><e>"HTMLBRElement"</e></m></meta>
	</class>
	<class path="js.html.BarProp" params="" file="C:\HaxeToolkit\haxe\std/js/html/BarProp.hx" extern="1">
		<visible public="1"><x path="Bool"/></visible>
		<meta><m n=":native"><e>"BarProp"</e></m></meta>
	</class>
	<class path="js.html.BaseElement" params="" file="C:\HaxeToolkit\haxe\std/js/html/BaseElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<href public="1"><c path="String"/></href>
		<target public="1"><c path="String"/></target>
		<meta><m n=":native"><e>"HTMLBaseElement"</e></m></meta>
	</class>
	<class path="js.html.BatteryManager" params="" file="C:\HaxeToolkit\haxe\std/js/html/BatteryManager.hx" extern="1">
		<extends path="js.html.EventTarget"/>
		<charging public="1" set="null"><x path="Bool"/></charging>
		<chargingTime public="1" set="null"><x path="Float"/></chargingTime>
		<dischargingTime public="1" set="null"><x path="Float"/></dischargingTime>
		<level public="1" set="null"><x path="Float"/></level>
		<onchargingchange public="1"><x path="haxe.Function"/></onchargingchange>
		<onchargingtimechange public="1"><x path="haxe.Function"/></onchargingtimechange>
		<ondischargingtimechange public="1"><x path="haxe.Function"/></ondischargingtimechange>
		<onlevelchange public="1"><x path="haxe.Function"/></onlevelchange>
		<meta><m n=":native"><e>"BatteryManager"</e></m></meta>
	</class>
	<class path="js.html.Blob" params="" file="C:\HaxeToolkit\haxe\std/js/html/Blob.hx" extern="1">
		<size public="1" set="null"><x path="Int"/></size>
		<type public="1" set="null"><c path="String"/></type>
		<slice public="1" set="method">
			<f a="?start:?end:?contentType" v="::&quot;&quot;">
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
				<c path="js.html.Blob"/>
			</f>
			<meta><m n=":value"><e>{contentType:""}</e></m></meta>
			<haxe_doc>@throws DOMError</haxe_doc>
		</slice>
		<new public="1" set="method">
			<f a="blobParts:?options">
				<c path="Array"><x path="haxe.extern.EitherType">
	<c path="js.html.ArrayBuffer"/>
	<x path="haxe.extern.EitherType">
		<c path="js.html.ArrayBufferView"/>
		<x path="haxe.extern.EitherType">
			<c path="js.html.Blob"/>
			<c path="String"/>
		</x>
	</x>
</x></c>
				<t path="js.html.BlobPropertyBag"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
			<overloads><new public="1" set="method">
	<f a=""><x path="Void"/></f>
	<haxe_doc>@throws DOMError</haxe_doc>
</new></overloads>
		</new>
		<meta><m n=":native"><e>"Blob"</e></m></meta>
	</class>
	<typedef path="js.html.BlobPropertyBag" params="" file="C:\HaxeToolkit\haxe\std/js/html/BlobPropertyBag.hx"><a>
	<type>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</type>
	<endings>
		<t path="Null"><d/></t>
		<meta><m n=":optional"/></meta>
	</endings>
</a></typedef>
	<class path="js.html.BodyElement" params="" file="C:\HaxeToolkit\haxe\std/js/html/BodyElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<text public="1"><c path="String"/></text>
		<link public="1"><c path="String"/></link>
		<vLink public="1"><c path="String"/></vLink>
		<aLink public="1"><c path="String"/></aLink>
		<bgColor public="1"><c path="String"/></bgColor>
		<background public="1"><c path="String"/></background>
		<onafterprint public="1"><x path="haxe.Function"/></onafterprint>
		<onbeforeprint public="1"><x path="haxe.Function"/></onbeforeprint>
		<onbeforeunload public="1"><f a="">
	<c path="js.html.Event"/>
	<c path="String"/>
</f></onbeforeunload>
		<onhashchange public="1"><x path="haxe.Function"/></onhashchange>
		<onlanguagechange public="1"><x path="haxe.Function"/></onlanguagechange>
		<onmessage public="1"><x path="haxe.Function"/></onmessage>
		<onoffline public="1"><x path="haxe.Function"/></onoffline>
		<ononline public="1"><x path="haxe.Function"/></ononline>
		<onpagehide public="1"><x path="haxe.Function"/></onpagehide>
		<onpageshow public="1"><x path="haxe.Function"/></onpageshow>
		<onpopstate public="1"><x path="haxe.Function"/></onpopstate>
		<onresize public="1"><x path="haxe.Function"/></onresize>
		<onunload public="1"><x path="haxe.Function"/></onunload>
		<meta><m n=":native"><e>"HTMLBodyElement"</e></m></meta>
	</class>
	<class path="js.html.ButtonElement" params="" file="C:\HaxeToolkit\haxe\std/js/html/ButtonElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<autofocus public="1"><x path="Bool"/></autofocus>
		<disabled public="1"><x path="Bool"/></disabled>
		<form public="1" set="null"><c path="js.html.FormElement"/></form>
		<formAction public="1"><c path="String"/></formAction>
		<formEnctype public="1"><c path="String"/></formEnctype>
		<formMethod public="1"><c path="String"/></formMethod>
		<formNoValidate public="1"><x path="Bool"/></formNoValidate>
		<formTarget public="1"><c path="String"/></formTarget>
		<name public="1"><c path="String"/></name>
		<type public="1"><c path="String"/></type>
		<value public="1"><c path="String"/></value>
		<willValidate public="1" set="null"><x path="Bool"/></willValidate>
		<validity public="1" set="null"><c path="js.html.ValidityState"/></validity>
		<validationMessage public="1" set="null"><c path="String"/></validationMessage>
		<checkValidity public="1" set="method"><f a=""><x path="Bool"/></f></checkValidity>
		<setCustomValidity public="1" set="method"><f a="error">
	<c path="String"/>
	<x path="Void"/>
</f></setCustomValidity>
		<meta><m n=":native"><e>"HTMLButtonElement"</e></m></meta>
	</class>
	<class path="js.html.CharacterData" params="" file="C:\HaxeToolkit\haxe\std/js/html/CharacterData.hx" extern="1">
		<extends path="js.html.Node"/>
		<data public="1"><c path="String"/></data>
		<length public="1" set="null"><x path="Int"/></length>
		<previousElementSibling public="1" set="null"><c path="js.html.Element"/></previousElementSibling>
		<nextElementSibling public="1" set="null"><c path="js.html.Element"/></nextElementSibling>
		<substringData public="1" set="method">
			<f a="offset:count">
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</substringData>
		<appendData public="1" set="method">
			<f a="data">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</appendData>
		<insertData public="1" set="method">
			<f a="offset:data">
				<x path="Int"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</insertData>
		<deleteData public="1" set="method">
			<f a="offset:count">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</deleteData>
		<replaceData public="1" set="method">
			<f a="offset:count:data">
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</replaceData>
		<remove public="1" set="method"><f a=""><x path="Void"/></f></remove>
		<meta><m n=":native"><e>"CharacterData"</e></m></meta>
	</class>
	<class path="js.html.Text" params="" file="C:\HaxeToolkit\haxe\std/js/html/Text.hx" extern="1">
		<extends path="js.html.CharacterData"/>
		<wholeText public="1" set="null"><c path="String"/></wholeText>
		<splitText public="1" set="method">
			<f a="offset">
				<x path="Int"/>
				<c path="js.html.Text"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</splitText>
		<convertQuadFromNode public="1" set="method">
			<f a="quad:from:?options">
				<c path="js.html.DOMQuad"/>
				<x path="haxe.extern.EitherType">
					<c path="js.html.Text"/>
					<x path="haxe.extern.EitherType">
						<c path="js.html.Element"/>
						<c path="js.html.HTMLDocument"/>
					</x>
				</x>
				<t path="js.html.ConvertCoordinateOptions"/>
				<c path="js.html.DOMQuad"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</convertQuadFromNode>
		<convertRectFromNode public="1" set="method">
			<f a="rect:from:?options">
				<c path="js.html.DOMRectReadOnly"/>
				<x path="haxe.extern.EitherType">
					<c path="js.html.Text"/>
					<x path="haxe.extern.EitherType">
						<c path="js.html.Element"/>
						<c path="js.html.HTMLDocument"/>
					</x>
				</x>
				<t path="js.html.ConvertCoordinateOptions"/>
				<c path="js.html.DOMQuad"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</convertRectFromNode>
		<convertPointFromNode public="1" set="method">
			<f a="point:from:?options">
				<t path="js.html.DOMPointInit"/>
				<x path="haxe.extern.EitherType">
					<c path="js.html.Text"/>
					<x path="haxe.extern.EitherType">
						<c path="js.html.Element"/>
						<c path="js.html.HTMLDocument"/>
					</x>
				</x>
				<t path="js.html.ConvertCoordinateOptions"/>
				<c path="js.html.DOMPoint"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</convertPointFromNode>
		<new public="1" set="method">
			<f a="?data" v="&quot;&quot;">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{data:""}</e></m></meta>
			<haxe_doc>@throws DOMError</haxe_doc>
		</new>
		<meta><m n=":native"><e>"Text"</e></m></meta>
	</class>
	<class path="js.html.CDATASection" params="" file="C:\HaxeToolkit\haxe\std/js/html/CDATASection.hx" extern="1">
		<extends path="js.html.Text"/>
		<meta><m n=":native"><e>"CDATASection"</e></m></meta>
	</class>
	<class path="js.html.CSSValue" params="" file="C:\HaxeToolkit\haxe\std/js/html/CSSValue.hx" extern="1">
		<CSS_INHERIT public="1" get="inline" set="null" expr="0" line="30" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</CSS_INHERIT>
		<CSS_PRIMITIVE_VALUE public="1" get="inline" set="null" expr="1" line="31" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</CSS_PRIMITIVE_VALUE>
		<CSS_VALUE_LIST public="1" get="inline" set="null" expr="2" line="32" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2</e></m></meta>
		</CSS_VALUE_LIST>
		<CSS_CUSTOM public="1" get="inline" set="null" expr="3" line="33" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3</e></m></meta>
		</CSS_CUSTOM>
		<cssText public="1"><c path="String"/></cssText>
		<cssValueType public="1" set="null"><x path="Int"/></cssValueType>
		<meta><m n=":native"><e>"CSSValue"</e></m></meta>
	</class>
	<class path="js.html.CSSPrimitiveValue" params="" file="C:\HaxeToolkit\haxe\std/js/html/CSSPrimitiveValue.hx" extern="1">
		<extends path="js.html.CSSValue"/>
		<CSS_UNKNOWN public="1" get="inline" set="null" expr="0" line="30" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</CSS_UNKNOWN>
		<CSS_NUMBER public="1" get="inline" set="null" expr="1" line="31" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</CSS_NUMBER>
		<CSS_PERCENTAGE public="1" get="inline" set="null" expr="2" line="32" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2</e></m></meta>
		</CSS_PERCENTAGE>
		<CSS_EMS public="1" get="inline" set="null" expr="3" line="33" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3</e></m></meta>
		</CSS_EMS>
		<CSS_EXS public="1" get="inline" set="null" expr="4" line="34" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>4</e></m></meta>
		</CSS_EXS>
		<CSS_PX public="1" get="inline" set="null" expr="5" line="35" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>5</e></m></meta>
		</CSS_PX>
		<CSS_CM public="1" get="inline" set="null" expr="6" line="36" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>6</e></m></meta>
		</CSS_CM>
		<CSS_MM public="1" get="inline" set="null" expr="7" line="37" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>7</e></m></meta>
		</CSS_MM>
		<CSS_IN public="1" get="inline" set="null" expr="8" line="38" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>8</e></m></meta>
		</CSS_IN>
		<CSS_PT public="1" get="inline" set="null" expr="9" line="39" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>9</e></m></meta>
		</CSS_PT>
		<CSS_PC public="1" get="inline" set="null" expr="10" line="40" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>10</e></m></meta>
		</CSS_PC>
		<CSS_DEG public="1" get="inline" set="null" expr="11" line="41" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>11</e></m></meta>
		</CSS_DEG>
		<CSS_RAD public="1" get="inline" set="null" expr="12" line="42" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>12</e></m></meta>
		</CSS_RAD>
		<CSS_GRAD public="1" get="inline" set="null" expr="13" line="43" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>13</e></m></meta>
		</CSS_GRAD>
		<CSS_MS public="1" get="inline" set="null" expr="14" line="44" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>14</e></m></meta>
		</CSS_MS>
		<CSS_S public="1" get="inline" set="null" expr="15" line="45" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>15</e></m></meta>
		</CSS_S>
		<CSS_HZ public="1" get="inline" set="null" expr="16" line="46" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>16</e></m></meta>
		</CSS_HZ>
		<CSS_KHZ public="1" get="inline" set="null" expr="17" line="47" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>17</e></m></meta>
		</CSS_KHZ>
		<CSS_DIMENSION public="1" get="inline" set="null" expr="18" line="48" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>18</e></m></meta>
		</CSS_DIMENSION>
		<CSS_STRING public="1" get="inline" set="null" expr="19" line="49" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>19</e></m></meta>
		</CSS_STRING>
		<CSS_URI public="1" get="inline" set="null" expr="20" line="50" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>20</e></m></meta>
		</CSS_URI>
		<CSS_IDENT public="1" get="inline" set="null" expr="21" line="51" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>21</e></m></meta>
		</CSS_IDENT>
		<CSS_ATTR public="1" get="inline" set="null" expr="22" line="52" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>22</e></m></meta>
		</CSS_ATTR>
		<CSS_COUNTER public="1" get="inline" set="null" expr="23" line="53" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>23</e></m></meta>
		</CSS_COUNTER>
		<CSS_RECT public="1" get="inline" set="null" expr="24" line="54" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>24</e></m></meta>
		</CSS_RECT>
		<CSS_RGBCOLOR public="1" get="inline" set="null" expr="25" line="55" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>25</e></m></meta>
		</CSS_RGBCOLOR>
		<primitiveType public="1" set="null"><x path="Int"/></primitiveType>
		<setFloatValue public="1" set="method">
			<f a="unitType:floatValue">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</setFloatValue>
		<getFloatValue public="1" set="method">
			<f a="unitType">
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</getFloatValue>
		<setStringValue public="1" set="method">
			<f a="stringType:stringValue">
				<x path="Int"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</setStringValue>
		<getStringValue public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</getStringValue>
		<getCounterValue public="1" set="method">
			<f a=""><d/></f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</getCounterValue>
		<getRectValue public="1" set="method">
			<f a=""><c path="js.html.Rect"/></f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</getRectValue>
		<getRGBColorValue public="1" set="method">
			<f a=""><c path="js.html.RGBColor"/></f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</getRGBColorValue>
		<meta><m n=":native"><e>"CSSPrimitiveValue"</e></m></meta>
	</class>
	<class path="js.html.CSSRule" params="" file="C:\HaxeToolkit\haxe\std/js/html/CSSRule.hx" extern="1">
		<UNKNOWN_RULE public="1" get="inline" set="null" expr="0" line="30" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</UNKNOWN_RULE>
		<STYLE_RULE public="1" get="inline" set="null" expr="1" line="31" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</STYLE_RULE>
		<CHARSET_RULE public="1" get="inline" set="null" expr="2" line="32" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2</e></m></meta>
		</CHARSET_RULE>
		<IMPORT_RULE public="1" get="inline" set="null" expr="3" line="33" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3</e></m></meta>
		</IMPORT_RULE>
		<MEDIA_RULE public="1" get="inline" set="null" expr="4" line="34" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>4</e></m></meta>
		</MEDIA_RULE>
		<FONT_FACE_RULE public="1" get="inline" set="null" expr="5" line="35" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>5</e></m></meta>
		</FONT_FACE_RULE>
		<PAGE_RULE public="1" get="inline" set="null" expr="6" line="36" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>6</e></m></meta>
		</PAGE_RULE>
		<type public="1" set="null"><x path="Int"/></type>
		<cssText public="1"><c path="String"/></cssText>
		<parentStyleSheet public="1" set="null"><c path="js.html.CSSStyleSheet"/></parentStyleSheet>
		<parentRule public="1" set="null"><c path="js.html.CSSRule"/></parentRule>
		<meta><m n=":native"><e>"CSSRule"</e></m></meta>
	</class>
	<class path="js.html.CSSRuleList" params="" file="C:\HaxeToolkit\haxe\std/js/html/CSSRuleList.hx" extern="1">
		<length public="1" set="null"><x path="Int"/></length>
		<item public="1" set="method"><f a="index">
	<x path="Int"/>
	<c path="js.html.CSSRule"/>
</f></item>
		<meta><m n=":native"><e>"CSSRuleList"</e></m></meta>
	</class>
	<class path="js.html.CSSStyleDeclaration" params="" file="C:\HaxeToolkit\haxe\std/js/html/CSSStyleDeclaration.hx" extern="1">
		<cssText public="1"><c path="String"/></cssText>
		<length public="1" set="null"><x path="Int"/></length>
		<parentRule public="1" set="null"><c path="js.html.CSSRule"/></parentRule>
		<alignContent public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "align-content" CSS property.</haxe_doc>
		</alignContent>
		<alignItems public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "align-items" CSS property.</haxe_doc>
		</alignItems>
		<alignSelf public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "align-self" CSS property.</haxe_doc>
		</alignSelf>
		<alignmentAdjust public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "alignment-adjust" CSS property.</haxe_doc>
		</alignmentAdjust>
		<alignmentBaseline public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "alignment-baseline" CSS property.</haxe_doc>
		</alignmentBaseline>
		<all public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "all" CSS property.</haxe_doc>
		</all>
		<anchorPoint public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "anchor-point" CSS property.</haxe_doc>
		</anchorPoint>
		<animation public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "animation" CSS property.</haxe_doc>
		</animation>
		<animationDelay public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "animation-delay" CSS property.</haxe_doc>
		</animationDelay>
		<animationDirection public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "animation-direction" CSS property.</haxe_doc>
		</animationDirection>
		<animationDuration public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "animation-duration" CSS property.</haxe_doc>
		</animationDuration>
		<animationFillMode public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "animation-fill-mode" CSS property.</haxe_doc>
		</animationFillMode>
		<animationIterationCount public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "animation-iteration-count" CSS property.</haxe_doc>
		</animationIterationCount>
		<animationName public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "animation-name" CSS property.</haxe_doc>
		</animationName>
		<animationPlayState public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "animation-play-state" CSS property.</haxe_doc>
		</animationPlayState>
		<animationTimingFunction public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "animation-timing-function" CSS property.</haxe_doc>
		</animationTimingFunction>
		<azimuth public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "azimuth" CSS property.</haxe_doc>
		</azimuth>
		<backfaceVisibility public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "backface-visibility" CSS property.</haxe_doc>
		</backfaceVisibility>
		<background public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "background" CSS property.</haxe_doc>
		</background>
		<backgroundAttachment public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "background-attachment" CSS property.</haxe_doc>
		</backgroundAttachment>
		<backgroundClip public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "background-clip" CSS property.</haxe_doc>
		</backgroundClip>
		<backgroundColor public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "background-color" CSS property.</haxe_doc>
		</backgroundColor>
		<backgroundImage public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "background-image" CSS property.</haxe_doc>
		</backgroundImage>
		<backgroundOrigin public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "background-origin" CSS property.</haxe_doc>
		</backgroundOrigin>
		<backgroundPosition public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "background-position" CSS property.</haxe_doc>
		</backgroundPosition>
		<backgroundRepeat public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "background-repeat" CSS property.</haxe_doc>
		</backgroundRepeat>
		<backgroundSize public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "background-size" CSS property.</haxe_doc>
		</backgroundSize>
		<baselineShift public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "baseline-shift" CSS property.</haxe_doc>
		</baselineShift>
		<binding public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "binding" CSS property.</haxe_doc>
		</binding>
		<bleed public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "bleed" CSS property.</haxe_doc>
		</bleed>
		<bookmarkLabel public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "bookmark-label" CSS property.</haxe_doc>
		</bookmarkLabel>
		<bookmarkLevel public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "bookmark-level" CSS property.</haxe_doc>
		</bookmarkLevel>
		<bookmarkState public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "bookmark-state" CSS property.</haxe_doc>
		</bookmarkState>
		<border public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "border" CSS property.</haxe_doc>
		</border>
		<borderBottom public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "border-bottom" CSS property.</haxe_doc>
		</borderBottom>
		<borderBottomColor public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "border-bottom-color" CSS property.</haxe_doc>
		</borderBottomColor>
		<borderBottomLeftRadius public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "border-bottom-left-radius" CSS property.</haxe_doc>
		</borderBottomLeftRadius>
		<borderBottomRightRadius public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "border-bottom-right-radius" CSS property.</haxe_doc>
		</borderBottomRightRadius>
		<borderBottomStyle public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "border-bottom-style" CSS property.</haxe_doc>
		</borderBottomStyle>
		<borderBottomWidth public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "border-bottom-width" CSS property.</haxe_doc>
		</borderBottomWidth>
		<borderCollapse public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "border-collapse" CSS property.</haxe_doc>
		</borderCollapse>
		<borderColor public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "border-color" CSS property.</haxe_doc>
		</borderColor>
		<borderImage public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "border-image" CSS property.</haxe_doc>
		</borderImage>
		<borderImageOutset public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "border-image-outset" CSS property.</haxe_doc>
		</borderImageOutset>
		<borderImageRepeat public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "border-image-repeat" CSS property.</haxe_doc>
		</borderImageRepeat>
		<borderImageSlice public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "border-image-slice" CSS property.</haxe_doc>
		</borderImageSlice>
		<borderImageSource public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "border-image-source" CSS property.</haxe_doc>
		</borderImageSource>
		<borderImageWidth public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "border-image-width" CSS property.</haxe_doc>
		</borderImageWidth>
		<borderLeft public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "border-left" CSS property.</haxe_doc>
		</borderLeft>
		<borderLeftColor public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "border-left-color" CSS property.</haxe_doc>
		</borderLeftColor>
		<borderLeftStyle public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "border-left-style" CSS property.</haxe_doc>
		</borderLeftStyle>
		<borderLeftWidth public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "border-left-width" CSS property.</haxe_doc>
		</borderLeftWidth>
		<borderRadius public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "border-radius" CSS property.</haxe_doc>
		</borderRadius>
		<borderRight public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "border-right" CSS property.</haxe_doc>
		</borderRight>
		<borderRightColor public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "border-right-color" CSS property.</haxe_doc>
		</borderRightColor>
		<borderRightStyle public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "border-right-style" CSS property.</haxe_doc>
		</borderRightStyle>
		<borderRightWidth public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "border-right-width" CSS property.</haxe_doc>
		</borderRightWidth>
		<borderSpacing public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "border-spacing" CSS property.</haxe_doc>
		</borderSpacing>
		<borderStyle public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "border-style" CSS property.</haxe_doc>
		</borderStyle>
		<borderTop public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "border-top" CSS property.</haxe_doc>
		</borderTop>
		<borderTopColor public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "border-top-color" CSS property.</haxe_doc>
		</borderTopColor>
		<borderTopLeftRadius public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "border-top-left-radius" CSS property.</haxe_doc>
		</borderTopLeftRadius>
		<borderTopRightRadius public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "border-top-right-radius" CSS property.</haxe_doc>
		</borderTopRightRadius>
		<borderTopStyle public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "border-top-style" CSS property.</haxe_doc>
		</borderTopStyle>
		<borderTopWidth public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "border-top-width" CSS property.</haxe_doc>
		</borderTopWidth>
		<borderWidth public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "border-width" CSS property.</haxe_doc>
		</borderWidth>
		<bottom public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "bottom" CSS property.</haxe_doc>
		</bottom>
		<boxDecorationBreak public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "box-decoration-break" CSS property.</haxe_doc>
		</boxDecorationBreak>
		<boxShadow public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "box-shadow" CSS property.</haxe_doc>
		</boxShadow>
		<boxSizing public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "box-sizing" CSS property.</haxe_doc>
		</boxSizing>
		<boxSnap public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "box-snap" CSS property.</haxe_doc>
		</boxSnap>
		<boxSuppress public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "box-suppress" CSS property.</haxe_doc>
		</boxSuppress>
		<breakAfter public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "break-after" CSS property.</haxe_doc>
		</breakAfter>
		<breakBefore public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "break-before" CSS property.</haxe_doc>
		</breakBefore>
		<breakInside public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "break-inside" CSS property.</haxe_doc>
		</breakInside>
		<captionSide public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "caption-side" CSS property.</haxe_doc>
		</captionSide>
		<chains public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "chains" CSS property.</haxe_doc>
		</chains>
		<clear public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "clear" CSS property.</haxe_doc>
		</clear>
		<clip public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "clip" CSS property.</haxe_doc>
		</clip>
		<clipPath public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "clip-path" CSS property.</haxe_doc>
		</clipPath>
		<clipRule public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "clip-rule" CSS property.</haxe_doc>
		</clipRule>
		<color public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "color" CSS property.</haxe_doc>
		</color>
		<colorInterpolationFilters public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "color-interpolation-filters" CSS property.</haxe_doc>
		</colorInterpolationFilters>
		<columnCount public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "column-count" CSS property.</haxe_doc>
		</columnCount>
		<columnFill public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "column-fill" CSS property.</haxe_doc>
		</columnFill>
		<columnGap public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "column-gap" CSS property.</haxe_doc>
		</columnGap>
		<columnRule public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "column-rule" CSS property.</haxe_doc>
		</columnRule>
		<columnRuleColor public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "column-rule-color" CSS property.</haxe_doc>
		</columnRuleColor>
		<columnRuleStyle public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "column-rule-style" CSS property.</haxe_doc>
		</columnRuleStyle>
		<columnRuleWidth public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "column-rule-width" CSS property.</haxe_doc>
		</columnRuleWidth>
		<columnSpan public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "column-span" CSS property.</haxe_doc>
		</columnSpan>
		<columnWidth public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "column-width" CSS property.</haxe_doc>
		</columnWidth>
		<columns public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "columns" CSS property.</haxe_doc>
		</columns>
		<contain public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "contain" CSS property.</haxe_doc>
		</contain>
		<content public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "content" CSS property.</haxe_doc>
		</content>
		<counterIncrement public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "counter-increment" CSS property.</haxe_doc>
		</counterIncrement>
		<counterReset public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "counter-reset" CSS property.</haxe_doc>
		</counterReset>
		<counterSet public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "counter-set" CSS property.</haxe_doc>
		</counterSet>
		<crop public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "crop" CSS property.</haxe_doc>
		</crop>
		<cue public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "cue" CSS property.</haxe_doc>
		</cue>
		<cueAfter public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "cue-after" CSS property.</haxe_doc>
		</cueAfter>
		<cueBefore public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "cue-before" CSS property.</haxe_doc>
		</cueBefore>
		<cursor public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "cursor" CSS property.</haxe_doc>
		</cursor>
		<direction public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "direction" CSS property.</haxe_doc>
		</direction>
		<display public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "display" CSS property.</haxe_doc>
		</display>
		<displayInside public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "display-inside" CSS property.</haxe_doc>
		</displayInside>
		<displayList public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "display-list" CSS property.</haxe_doc>
		</displayList>
		<displayOutside public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "display-outside" CSS property.</haxe_doc>
		</displayOutside>
		<dominantBaseline public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "dominant-baseline" CSS property.</haxe_doc>
		</dominantBaseline>
		<elevation public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "elevation" CSS property.</haxe_doc>
		</elevation>
		<emptyCells public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "empty-cells" CSS property.</haxe_doc>
		</emptyCells>
		<filter public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "filter" CSS property.</haxe_doc>
		</filter>
		<flex public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "flex" CSS property.</haxe_doc>
		</flex>
		<flexBasis public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "flex-basis" CSS property.</haxe_doc>
		</flexBasis>
		<flexDirection public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "flex-direction" CSS property.</haxe_doc>
		</flexDirection>
		<flexFlow public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "flex-flow" CSS property.</haxe_doc>
		</flexFlow>
		<flexGrow public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "flex-grow" CSS property.</haxe_doc>
		</flexGrow>
		<flexShrink public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "flex-shrink" CSS property.</haxe_doc>
		</flexShrink>
		<flexWrap public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "flex-wrap" CSS property.</haxe_doc>
		</flexWrap>
		<float public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "float" CSS property.</haxe_doc>
		</float>
		<floatOffset public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "float-offset" CSS property.</haxe_doc>
		</floatOffset>
		<floodColor public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "flood-color" CSS property.</haxe_doc>
		</floodColor>
		<floodOpacity public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "flood-opacity" CSS property.</haxe_doc>
		</floodOpacity>
		<flowFrom public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "flow-from" CSS property.</haxe_doc>
		</flowFrom>
		<flowInto public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "flow-into" CSS property.</haxe_doc>
		</flowInto>
		<font public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "font" CSS property.</haxe_doc>
		</font>
		<fontFamily public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "font-family" CSS property.</haxe_doc>
		</fontFamily>
		<fontFeatureSettings public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "font-feature-settings" CSS property.</haxe_doc>
		</fontFeatureSettings>
		<fontKerning public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "font-kerning" CSS property.</haxe_doc>
		</fontKerning>
		<fontLanguageOverride public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "font-language-override" CSS property.</haxe_doc>
		</fontLanguageOverride>
		<fontSize public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "font-size" CSS property.</haxe_doc>
		</fontSize>
		<fontSizeAdjust public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "font-size-adjust" CSS property.</haxe_doc>
		</fontSizeAdjust>
		<fontStretch public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "font-stretch" CSS property.</haxe_doc>
		</fontStretch>
		<fontStyle public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "font-style" CSS property.</haxe_doc>
		</fontStyle>
		<fontSynthesis public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "font-synthesis" CSS property.</haxe_doc>
		</fontSynthesis>
		<fontVariant public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "font-variant" CSS property.</haxe_doc>
		</fontVariant>
		<fontVariantAlternates public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "font-variant-alternates" CSS property.</haxe_doc>
		</fontVariantAlternates>
		<fontVariantCaps public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "font-variant-caps" CSS property.</haxe_doc>
		</fontVariantCaps>
		<fontVariantEastAsian public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "font-variant-east-asian" CSS property.</haxe_doc>
		</fontVariantEastAsian>
		<fontVariantLigatures public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "font-variant-ligatures" CSS property.</haxe_doc>
		</fontVariantLigatures>
		<fontVariantNumeric public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "font-variant-numeric" CSS property.</haxe_doc>
		</fontVariantNumeric>
		<fontVariantPosition public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "font-variant-position" CSS property.</haxe_doc>
		</fontVariantPosition>
		<fontWeight public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "font-weight" CSS property.</haxe_doc>
		</fontWeight>
		<grid public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "grid" CSS property.</haxe_doc>
		</grid>
		<gridArea public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "grid-area" CSS property.</haxe_doc>
		</gridArea>
		<gridAutoColumns public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "grid-auto-columns" CSS property.</haxe_doc>
		</gridAutoColumns>
		<gridAutoFlow public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "grid-auto-flow" CSS property.</haxe_doc>
		</gridAutoFlow>
		<gridAutoRows public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "grid-auto-rows" CSS property.</haxe_doc>
		</gridAutoRows>
		<gridColumn public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "grid-column" CSS property.</haxe_doc>
		</gridColumn>
		<gridColumnEnd public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "grid-column-end" CSS property.</haxe_doc>
		</gridColumnEnd>
		<gridColumnStart public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "grid-column-start" CSS property.</haxe_doc>
		</gridColumnStart>
		<gridRow public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "grid-row" CSS property.</haxe_doc>
		</gridRow>
		<gridRowEnd public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "grid-row-end" CSS property.</haxe_doc>
		</gridRowEnd>
		<gridRowStart public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "grid-row-start" CSS property.</haxe_doc>
		</gridRowStart>
		<gridTemplate public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "grid-template" CSS property.</haxe_doc>
		</gridTemplate>
		<gridTemplateAreas public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "grid-template-areas" CSS property.</haxe_doc>
		</gridTemplateAreas>
		<gridTemplateColumns public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "grid-template-columns" CSS property.</haxe_doc>
		</gridTemplateColumns>
		<gridTemplateRows public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "grid-template-rows" CSS property.</haxe_doc>
		</gridTemplateRows>
		<hangingPunctuation public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "hanging-punctuation" CSS property.</haxe_doc>
		</hangingPunctuation>
		<height public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "height" CSS property.</haxe_doc>
		</height>
		<hyphens public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "hyphens" CSS property.</haxe_doc>
		</hyphens>
		<icon public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "icon" CSS property.</haxe_doc>
		</icon>
		<imageOrientation public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "image-orientation" CSS property.</haxe_doc>
		</imageOrientation>
		<imageResolution public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "image-resolution" CSS property.</haxe_doc>
		</imageResolution>
		<imeMode public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "ime-mode" CSS property.</haxe_doc>
		</imeMode>
		<initialLetters public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "initial-letters" CSS property.</haxe_doc>
		</initialLetters>
		<inlineBoxAlign public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "inline-box-align" CSS property.</haxe_doc>
		</inlineBoxAlign>
		<justifyContent public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "justify-content" CSS property.</haxe_doc>
		</justifyContent>
		<justifyItems public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "justify-items" CSS property.</haxe_doc>
		</justifyItems>
		<justifySelf public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "justify-self" CSS property.</haxe_doc>
		</justifySelf>
		<left public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "left" CSS property.</haxe_doc>
		</left>
		<letterSpacing public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "letter-spacing" CSS property.</haxe_doc>
		</letterSpacing>
		<lightingColor public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "lighting-color" CSS property.</haxe_doc>
		</lightingColor>
		<lineBoxContain public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "line-box-contain" CSS property.</haxe_doc>
		</lineBoxContain>
		<lineBreak public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "line-break" CSS property.</haxe_doc>
		</lineBreak>
		<lineGrid public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "line-grid" CSS property.</haxe_doc>
		</lineGrid>
		<lineHeight public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "line-height" CSS property.</haxe_doc>
		</lineHeight>
		<lineSnap public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "line-snap" CSS property.</haxe_doc>
		</lineSnap>
		<lineStacking public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "line-stacking" CSS property.</haxe_doc>
		</lineStacking>
		<lineStackingRuby public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "line-stacking-ruby" CSS property.</haxe_doc>
		</lineStackingRuby>
		<lineStackingShift public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "line-stacking-shift" CSS property.</haxe_doc>
		</lineStackingShift>
		<lineStackingStrategy public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "line-stacking-strategy" CSS property.</haxe_doc>
		</lineStackingStrategy>
		<listStyle public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "list-style" CSS property.</haxe_doc>
		</listStyle>
		<listStyleImage public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "list-style-image" CSS property.</haxe_doc>
		</listStyleImage>
		<listStylePosition public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "list-style-position" CSS property.</haxe_doc>
		</listStylePosition>
		<listStyleType public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "list-style-type" CSS property.</haxe_doc>
		</listStyleType>
		<margin public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "margin" CSS property.</haxe_doc>
		</margin>
		<marginBottom public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "margin-bottom" CSS property.</haxe_doc>
		</marginBottom>
		<marginLeft public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "margin-left" CSS property.</haxe_doc>
		</marginLeft>
		<marginRight public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "margin-right" CSS property.</haxe_doc>
		</marginRight>
		<marginTop public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "margin-top" CSS property.</haxe_doc>
		</marginTop>
		<markerOffset public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "marker-offset" CSS property.</haxe_doc>
		</markerOffset>
		<markerSide public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "marker-side" CSS property.</haxe_doc>
		</markerSide>
		<marks public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "marks" CSS property.</haxe_doc>
		</marks>
		<mask public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "mask" CSS property.</haxe_doc>
		</mask>
		<maskBox public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "mask-box" CSS property.</haxe_doc>
		</maskBox>
		<maskBoxOutset public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "mask-box-outset" CSS property.</haxe_doc>
		</maskBoxOutset>
		<maskBoxRepeat public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "mask-box-repeat" CSS property.</haxe_doc>
		</maskBoxRepeat>
		<maskBoxSlice public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "mask-box-slice" CSS property.</haxe_doc>
		</maskBoxSlice>
		<maskBoxSource public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "mask-box-source" CSS property.</haxe_doc>
		</maskBoxSource>
		<maskBoxWidth public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "mask-box-width" CSS property.</haxe_doc>
		</maskBoxWidth>
		<maskClip public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "mask-clip" CSS property.</haxe_doc>
		</maskClip>
		<maskImage public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "mask-image" CSS property.</haxe_doc>
		</maskImage>
		<maskOrigin public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "mask-origin" CSS property.</haxe_doc>
		</maskOrigin>
		<maskPosition public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "mask-position" CSS property.</haxe_doc>
		</maskPosition>
		<maskRepeat public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "mask-repeat" CSS property.</haxe_doc>
		</maskRepeat>
		<maskSize public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "mask-size" CSS property.</haxe_doc>
		</maskSize>
		<maskSourceType public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "mask-source-type" CSS property.</haxe_doc>
		</maskSourceType>
		<maskType public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "mask-type" CSS property.</haxe_doc>
		</maskType>
		<maxHeight public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "max-height" CSS property.</haxe_doc>
		</maxHeight>
		<maxLines public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "max-lines" CSS property.</haxe_doc>
		</maxLines>
		<maxWidth public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "max-width" CSS property.</haxe_doc>
		</maxWidth>
		<minHeight public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "min-height" CSS property.</haxe_doc>
		</minHeight>
		<minWidth public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "min-width" CSS property.</haxe_doc>
		</minWidth>
		<moveTo public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "move-to" CSS property.</haxe_doc>
		</moveTo>
		<navDown public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "nav-down" CSS property.</haxe_doc>
		</navDown>
		<navIndex public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "nav-index" CSS property.</haxe_doc>
		</navIndex>
		<navLeft public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "nav-left" CSS property.</haxe_doc>
		</navLeft>
		<navRight public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "nav-right" CSS property.</haxe_doc>
		</navRight>
		<navUp public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "nav-up" CSS property.</haxe_doc>
		</navUp>
		<objectFit public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "object-fit" CSS property.</haxe_doc>
		</objectFit>
		<objectPosition public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "object-position" CSS property.</haxe_doc>
		</objectPosition>
		<opacity public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "opacity" CSS property.</haxe_doc>
		</opacity>
		<order public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "order" CSS property.</haxe_doc>
		</order>
		<orphans public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "orphans" CSS property.</haxe_doc>
		</orphans>
		<outline public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "outline" CSS property.</haxe_doc>
		</outline>
		<outlineColor public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "outline-color" CSS property.</haxe_doc>
		</outlineColor>
		<outlineOffset public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "outline-offset" CSS property.</haxe_doc>
		</outlineOffset>
		<outlineStyle public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "outline-style" CSS property.</haxe_doc>
		</outlineStyle>
		<outlineWidth public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "outline-width" CSS property.</haxe_doc>
		</outlineWidth>
		<overflow public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "overflow" CSS property.</haxe_doc>
		</overflow>
		<overflowWrap public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "overflow-wrap" CSS property.</haxe_doc>
		</overflowWrap>
		<overflowX public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "overflow-x" CSS property.</haxe_doc>
		</overflowX>
		<overflowY public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "overflow-y" CSS property.</haxe_doc>
		</overflowY>
		<padding public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "padding" CSS property.</haxe_doc>
		</padding>
		<paddingBottom public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "padding-bottom" CSS property.</haxe_doc>
		</paddingBottom>
		<paddingLeft public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "padding-left" CSS property.</haxe_doc>
		</paddingLeft>
		<paddingRight public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "padding-right" CSS property.</haxe_doc>
		</paddingRight>
		<paddingTop public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "padding-top" CSS property.</haxe_doc>
		</paddingTop>
		<page public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "page" CSS property.</haxe_doc>
		</page>
		<pageBreakAfter public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "page-break-after" CSS property.</haxe_doc>
		</pageBreakAfter>
		<pageBreakBefore public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "page-break-before" CSS property.</haxe_doc>
		</pageBreakBefore>
		<pageBreakInside public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "page-break-inside" CSS property.</haxe_doc>
		</pageBreakInside>
		<pagePolicy public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "page-policy" CSS property.</haxe_doc>
		</pagePolicy>
		<pause public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "pause" CSS property.</haxe_doc>
		</pause>
		<pauseAfter public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "pause-after" CSS property.</haxe_doc>
		</pauseAfter>
		<pauseBefore public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "pause-before" CSS property.</haxe_doc>
		</pauseBefore>
		<perspective public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "perspective" CSS property.</haxe_doc>
		</perspective>
		<perspectiveOrigin public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "perspective-origin" CSS property.</haxe_doc>
		</perspectiveOrigin>
		<pitch public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "pitch" CSS property.</haxe_doc>
		</pitch>
		<pitchRange public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "pitch-range" CSS property.</haxe_doc>
		</pitchRange>
		<playDuring public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "play-during" CSS property.</haxe_doc>
		</playDuring>
		<position public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "position" CSS property.</haxe_doc>
		</position>
		<presentationLevel public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "presentation-level" CSS property.</haxe_doc>
		</presentationLevel>
		<quotes public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "quotes" CSS property.</haxe_doc>
		</quotes>
		<regionFragment public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "region-fragment" CSS property.</haxe_doc>
		</regionFragment>
		<resize public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "resize" CSS property.</haxe_doc>
		</resize>
		<rest public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "rest" CSS property.</haxe_doc>
		</rest>
		<restAfter public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "rest-after" CSS property.</haxe_doc>
		</restAfter>
		<restBefore public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "rest-before" CSS property.</haxe_doc>
		</restBefore>
		<richness public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "richness" CSS property.</haxe_doc>
		</richness>
		<right public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "right" CSS property.</haxe_doc>
		</right>
		<rotation public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "rotation" CSS property.</haxe_doc>
		</rotation>
		<rotationPoint public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "rotation-point" CSS property.</haxe_doc>
		</rotationPoint>
		<rubyAlign public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "ruby-align" CSS property.</haxe_doc>
		</rubyAlign>
		<rubyMerge public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "ruby-merge" CSS property.</haxe_doc>
		</rubyMerge>
		<rubyPosition public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "ruby-position" CSS property.</haxe_doc>
		</rubyPosition>
		<shapeImageThreshold public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "shape-image-threshold" CSS property.</haxe_doc>
		</shapeImageThreshold>
		<shapeOutside public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "shape-outside" CSS property.</haxe_doc>
		</shapeOutside>
		<shapeMargin public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "shape-margin" CSS property.</haxe_doc>
		</shapeMargin>
		<size public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "size" CSS property.</haxe_doc>
		</size>
		<speak public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "speak" CSS property.</haxe_doc>
		</speak>
		<speakAs public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "speak-as" CSS property.</haxe_doc>
		</speakAs>
		<speakHeader public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "speak-header" CSS property.</haxe_doc>
		</speakHeader>
		<speakNumeral public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "speak-numeral" CSS property.</haxe_doc>
		</speakNumeral>
		<speakPunctuation public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "speak-punctuation" CSS property.</haxe_doc>
		</speakPunctuation>
		<speechRate public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "speech-rate" CSS property.</haxe_doc>
		</speechRate>
		<stress public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "stress" CSS property.</haxe_doc>
		</stress>
		<stringSet public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "string-set" CSS property.</haxe_doc>
		</stringSet>
		<tabSize public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "tab-size" CSS property.</haxe_doc>
		</tabSize>
		<tableLayout public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "table-layout" CSS property.</haxe_doc>
		</tableLayout>
		<textAlign public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "text-align" CSS property.</haxe_doc>
		</textAlign>
		<textAlignLast public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "text-align-last" CSS property.</haxe_doc>
		</textAlignLast>
		<textCombineUpright public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "text-combine-upright" CSS property.</haxe_doc>
		</textCombineUpright>
		<textDecoration public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "text-decoration" CSS property.</haxe_doc>
		</textDecoration>
		<textDecorationColor public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "text-decoration-color" CSS property.</haxe_doc>
		</textDecorationColor>
		<textDecorationLine public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "text-decoration-line" CSS property.</haxe_doc>
		</textDecorationLine>
		<textDecorationSkip public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "text-decoration-skip" CSS property.</haxe_doc>
		</textDecorationSkip>
		<textDecorationStyle public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "text-decoration-style" CSS property.</haxe_doc>
		</textDecorationStyle>
		<textEmphasis public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "text-emphasis" CSS property.</haxe_doc>
		</textEmphasis>
		<textEmphasisColor public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "text-emphasis-color" CSS property.</haxe_doc>
		</textEmphasisColor>
		<textEmphasisPosition public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "text-emphasis-position" CSS property.</haxe_doc>
		</textEmphasisPosition>
		<textEmphasisStyle public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "text-emphasis-style" CSS property.</haxe_doc>
		</textEmphasisStyle>
		<textHeight public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "text-height" CSS property.</haxe_doc>
		</textHeight>
		<textIndent public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "text-indent" CSS property.</haxe_doc>
		</textIndent>
		<textJustify public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "text-justify" CSS property.</haxe_doc>
		</textJustify>
		<textOrientation public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "text-orientation" CSS property.</haxe_doc>
		</textOrientation>
		<textOverflow public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "text-overflow" CSS property.</haxe_doc>
		</textOverflow>
		<textShadow public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "text-shadow" CSS property.</haxe_doc>
		</textShadow>
		<textSpaceCollapse public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "text-space-collapse" CSS property.</haxe_doc>
		</textSpaceCollapse>
		<textTransform public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "text-transform" CSS property.</haxe_doc>
		</textTransform>
		<textUnderlinePosition public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "text-underline-position" CSS property.</haxe_doc>
		</textUnderlinePosition>
		<textWrap public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "text-wrap" CSS property.</haxe_doc>
		</textWrap>
		<top public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "top" CSS property.</haxe_doc>
		</top>
		<transform public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "transform" CSS property.</haxe_doc>
		</transform>
		<transformOrigin public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "transform-origin" CSS property.</haxe_doc>
		</transformOrigin>
		<transformStyle public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "transform-style" CSS property.</haxe_doc>
		</transformStyle>
		<transition public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "transition" CSS property.</haxe_doc>
		</transition>
		<transitionDelay public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "transition-delay" CSS property.</haxe_doc>
		</transitionDelay>
		<transitionDuration public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "transition-duration" CSS property.</haxe_doc>
		</transitionDuration>
		<transitionProperty public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "transition-property" CSS property.</haxe_doc>
		</transitionProperty>
		<transitionTimingFunction public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "transition-timing-function" CSS property.</haxe_doc>
		</transitionTimingFunction>
		<unicodeBidi public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "unicode-bidi" CSS property.</haxe_doc>
		</unicodeBidi>
		<verticalAlign public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "vertical-align" CSS property.</haxe_doc>
		</verticalAlign>
		<visibility public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "visibility" CSS property.</haxe_doc>
		</visibility>
		<voiceBalance public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "voice-balance" CSS property.</haxe_doc>
		</voiceBalance>
		<voiceDuration public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "voice-duration" CSS property.</haxe_doc>
		</voiceDuration>
		<voiceFamily public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "voice-family" CSS property.</haxe_doc>
		</voiceFamily>
		<voicePitch public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "voice-pitch" CSS property.</haxe_doc>
		</voicePitch>
		<voiceRange public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "voice-range" CSS property.</haxe_doc>
		</voiceRange>
		<voiceRate public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "voice-rate" CSS property.</haxe_doc>
		</voiceRate>
		<voiceStress public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "voice-stress" CSS property.</haxe_doc>
		</voiceStress>
		<voiceVolume public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "voice-volume" CSS property.</haxe_doc>
		</voiceVolume>
		<volume public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "volume" CSS property.</haxe_doc>
		</volume>
		<whiteSpace public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "white-space" CSS property.</haxe_doc>
		</whiteSpace>
		<widows public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "widows" CSS property.</haxe_doc>
		</widows>
		<width public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "width" CSS property.</haxe_doc>
		</width>
		<willChange public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "will-change" CSS property.</haxe_doc>
		</willChange>
		<wordBreak public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "word-break" CSS property.</haxe_doc>
		</wordBreak>
		<wordSpacing public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "word-spacing" CSS property.</haxe_doc>
		</wordSpacing>
		<wordWrap public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "word-wrap" CSS property.</haxe_doc>
		</wordWrap>
		<wrapFlow public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "wrap-flow" CSS property.</haxe_doc>
		</wrapFlow>
		<wrapThrough public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "wrap-through" CSS property.</haxe_doc>
		</wrapThrough>
		<writingMode public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "writing-mode" CSS property.</haxe_doc>
		</writingMode>
		<zIndex public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "z-index" CSS property.</haxe_doc>
		</zIndex>
		<item public="1" set="method"><f a="index">
	<x path="Int"/>
	<c path="String"/>
</f></item>
		<getPropertyValue public="1" set="method">
			<f a="property">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</getPropertyValue>
		<getPropertyCSSValue public="1" set="method">
			<f a="property">
				<c path="String"/>
				<c path="js.html.CSSValue"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</getPropertyCSSValue>
		<getPropertyPriority public="1" set="method"><f a="property">
	<c path="String"/>
	<c path="String"/>
</f></getPropertyPriority>
		<setProperty public="1" set="method">
			<f a="property:value:?priority" v="::&quot;&quot;">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{priority:""}</e></m></meta>
			<haxe_doc>@throws DOMError</haxe_doc>
		</setProperty>
		<removeProperty public="1" set="method">
			<f a="property">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</removeProperty>
		<meta><m n=":native"><e>"CSSStyleDeclaration"</e></m></meta>
	</class>
	<class path="js.html.StyleSheet" params="" file="C:\HaxeToolkit\haxe\std/js/html/StyleSheet.hx" extern="1">
		<type public="1" set="null"><c path="String"/></type>
		<href public="1" set="null"><c path="String"/></href>
		<ownerNode public="1" set="null"><c path="js.html.Node"/></ownerNode>
		<parentStyleSheet public="1" set="null"><c path="js.html.StyleSheet"/></parentStyleSheet>
		<title public="1" set="null"><c path="String"/></title>
		<media public="1" set="null"><c path="js.html.MediaList"/></media>
		<disabled public="1"><x path="Bool"/></disabled>
		<meta><m n=":native"><e>"StyleSheet"</e></m></meta>
	</class>
	<class path="js.html.CSSStyleSheet" params="" file="C:\HaxeToolkit\haxe\std/js/html/CSSStyleSheet.hx" extern="1">
		<extends path="js.html.StyleSheet"/>
		<ownerRule public="1" set="null"><c path="js.html.CSSRule"/></ownerRule>
		<cssRules public="1" set="null"><c path="js.html.CSSRuleList"/></cssRules>
		<insertRule public="1" set="method">
			<f a="rule:index">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</insertRule>
		<deleteRule public="1" set="method">
			<f a="index">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</deleteRule>
		<meta><m n=":native"><e>"CSSStyleSheet"</e></m></meta>
	</class>
	<class path="js.html.CanvasElement" params="" file="C:\HaxeToolkit\haxe\std/js/html/CanvasElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<width public="1"><x path="Int"/></width>
		<height public="1"><x path="Int"/></height>
		<getContext public="1" set="method">
			<f a="contextId:?contextOptions">
				<c path="String"/>
				<d/>
				<d/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</getContext>
		<toDataURL public="1" set="method">
			<f a="?type:?encoderOptions" v="&quot;&quot;:">
				<c path="String"/>
				<d/>
				<c path="String"/>
			</f>
			<meta><m n=":value"><e>{type:""}</e></m></meta>
			<haxe_doc>@throws DOMError</haxe_doc>
		</toDataURL>
		<toBlob public="1" set="method">
			<f a="callback:?type:?encoderOptions" v=":&quot;&quot;:">
				<f a="">
					<c path="js.html.Blob"/>
					<x path="Void"/>
				</f>
				<c path="String"/>
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{type:""}</e></m></meta>
			<haxe_doc>@throws DOMError</haxe_doc>
		</toBlob>
		<getContext2d public="1" get="inline" set="null" line="41">
			<f a="?attribs">
				<a/>
				<c path="js.html.CanvasRenderingContext2D"/>
			</f>
			<haxe_doc>Shorthand for getting a CanvasRenderingContext2D.</haxe_doc>
		</getContext2d>
		<getContextWebGL public="1" get="inline" set="null" line="45">
			<f a="?attribs">
				<t path="js.html.webgl.ContextAttributes"/>
				<c path="js.html.webgl.RenderingContext"/>
			</f>
			<haxe_doc>Shorthand for getting a js.html.webgl.RenderingContext.</haxe_doc>
		</getContextWebGL>
		<meta><m n=":native"><e>"HTMLCanvasElement"</e></m></meta>
	</class>
	<class path="js.html.CanvasGradient" params="" file="C:\HaxeToolkit\haxe\std/js/html/CanvasGradient.hx" extern="1">
		<addColorStop public="1" set="method">
			<f a="offset:color">
				<x path="Float"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</addColorStop>
		<meta><m n=":native"><e>"CanvasGradient"</e></m></meta>
	</class>
	<class path="js.html.CanvasPattern" params="" file="C:\HaxeToolkit\haxe\std/js/html/CanvasPattern.hx" extern="1">
		<setTransform public="1" set="method"><f a="matrix">
	<c path="js.html.svg.Matrix"/>
	<x path="Void"/>
</f></setTransform>
		<meta><m n=":native"><e>"CanvasPattern"</e></m></meta>
	</class>
	<class path="js.html.CanvasRenderingContext2D" params="" file="C:\HaxeToolkit\haxe\std/js/html/CanvasRenderingContext2D.hx" extern="1">
		<canvas public="1" set="null"><c path="js.html.CanvasElement"/></canvas>
		<globalAlpha public="1"><x path="Float"/></globalAlpha>
		<globalCompositeOperation public="1"><c path="String"/></globalCompositeOperation>
		<strokeStyle public="1"><x path="haxe.extern.EitherType">
	<c path="String"/>
	<x path="haxe.extern.EitherType">
		<c path="js.html.CanvasGradient"/>
		<c path="js.html.CanvasPattern"/>
	</x>
</x></strokeStyle>
		<fillStyle public="1"><x path="haxe.extern.EitherType">
	<c path="String"/>
	<x path="haxe.extern.EitherType">
		<c path="js.html.CanvasGradient"/>
		<c path="js.html.CanvasPattern"/>
	</x>
</x></fillStyle>
		<shadowOffsetX public="1"><x path="Float"/></shadowOffsetX>
		<shadowOffsetY public="1"><x path="Float"/></shadowOffsetY>
		<shadowBlur public="1"><x path="Float"/></shadowBlur>
		<shadowColor public="1"><c path="String"/></shadowColor>
		<filter public="1"><c path="String"/></filter>
		<imageSmoothingEnabled public="1"><x path="Bool"/></imageSmoothingEnabled>
		<lineWidth public="1"><x path="Float"/></lineWidth>
		<lineCap public="1"><c path="String"/></lineCap>
		<lineJoin public="1"><c path="String"/></lineJoin>
		<miterLimit public="1"><x path="Float"/></miterLimit>
		<lineDashOffset public="1"><x path="Float"/></lineDashOffset>
		<font public="1"><c path="String"/></font>
		<textAlign public="1"><c path="String"/></textAlign>
		<textBaseline public="1"><c path="String"/></textBaseline>
		<save public="1" set="method"><f a=""><x path="Void"/></f></save>
		<restore public="1" set="method"><f a=""><x path="Void"/></f></restore>
		<scale public="1" set="method">
			<f a="x:y">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</scale>
		<rotate public="1" set="method">
			<f a="angle">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</rotate>
		<translate public="1" set="method">
			<f a="x:y">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</translate>
		<transform public="1" set="method">
			<f a="a:b:c:d:e:f">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</transform>
		<setTransform public="1" set="method">
			<f a="a:b:c:d:e:f">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</setTransform>
		<resetTransform public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</resetTransform>
		<createLinearGradient public="1" set="method"><f a="x0:y0:x1:y1">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="js.html.CanvasGradient"/>
</f></createLinearGradient>
		<createRadialGradient public="1" set="method">
			<f a="x0:y0:r0:x1:y1:r1">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="js.html.CanvasGradient"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</createRadialGradient>
		<createPattern public="1" set="method">
			<f a="image:repetition">
				<x path="haxe.extern.EitherType">
					<c path="js.html.ImageElement"/>
					<x path="haxe.extern.EitherType">
						<c path="js.html.CanvasElement"/>
						<c path="js.html.VideoElement"/>
					</x>
				</x>
				<c path="String"/>
				<c path="js.html.CanvasPattern"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</createPattern>
		<clearRect public="1" set="method"><f a="x:y:w:h">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></clearRect>
		<fillRect public="1" set="method"><f a="x:y:w:h">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></fillRect>
		<strokeRect public="1" set="method"><f a="x:y:w:h">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></strokeRect>
		<beginPath public="1" set="method"><f a=""><x path="Void"/></f></beginPath>
		<fill public="1" set="method">
			<f a="path:?winding" v=":&quot;nonzero&quot;">
				<c path="js.html.Path2D"/>
				<x path="js.html.CanvasWindingRule"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{winding:"nonzero"}</e></m></meta>
			<overloads><fill public="1" set="method">
	<f a="?winding" v="&quot;nonzero&quot;">
		<x path="js.html.CanvasWindingRule"/>
		<x path="Void"/>
	</f>
	<meta><m n=":value"><e>{winding:"nonzero"}</e></m></meta>
</fill></overloads>
		</fill>
		<stroke public="1" set="method">
			<f a="path">
				<c path="js.html.Path2D"/>
				<x path="Void"/>
			</f>
			<overloads><stroke public="1" set="method"><f a=""><x path="Void"/></f></stroke></overloads>
		</stroke>
		<drawFocusIfNeeded public="1" set="method"><f a="element">
	<c path="js.html.Element"/>
	<x path="Void"/>
</f></drawFocusIfNeeded>
		<drawCustomFocusRing public="1" set="method"><f a="element">
	<c path="js.html.Element"/>
	<x path="Bool"/>
</f></drawCustomFocusRing>
		<clip public="1" set="method">
			<f a="path:?winding" v=":&quot;nonzero&quot;">
				<c path="js.html.Path2D"/>
				<x path="js.html.CanvasWindingRule"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{winding:"nonzero"}</e></m></meta>
			<overloads><clip public="1" set="method">
	<f a="?winding" v="&quot;nonzero&quot;">
		<x path="js.html.CanvasWindingRule"/>
		<x path="Void"/>
	</f>
	<meta><m n=":value"><e>{winding:"nonzero"}</e></m></meta>
</clip></overloads>
		</clip>
		<isPointInPath public="1" set="method">
			<f a="path:x:y:?winding" v=":::&quot;nonzero&quot;">
				<c path="js.html.Path2D"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="js.html.CanvasWindingRule"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>{winding:"nonzero"}</e></m></meta>
			<overloads><isPointInPath public="1" set="method">
	<f a="x:y:?winding" v="::&quot;nonzero&quot;">
		<x path="Float"/>
		<x path="Float"/>
		<x path="js.html.CanvasWindingRule"/>
		<x path="Bool"/>
	</f>
	<meta><m n=":value"><e>{winding:"nonzero"}</e></m></meta>
</isPointInPath></overloads>
		</isPointInPath>
		<isPointInStroke public="1" set="method">
			<f a="path:x:y">
				<c path="js.html.Path2D"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<overloads><isPointInStroke public="1" set="method"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Bool"/>
</f></isPointInStroke></overloads>
		</isPointInStroke>
		<fillText public="1" set="method">
			<f a="text:x:y:?maxWidth">
				<c path="String"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</fillText>
		<strokeText public="1" set="method">
			<f a="text:x:y:?maxWidth">
				<c path="String"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</strokeText>
		<measureText public="1" set="method">
			<f a="text">
				<c path="String"/>
				<c path="js.html.TextMetrics"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</measureText>
		<drawImage public="1" set="method">
			<f a="image:sx:sy:sw:sh:dx:dy:dw:dh">
				<x path="haxe.extern.EitherType">
					<c path="js.html.ImageElement"/>
					<x path="haxe.extern.EitherType">
						<c path="js.html.CanvasElement"/>
						<c path="js.html.VideoElement"/>
					</x>
				</x>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
			<overloads>
				<drawImage public="1" set="method">
					<f a="image:dx:dy">
						<x path="haxe.extern.EitherType">
							<c path="js.html.ImageElement"/>
							<x path="haxe.extern.EitherType">
								<c path="js.html.CanvasElement"/>
								<c path="js.html.VideoElement"/>
							</x>
						</x>
						<x path="Float"/>
						<x path="Float"/>
						<x path="Void"/>
					</f>
					<haxe_doc>@throws DOMError</haxe_doc>
				</drawImage>
				<drawImage public="1" set="method">
					<f a="image:dx:dy:dw:dh">
						<x path="haxe.extern.EitherType">
							<c path="js.html.ImageElement"/>
							<x path="haxe.extern.EitherType">
								<c path="js.html.CanvasElement"/>
								<c path="js.html.VideoElement"/>
							</x>
						</x>
						<x path="Float"/>
						<x path="Float"/>
						<x path="Float"/>
						<x path="Float"/>
						<x path="Void"/>
					</f>
					<haxe_doc>@throws DOMError</haxe_doc>
				</drawImage>
			</overloads>
		</drawImage>
		<addHitRegion public="1" set="method">
			<f a="?options">
				<t path="js.html.HitRegionOptions"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</addHitRegion>
		<removeHitRegion public="1" set="method"><f a="id">
	<c path="String"/>
	<x path="Void"/>
</f></removeHitRegion>
		<clearHitRegions public="1" set="method"><f a=""><x path="Void"/></f></clearHitRegions>
		<createImageData public="1" set="method">
			<f a="imagedata">
				<c path="js.html.ImageData"/>
				<c path="js.html.ImageData"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
			<overloads><createImageData public="1" set="method">
	<f a="sw:sh">
		<x path="Float"/>
		<x path="Float"/>
		<c path="js.html.ImageData"/>
	</f>
	<haxe_doc>@throws DOMError</haxe_doc>
</createImageData></overloads>
		</createImageData>
		<getImageData public="1" set="method">
			<f a="sx:sy:sw:sh">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="js.html.ImageData"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</getImageData>
		<putImageData public="1" set="method">
			<f a="imagedata:dx:dy:dirtyX:dirtyY:dirtyWidth:dirtyHeight">
				<c path="js.html.ImageData"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
			<overloads><putImageData public="1" set="method">
	<f a="imagedata:dx:dy">
		<c path="js.html.ImageData"/>
		<x path="Float"/>
		<x path="Float"/>
		<x path="Void"/>
	</f>
	<haxe_doc>@throws DOMError</haxe_doc>
</putImageData></overloads>
		</putImageData>
		<setLineDash public="1" set="method"><f a="segments">
	<c path="Array"><x path="Float"/></c>
	<x path="Void"/>
</f></setLineDash>
		<getLineDash public="1" set="method"><f a=""><c path="Array"><x path="Float"/></c></f></getLineDash>
		<closePath public="1" set="method"><f a=""><x path="Void"/></f></closePath>
		<moveTo public="1" set="method"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></moveTo>
		<lineTo public="1" set="method"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></lineTo>
		<quadraticCurveTo public="1" set="method"><f a="cpx:cpy:x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></quadraticCurveTo>
		<bezierCurveTo public="1" set="method"><f a="cp1x:cp1y:cp2x:cp2y:x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></bezierCurveTo>
		<arcTo public="1" set="method">
			<f a="x1:y1:x2:y2:radius">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</arcTo>
		<rect public="1" set="method"><f a="x:y:w:h">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></rect>
		<arc public="1" set="method">
			<f a="x:y:radius:startAngle:endAngle:?anticlockwise" v=":::::false">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{anticlockwise:false}</e></m></meta>
			<haxe_doc>@throws DOMError</haxe_doc>
		</arc>
		<meta><m n=":native"><e>"CanvasRenderingContext2D"</e></m></meta>
	</class>
	<abstract path="js.html.CanvasWindingRule" params="" file="C:\HaxeToolkit\haxe\std/js/html/CanvasWindingRule.hx">
		<this><c path="String"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="js.html._CanvasWindingRule.CanvasWindingRule_Impl_" params="" file="C:\HaxeToolkit\haxe\std/js/html/CanvasWindingRule.hx" private="1" module="js.html.CanvasWindingRule"><meta>
	<m n=":keep"/>
	<m n=":enum"/>
</meta></class></impl>
	</abstract>
	<class path="js.html.CaretPosition" params="" file="C:\HaxeToolkit\haxe\std/js/html/CaretPosition.hx" extern="1">
		<offsetNode public="1" set="null"><c path="js.html.Node"/></offsetNode>
		<offset public="1" set="null"><x path="Int"/></offset>
		<getClientRect public="1" set="method"><f a=""><c path="js.html.DOMRect"/></f></getClientRect>
		<meta><m n=":native"><e>"CaretPosition"</e></m></meta>
	</class>
	<typedef path="js.html.ChromeFilePropertyBag" params="" file="C:\HaxeToolkit\haxe\std/js/html/ChromeFilePropertyBag.hx"><a>
	<type>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</type>
	<temporary>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</temporary>
	<name>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</name>
	<lastModified>
		<t path="Null"><x path="Int"/></t>
		<meta><m n=":optional"/></meta>
	</lastModified>
</a></typedef>
	<class path="js.html.Comment" params="" file="C:\HaxeToolkit\haxe\std/js/html/Comment.hx" extern="1">
		<extends path="js.html.CharacterData"/>
		<new public="1" set="method">
			<f a="?data" v="&quot;&quot;">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{data:""}</e></m></meta>
			<haxe_doc>@throws DOMError</haxe_doc>
		</new>
		<meta><m n=":native"><e>"Comment"</e></m></meta>
	</class>
	<class path="js.html.Console" params="" file="C:\HaxeToolkit\haxe\std/js/html/Console.hx" extern="1">
		<log public="1" set="method"><f a="data">
	<x path="haxe.extern.Rest"><d/></x>
	<x path="Void"/>
</f></log>
		<info public="1" set="method"><f a="data">
	<x path="haxe.extern.Rest"><d/></x>
	<x path="Void"/>
</f></info>
		<warn public="1" set="method"><f a="data">
	<x path="haxe.extern.Rest"><d/></x>
	<x path="Void"/>
</f></warn>
		<error public="1" set="method"><f a="data">
	<x path="haxe.extern.Rest"><d/></x>
	<x path="Void"/>
</f></error>
		<exception public="1" set="method"><f a="data">
	<x path="haxe.extern.Rest"><d/></x>
	<x path="Void"/>
</f></exception>
		<debug public="1" set="method"><f a="data">
	<x path="haxe.extern.Rest"><d/></x>
	<x path="Void"/>
</f></debug>
		<table public="1" set="method"><f a="data">
	<x path="haxe.extern.Rest"><d/></x>
	<x path="Void"/>
</f></table>
		<trace public="1" set="method"><f a=""><x path="Void"/></f></trace>
		<dir public="1" set="method"><f a="data">
	<x path="haxe.extern.Rest"><d/></x>
	<x path="Void"/>
</f></dir>
		<group public="1" set="method"><f a="data">
	<x path="haxe.extern.Rest"><d/></x>
	<x path="Void"/>
</f></group>
		<groupCollapsed public="1" set="method"><f a="data">
	<x path="haxe.extern.Rest"><d/></x>
	<x path="Void"/>
</f></groupCollapsed>
		<groupEnd public="1" set="method"><f a="data">
	<x path="haxe.extern.Rest"><d/></x>
	<x path="Void"/>
</f></groupEnd>
		<time public="1" set="method"><f a="?time">
	<d/>
	<x path="Void"/>
</f></time>
		<timeEnd public="1" set="method"><f a="?time">
	<d/>
	<x path="Void"/>
</f></timeEnd>
		<profile public="1" set="method"><f a="data">
	<x path="haxe.extern.Rest"><d/></x>
	<x path="Void"/>
</f></profile>
		<profileEnd public="1" set="method"><f a="data">
	<x path="haxe.extern.Rest"><d/></x>
	<x path="Void"/>
</f></profileEnd>
		<assert public="1" set="method"><f a="condition:data">
	<x path="Bool"/>
	<x path="haxe.extern.Rest"><d/></x>
	<x path="Void"/>
</f></assert>
		<count public="1" set="method"><f a="data">
	<x path="haxe.extern.Rest"><d/></x>
	<x path="Void"/>
</f></count>
		<clear public="1" set="method"><f a=""><x path="Void"/></f></clear>
		<meta><m n=":native"><e>"Console"</e></m></meta>
	</class>
	<class path="js.html.ContentElement" params="" file="C:\HaxeToolkit\haxe\std/js/html/ContentElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<select public="1"><c path="String"/></select>
		<getDistributedNodes public="1" set="method"><f a=""><c path="js.html.NodeList"/></f></getDistributedNodes>
		<meta><m n=":native"><e>"HTMLContentElement"</e></m></meta>
	</class>
	<typedef path="js.html.ConvertCoordinateOptions" params="" file="C:\HaxeToolkit\haxe\std/js/html/ConvertCoordinateOptions.hx"><a>
	<toBox>
		<t path="Null"><d/></t>
		<meta><m n=":optional"/></meta>
	</toBox>
	<fromBox>
		<t path="Null"><d/></t>
		<meta><m n=":optional"/></meta>
	</fromBox>
</a></typedef>
	<class path="js.html.Coordinates" params="" file="C:\HaxeToolkit\haxe\std/js/html/Coordinates.hx" extern="1">
		<latitude public="1" set="null"><x path="Float"/></latitude>
		<longitude public="1" set="null"><x path="Float"/></longitude>
		<altitude public="1" set="null"><x path="Float"/></altitude>
		<accuracy public="1" set="null"><x path="Float"/></accuracy>
		<altitudeAccuracy public="1" set="null"><x path="Float"/></altitudeAccuracy>
		<heading public="1" set="null"><x path="Float"/></heading>
		<speed public="1" set="null"><x path="Float"/></speed>
		<meta><m n=":native"><e>"Coordinates"</e></m></meta>
	</class>
	<typedef path="js.html.CreateFileOptions" params="" file="C:\HaxeToolkit\haxe\std/js/html/CreateFileOptions.hx"><a>
	<ifExists>
		<t path="Null"><d/></t>
		<meta><m n=":optional"/></meta>
	</ifExists>
	<data>
		<t path="Null"><x path="haxe.extern.EitherType">
	<c path="String"/>
	<x path="haxe.extern.EitherType">
		<c path="js.html.Blob"/>
		<x path="haxe.extern.EitherType">
			<c path="js.html.ArrayBuffer"/>
			<c path="js.html.ArrayBufferView"/>
		</x>
	</x>
</x></t>
		<meta><m n=":optional"/></meta>
	</data>
</a></typedef>
	<class path="js.html.DListElement" params="" file="C:\HaxeToolkit\haxe\std/js/html/DListElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<compact public="1"><x path="Bool"/></compact>
		<meta><m n=":native"><e>"HTMLDListElement"</e></m></meta>
	</class>
	<class path="js.html.DOMError" params="" file="C:\HaxeToolkit\haxe\std/js/html/DOMError.hx" extern="1">
		<name public="1" set="null"><c path="String"/></name>
		<message public="1" set="null"><c path="String"/></message>
		<new public="1" set="method">
			<f a="name:?message" v=":&quot;&quot;">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{message:""}</e></m></meta>
			<haxe_doc>@throws DOMError</haxe_doc>
		</new>
		<meta><m n=":native"><e>"DOMError"</e></m></meta>
	</class>
	<class path="js.html.DOMImplementation" params="" file="C:\HaxeToolkit\haxe\std/js/html/DOMImplementation.hx" extern="1">
		<hasFeature public="1" set="method"><f a="feature:version">
	<c path="String"/>
	<c path="String"/>
	<x path="Bool"/>
</f></hasFeature>
		<createDocumentType public="1" set="method">
			<f a="qualifiedName:publicId:systemId">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<c path="js.html.DocumentType"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</createDocumentType>
		<createDocument public="1" set="method">
			<f a="namespace_:qualifiedName:?doctype">
				<c path="String"/>
				<c path="String"/>
				<c path="js.html.DocumentType"/>
				<c path="js.html.HTMLDocument"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</createDocument>
		<createHTMLDocument public="1" set="method">
			<f a="?title">
				<c path="String"/>
				<c path="js.html.HTMLDocument"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</createHTMLDocument>
		<meta><m n=":native"><e>"DOMImplementation"</e></m></meta>
	</class>
	<class path="js.html.DOMPointReadOnly" params="" file="C:\HaxeToolkit\haxe\std/js/html/DOMPointReadOnly.hx" extern="1">
		<x public="1" set="null"><x path="Float"/></x>
		<y public="1" set="null"><x path="Float"/></y>
		<z public="1" set="null"><x path="Float"/></z>
		<w public="1" set="null"><x path="Float"/></w>
		<meta><m n=":native"><e>"DOMPointReadOnly"</e></m></meta>
	</class>
	<class path="js.html.DOMPoint" params="" file="C:\HaxeToolkit\haxe\std/js/html/DOMPoint.hx" extern="1">
		<extends path="js.html.DOMPointReadOnly"/>
		<new public="1" set="method">
			<f a="x:y:?z:?w" v="::0.0:1.0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{w:1.0,z:0.0}</e></m></meta>
			<haxe_doc>@throws DOMError</haxe_doc>
			<overloads><new public="1" set="method">
	<f a="?point">
		<t path="js.html.DOMPointInit"/>
		<x path="Void"/>
	</f>
	<haxe_doc>@throws DOMError</haxe_doc>
</new></overloads>
		</new>
		<meta><m n=":native"><e>"DOMPoint"</e></m></meta>
	</class>
	<typedef path="js.html.DOMPointInit" params="" file="C:\HaxeToolkit\haxe\std/js/html/DOMPointInit.hx"><a>
	<z>
		<t path="Null"><x path="Float"/></t>
		<meta><m n=":optional"/></meta>
	</z>
	<y>
		<t path="Null"><x path="Float"/></t>
		<meta><m n=":optional"/></meta>
	</y>
	<x>
		<t path="Null"><x path="Float"/></t>
		<meta><m n=":optional"/></meta>
	</x>
	<w>
		<t path="Null"><x path="Float"/></t>
		<meta><m n=":optional"/></meta>
	</w>
</a></typedef>
	<class path="js.html.DOMQuad" params="" file="C:\HaxeToolkit\haxe\std/js/html/DOMQuad.hx" extern="1">
		<p1 public="1" set="null"><c path="js.html.DOMPoint"/></p1>
		<p2 public="1" set="null"><c path="js.html.DOMPoint"/></p2>
		<p3 public="1" set="null"><c path="js.html.DOMPoint"/></p3>
		<p4 public="1" set="null"><c path="js.html.DOMPoint"/></p4>
		<bounds public="1" set="null"><c path="js.html.DOMRectReadOnly"/></bounds>
		<new public="1" set="method">
			<f a="rect">
				<c path="js.html.DOMRectReadOnly"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
			<overloads><new public="1" set="method">
	<f a="?p1:?p2:?p3:?p4">
		<t path="js.html.DOMPointInit"/>
		<t path="js.html.DOMPointInit"/>
		<t path="js.html.DOMPointInit"/>
		<t path="js.html.DOMPointInit"/>
		<x path="Void"/>
	</f>
	<haxe_doc>@throws DOMError</haxe_doc>
</new></overloads>
		</new>
		<meta><m n=":native"><e>"DOMQuad"</e></m></meta>
	</class>
	<class path="js.html.DOMRectReadOnly" params="" file="C:\HaxeToolkit\haxe\std/js/html/DOMRectReadOnly.hx" extern="1">
		<x public="1" set="null"><x path="Float"/></x>
		<y public="1" set="null"><x path="Float"/></y>
		<width public="1" set="null"><x path="Float"/></width>
		<height public="1" set="null"><x path="Float"/></height>
		<top public="1" set="null"><x path="Float"/></top>
		<right public="1" set="null"><x path="Float"/></right>
		<bottom public="1" set="null"><x path="Float"/></bottom>
		<left public="1" set="null"><x path="Float"/></left>
		<meta><m n=":native"><e>"DOMRectReadOnly"</e></m></meta>
	</class>
	<class path="js.html.DOMRect" params="" file="C:\HaxeToolkit\haxe\std/js/html/DOMRect.hx" extern="1">
		<extends path="js.html.DOMRectReadOnly"/>
		<new public="1" set="method">
			<f a="x:y:width:height">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
			<overloads><new public="1" set="method">
	<f a=""><x path="Void"/></f>
	<haxe_doc>@throws DOMError</haxe_doc>
</new></overloads>
		</new>
		<meta><m n=":native"><e>"DOMRect"</e></m></meta>
	</class>
	<class path="js.html.DOMRectList" params="" file="C:\HaxeToolkit\haxe\std/js/html/DOMRectList.hx" extern="1">
		<length public="1" set="null"><x path="Int"/></length>
		<item public="1" set="method"><f a="index">
	<x path="Int"/>
	<c path="js.html.DOMRect"/>
</f></item>
		<meta><m n=":native"><e>"DOMRectList"</e></m></meta>
	</class>
	<class path="js.html.DOMTokenList" params="" file="C:\HaxeToolkit\haxe\std/js/html/DOMTokenList.hx" extern="1">
		<length public="1" set="null"><x path="Int"/></length>
		<item public="1" set="method"><f a="index">
	<x path="Int"/>
	<c path="String"/>
</f></item>
		<contains public="1" set="method">
			<f a="token">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</contains>
		<add public="1" set="method">
			<f a="tokens">
				<x path="haxe.extern.Rest"><c path="String"/></x>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</add>
		<remove public="1" set="method">
			<f a="tokens">
				<x path="haxe.extern.Rest"><c path="String"/></x>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</remove>
		<toggle public="1" set="method">
			<f a="token:?force">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</toggle>
		<meta><m n=":native"><e>"DOMTokenList"</e></m></meta>
	</class>
	<class path="js.html.DOMSettableTokenList" params="" file="C:\HaxeToolkit\haxe\std/js/html/DOMSettableTokenList.hx" extern="1">
		<extends path="js.html.DOMTokenList"/>
		<value public="1"><c path="String"/></value>
		<meta><m n=":native"><e>"DOMSettableTokenList"</e></m></meta>
	</class>
	<class path="js.html.DOMStringList" params="" file="C:\HaxeToolkit\haxe\std/js/html/DOMStringList.hx" extern="1">
		<length public="1" set="null"><x path="Int"/></length>
		<item public="1" set="method"><f a="index">
	<x path="Int"/>
	<c path="String"/>
</f></item>
		<contains public="1" set="method"><f a="string">
	<c path="String"/>
	<x path="Bool"/>
</f></contains>
		<meta><m n=":native"><e>"DOMStringList"</e></m></meta>
	</class>
	<class path="js.html.DOMStringMap" params="" file="C:\HaxeToolkit\haxe\std/js/html/DOMStringMap.hx" extern="1">
		<meta><m n=":native"><e>"DOMStringMap"</e></m></meta>
		<haxe_dynamic><c path="String"/></haxe_dynamic>
	</class>
	<class path="js.html.DataListElement" params="" file="C:\HaxeToolkit\haxe\std/js/html/DataListElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<options public="1" set="null"><c path="js.html.HTMLCollection"/></options>
		<meta><m n=":native"><e>"HTMLDataListElement"</e></m></meta>
	</class>
	<abstract path="js.html.DirectionSetting" params="" file="C:\HaxeToolkit\haxe\std/js/html/DirectionSetting.hx">
		<this><c path="String"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="js.html._DirectionSetting.DirectionSetting_Impl_" params="" file="C:\HaxeToolkit\haxe\std/js/html/DirectionSetting.hx" private="1" module="js.html.DirectionSetting"><meta>
	<m n=":keep"/>
	<m n=":enum"/>
</meta></class></impl>
	</abstract>
	<class path="js.html.DirectoryElement" params="" file="C:\HaxeToolkit\haxe\std/js/html/DirectoryElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<compact public="1"><x path="Bool"/></compact>
		<meta><m n=":native"><e>"HTMLDirectoryElement"</e></m></meta>
	</class>
	<class path="js.html.DivElement" params="" file="C:\HaxeToolkit\haxe\std/js/html/DivElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<align public="1"><c path="String"/></align>
		<meta><m n=":native"><e>"HTMLDivElement"</e></m></meta>
	</class>
	<class path="js.html.Document" params="" file="C:\HaxeToolkit\haxe\std/js/html/Document.hx" extern="1">
		<extends path="js.html.Node"/>
		<implementation public="1" set="null"><c path="js.html.DOMImplementation"/></implementation>
		<URL public="1" set="null"><c path="String"/></URL>
		<documentURI public="1" set="null"><c path="String"/></documentURI>
		<compatMode public="1" set="null"><c path="String"/></compatMode>
		<characterSet public="1" set="null"><c path="String"/></characterSet>
		<contentType public="1" set="null"><c path="String"/></contentType>
		<doctype public="1" set="null"><c path="js.html.DocumentType"/></doctype>
		<documentElement public="1" set="null"><c path="js.html.Element"/></documentElement>
		<inputEncoding public="1" set="null"><c path="String"/></inputEncoding>
		<fullscreenEnabled public="1" set="null"><x path="Bool"/></fullscreenEnabled>
		<fullscreenElement public="1" set="null"><c path="js.html.Element"/></fullscreenElement>
		<onfullscreenchange public="1"><x path="haxe.Function"/></onfullscreenchange>
		<onfullscreenerror public="1"><x path="haxe.Function"/></onfullscreenerror>
		<location public="1" set="null"><c path="js.html.Location"/></location>
		<referrer public="1" set="null"><c path="String"/></referrer>
		<lastModified public="1" set="null"><c path="String"/></lastModified>
		<readyState public="1" set="null"><c path="String"/></readyState>
		<title public="1"><c path="String"/></title>
		<dir public="1"><c path="String"/></dir>
		<defaultView public="1" set="null"><c path="js.html.Window"/></defaultView>
		<activeElement public="1" set="null"><c path="js.html.Element"/></activeElement>
		<onreadystatechange public="1"><x path="haxe.Function"/></onreadystatechange>
		<onwheel public="1"><x path="haxe.Function"/></onwheel>
		<oncopy public="1"><x path="haxe.Function"/></oncopy>
		<oncut public="1"><x path="haxe.Function"/></oncut>
		<onpaste public="1"><x path="haxe.Function"/></onpaste>
		<onbeforescriptexecute public="1"><x path="haxe.Function"/></onbeforescriptexecute>
		<onafterscriptexecute public="1"><x path="haxe.Function"/></onafterscriptexecute>
		<currentScript public="1" set="null"><c path="js.html.Element"/></currentScript>
		<pointerLockElement public="1" set="null"><c path="js.html.Element"/></pointerLockElement>
		<hidden public="1" set="null"><x path="Bool"/></hidden>
		<visibilityState public="1" set="null"><x path="js.html.VisibilityState"/></visibilityState>
		<styleSheets public="1" set="null"><c path="js.html.StyleSheetList"/></styleSheets>
		<selectedStyleSheetSet public="1"><c path="String"/></selectedStyleSheetSet>
		<lastStyleSheetSet public="1" set="null"><c path="String"/></lastStyleSheetSet>
		<preferredStyleSheetSet public="1" set="null"><c path="String"/></preferredStyleSheetSet>
		<styleSheetSets public="1" set="null"><c path="js.html.DOMStringList"/></styleSheetSets>
		<timeline public="1" set="null"><c path="js.html.AnimationTimeline"/></timeline>
		<fonts public="1" set="null"><c path="js.html.FontFaceSet"/></fonts>
		<onabort public="1"><x path="haxe.Function"/></onabort>
		<onblur public="1"><x path="haxe.Function"/></onblur>
		<onfocus public="1"><x path="haxe.Function"/></onfocus>
		<oncanplay public="1"><x path="haxe.Function"/></oncanplay>
		<oncanplaythrough public="1"><x path="haxe.Function"/></oncanplaythrough>
		<onchange public="1"><x path="haxe.Function"/></onchange>
		<onclick public="1"><x path="haxe.Function"/></onclick>
		<oncontextmenu public="1"><x path="haxe.Function"/></oncontextmenu>
		<ondblclick public="1"><x path="haxe.Function"/></ondblclick>
		<ondrag public="1"><x path="haxe.Function"/></ondrag>
		<ondragend public="1"><x path="haxe.Function"/></ondragend>
		<ondragenter public="1"><x path="haxe.Function"/></ondragenter>
		<ondragleave public="1"><x path="haxe.Function"/></ondragleave>
		<ondragover public="1"><x path="haxe.Function"/></ondragover>
		<ondragstart public="1"><x path="haxe.Function"/></ondragstart>
		<ondrop public="1"><x path="haxe.Function"/></ondrop>
		<ondurationchange public="1"><x path="haxe.Function"/></ondurationchange>
		<onemptied public="1"><x path="haxe.Function"/></onemptied>
		<onended public="1"><x path="haxe.Function"/></onended>
		<oninput public="1"><x path="haxe.Function"/></oninput>
		<oninvalid public="1"><x path="haxe.Function"/></oninvalid>
		<onkeydown public="1"><x path="haxe.Function"/></onkeydown>
		<onkeypress public="1"><x path="haxe.Function"/></onkeypress>
		<onkeyup public="1"><x path="haxe.Function"/></onkeyup>
		<onload public="1"><x path="haxe.Function"/></onload>
		<onloadeddata public="1"><x path="haxe.Function"/></onloadeddata>
		<onloadedmetadata public="1"><x path="haxe.Function"/></onloadedmetadata>
		<onloadstart public="1"><x path="haxe.Function"/></onloadstart>
		<onmousedown public="1"><x path="haxe.Function"/></onmousedown>
		<onmouseenter public="1"><x path="haxe.Function"/></onmouseenter>
		<onmouseleave public="1"><x path="haxe.Function"/></onmouseleave>
		<onmousemove public="1"><x path="haxe.Function"/></onmousemove>
		<onmouseout public="1"><x path="haxe.Function"/></onmouseout>
		<onmouseover public="1"><x path="haxe.Function"/></onmouseover>
		<onmouseup public="1"><x path="haxe.Function"/></onmouseup>
		<onpause public="1"><x path="haxe.Function"/></onpause>
		<onplay public="1"><x path="haxe.Function"/></onplay>
		<onplaying public="1"><x path="haxe.Function"/></onplaying>
		<onprogress public="1"><x path="haxe.Function"/></onprogress>
		<onratechange public="1"><x path="haxe.Function"/></onratechange>
		<onreset public="1"><x path="haxe.Function"/></onreset>
		<onscroll public="1"><x path="haxe.Function"/></onscroll>
		<onseeked public="1"><x path="haxe.Function"/></onseeked>
		<onseeking public="1"><x path="haxe.Function"/></onseeking>
		<onselect public="1"><x path="haxe.Function"/></onselect>
		<onshow public="1"><x path="haxe.Function"/></onshow>
		<onstalled public="1"><x path="haxe.Function"/></onstalled>
		<onsubmit public="1"><x path="haxe.Function"/></onsubmit>
		<onsuspend public="1"><x path="haxe.Function"/></onsuspend>
		<ontimeupdate public="1"><x path="haxe.Function"/></ontimeupdate>
		<onvolumechange public="1"><x path="haxe.Function"/></onvolumechange>
		<onwaiting public="1"><x path="haxe.Function"/></onwaiting>
		<onpointercancel public="1"><x path="haxe.Function"/></onpointercancel>
		<onpointerdown public="1"><x path="haxe.Function"/></onpointerdown>
		<onpointerup public="1"><x path="haxe.Function"/></onpointerup>
		<onpointermove public="1"><x path="haxe.Function"/></onpointermove>
		<onpointerout public="1"><x path="haxe.Function"/></onpointerout>
		<onpointerover public="1"><x path="haxe.Function"/></onpointerover>
		<onpointerenter public="1"><x path="haxe.Function"/></onpointerenter>
		<onpointerleave public="1"><x path="haxe.Function"/></onpointerleave>
		<ongotpointercapture public="1"><x path="haxe.Function"/></ongotpointercapture>
		<onlostpointercapture public="1"><x path="haxe.Function"/></onlostpointercapture>
		<onpointerlockchange public="1"><x path="haxe.Function"/></onpointerlockchange>
		<onpointerlockerror public="1"><x path="haxe.Function"/></onpointerlockerror>
		<onerror public="1"><x path="haxe.Function"/></onerror>
		<children public="1" set="null"><c path="js.html.HTMLCollection"/></children>
		<firstElementChild public="1" set="null"><c path="js.html.Element"/></firstElementChild>
		<lastElementChild public="1" set="null"><c path="js.html.Element"/></lastElementChild>
		<childElementCount public="1" set="null"><x path="Int"/></childElementCount>
		<ontouchstart public="1"><x path="haxe.Function"/></ontouchstart>
		<ontouchend public="1"><x path="haxe.Function"/></ontouchend>
		<ontouchmove public="1"><x path="haxe.Function"/></ontouchmove>
		<ontouchcancel public="1"><x path="haxe.Function"/></ontouchcancel>
		<getElementsByTagName public="1" set="method"><f a="localName">
	<c path="String"/>
	<c path="js.html.HTMLCollection"/>
</f></getElementsByTagName>
		<getElementsByTagNameNS public="1" set="method">
			<f a="namespace_:localName">
				<c path="String"/>
				<c path="String"/>
				<c path="js.html.HTMLCollection"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</getElementsByTagNameNS>
		<getElementsByClassName public="1" set="method"><f a="classNames">
	<c path="String"/>
	<c path="js.html.HTMLCollection"/>
</f></getElementsByClassName>
		<getElementById public="1" set="method"><f a="elementId">
	<c path="String"/>
	<c path="js.html.Element"/>
</f></getElementById>
		<createElement public="1" set="method">
			<f a="localName:typeExtension">
				<c path="String"/>
				<c path="String"/>
				<c path="js.html.Element"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
			<overloads><createElement public="1" set="method">
	<f a="localName">
		<c path="String"/>
		<c path="js.html.Element"/>
	</f>
	<haxe_doc>@throws DOMError</haxe_doc>
</createElement></overloads>
		</createElement>
		<createElementNS public="1" set="method">
			<f a="namespace_:qualifiedName:typeExtension">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<c path="js.html.Element"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
			<overloads><createElementNS public="1" set="method">
	<f a="namespace_:qualifiedName">
		<c path="String"/>
		<c path="String"/>
		<c path="js.html.Element"/>
	</f>
	<haxe_doc>@throws DOMError</haxe_doc>
</createElementNS></overloads>
		</createElementNS>
		<createDocumentFragment public="1" set="method"><f a=""><c path="js.html.DocumentFragment"/></f></createDocumentFragment>
		<createTextNode public="1" set="method"><f a="data">
	<c path="String"/>
	<c path="js.html.Text"/>
</f></createTextNode>
		<createComment public="1" set="method"><f a="data">
	<c path="String"/>
	<c path="js.html.Comment"/>
</f></createComment>
		<createProcessingInstruction public="1" set="method">
			<f a="target:data">
				<c path="String"/>
				<c path="String"/>
				<c path="js.html.ProcessingInstruction"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</createProcessingInstruction>
		<importNode public="1" set="method">
			<f a="node:?deep" v=":false">
				<c path="js.html.Node"/>
				<x path="Bool"/>
				<c path="js.html.Node"/>
			</f>
			<meta><m n=":value"><e>{deep:false}</e></m></meta>
			<haxe_doc>@throws DOMError</haxe_doc>
		</importNode>
		<adoptNode public="1" set="method">
			<f a="node">
				<c path="js.html.Node"/>
				<c path="js.html.Node"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</adoptNode>
		<createEvent public="1" set="method">
			<f a="interface_">
				<c path="String"/>
				<c path="js.html.Event"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</createEvent>
		<createRange public="1" set="method">
			<f a=""><c path="js.html.Range"/></f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</createRange>
		<createNodeIterator public="1" set="method">
			<f a="root:?whatToShow:?filter" v=":&apos;???&apos;:">
				<c path="js.html.Node"/>
				<x path="Int"/>
				<c path="js.html.NodeFilter"/>
				<c path="js.html.NodeIterator"/>
			</f>
			<meta><m n=":value"><e>{whatToShow:'???'}</e></m></meta>
			<haxe_doc>@throws DOMError</haxe_doc>
		</createNodeIterator>
		<createTreeWalker public="1" set="method">
			<f a="root:?whatToShow:?filter" v=":&apos;???&apos;:">
				<c path="js.html.Node"/>
				<x path="Int"/>
				<c path="js.html.NodeFilter"/>
				<c path="js.html.TreeWalker"/>
			</f>
			<meta><m n=":value"><e>{whatToShow:'???'}</e></m></meta>
			<haxe_doc>@throws DOMError</haxe_doc>
		</createTreeWalker>
		<createCDATASection public="1" set="method">
			<f a="data">
				<c path="String"/>
				<c path="js.html.CDATASection"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</createCDATASection>
		<createAttribute public="1" set="method">
			<f a="name">
				<c path="String"/>
				<c path="js.html.Attr"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</createAttribute>
		<createAttributeNS public="1" set="method">
			<f a="namespace_:name">
				<c path="String"/>
				<c path="String"/>
				<c path="js.html.Attr"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</createAttributeNS>
		<exitFullscreen public="1" set="method"><f a=""><x path="Void"/></f></exitFullscreen>
		<hasFocus public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</hasFocus>
		<releaseCapture public="1" set="method"><f a=""><x path="Void"/></f></releaseCapture>
		<exitPointerLock public="1" set="method"><f a=""><x path="Void"/></f></exitPointerLock>
		<registerElement public="1" set="method">
			<f a="name:?options">
				<c path="String"/>
				<t path="js.html.ElementRegistrationOptions"/>
				<d/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</registerElement>
		<enableStyleSheetsForSet public="1" set="method"><f a="name">
	<c path="String"/>
	<x path="Void"/>
</f></enableStyleSheetsForSet>
		<elementFromPoint public="1" set="method"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<c path="js.html.Element"/>
</f></elementFromPoint>
		<caretPositionFromPoint public="1" set="method"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<c path="js.html.CaretPosition"/>
</f></caretPositionFromPoint>
		<querySelector public="1" set="method">
			<f a="selectors">
				<c path="String"/>
				<c path="js.html.Element"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</querySelector>
		<querySelectorAll public="1" set="method">
			<f a="selectors">
				<c path="String"/>
				<c path="js.html.NodeList"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</querySelectorAll>
		<createTouch public="1" set="method">
			<f a="?view:?target:?identifier:?pageX:?pageY:?screenX:?screenY:?clientX:?clientY:?radiusX:?radiusY:?rotationAngle:?force" v="::0:0:0:0:0:0:0:0:0:0.0:0.0">
				<c path="js.html.Window"/>
				<c path="js.html.EventTarget"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="js.html.Touch"/>
			</f>
			<meta><m n=":value"><e>{force:0.0,rotationAngle:0.0,radiusY:0,radiusX:0,clientY:0,clientX:0,screenY:0,screenX:0,pageY:0,pageX:0,identifier:0}</e></m></meta>
		</createTouch>
		<createTouchList public="1" set="method">
			<f a="touches">
				<c path="Array"><c path="js.html.Touch"/></c>
				<c path="js.html.TouchList"/>
			</f>
			<overloads>
				<createTouchList public="1" set="method"><f a="touch:touches">
	<c path="js.html.Touch"/>
	<x path="haxe.extern.Rest"><c path="js.html.Touch"/></x>
	<c path="js.html.TouchList"/>
</f></createTouchList>
				<createTouchList public="1" set="method"><f a=""><c path="js.html.TouchList"/></f></createTouchList>
			</overloads>
		</createTouchList>
		<convertQuadFromNode public="1" set="method">
			<f a="quad:from:?options">
				<c path="js.html.DOMQuad"/>
				<x path="haxe.extern.EitherType">
					<c path="js.html.Text"/>
					<x path="haxe.extern.EitherType">
						<c path="js.html.Element"/>
						<c path="js.html.HTMLDocument"/>
					</x>
				</x>
				<t path="js.html.ConvertCoordinateOptions"/>
				<c path="js.html.DOMQuad"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</convertQuadFromNode>
		<convertRectFromNode public="1" set="method">
			<f a="rect:from:?options">
				<c path="js.html.DOMRectReadOnly"/>
				<x path="haxe.extern.EitherType">
					<c path="js.html.Text"/>
					<x path="haxe.extern.EitherType">
						<c path="js.html.Element"/>
						<c path="js.html.HTMLDocument"/>
					</x>
				</x>
				<t path="js.html.ConvertCoordinateOptions"/>
				<c path="js.html.DOMQuad"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</convertRectFromNode>
		<convertPointFromNode public="1" set="method">
			<f a="point:from:?options">
				<t path="js.html.DOMPointInit"/>
				<x path="haxe.extern.EitherType">
					<c path="js.html.Text"/>
					<x path="haxe.extern.EitherType">
						<c path="js.html.Element"/>
						<c path="js.html.HTMLDocument"/>
					</x>
				</x>
				<t path="js.html.ConvertCoordinateOptions"/>
				<c path="js.html.DOMPoint"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</convertPointFromNode>
		<createExpression public="1" set="method">
			<f a="expression:resolver">
				<c path="String"/>
				<c path="js.html.XPathNSResolver"/>
				<c path="js.html.XPathExpression"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</createExpression>
		<createNSResolver public="1" set="method"><f a="nodeResolver">
	<c path="js.html.Node"/>
	<c path="js.html.Node"/>
</f></createNSResolver>
		<evaluate public="1" set="method">
			<f a="expression:contextNode:resolver:type:result">
				<c path="String"/>
				<c path="js.html.Node"/>
				<c path="js.html.XPathNSResolver"/>
				<x path="Int"/>
				<d/>
				<c path="js.html.XPathResult"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</evaluate>
		<new public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</new>
		<meta><m n=":native"><e>"Document"</e></m></meta>
	</class>
	<class path="js.html.DocumentFragment" params="" file="C:\HaxeToolkit\haxe\std/js/html/DocumentFragment.hx" extern="1">
		<extends path="js.html.Node"/>
		<children public="1" set="null"><c path="js.html.HTMLCollection"/></children>
		<firstElementChild public="1" set="null"><c path="js.html.Element"/></firstElementChild>
		<lastElementChild public="1" set="null"><c path="js.html.Element"/></lastElementChild>
		<childElementCount public="1" set="null"><x path="Int"/></childElementCount>
		<getElementById public="1" set="method"><f a="elementId">
	<c path="String"/>
	<c path="js.html.Element"/>
</f></getElementById>
		<querySelector public="1" set="method">
			<f a="selectors">
				<c path="String"/>
				<c path="js.html.Element"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</querySelector>
		<querySelectorAll public="1" set="method">
			<f a="selectors">
				<c path="String"/>
				<c path="js.html.NodeList"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</querySelectorAll>
		<new public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</new>
		<meta><m n=":native"><e>"DocumentFragment"</e></m></meta>
	</class>
	<class path="js.html.DocumentType" params="" file="C:\HaxeToolkit\haxe\std/js/html/DocumentType.hx" extern="1">
		<extends path="js.html.Node"/>
		<name public="1" set="null"><c path="String"/></name>
		<publicId public="1" set="null"><c path="String"/></publicId>
		<systemId public="1" set="null"><c path="String"/></systemId>
		<internalSubset public="1" set="null"><c path="String"/></internalSubset>
		<remove public="1" set="method"><f a=""><x path="Void"/></f></remove>
		<meta><m n=":native"><e>"DocumentType"</e></m></meta>
	</class>
	<typedef path="js.html.ElementRegistrationOptions" params="" file="C:\HaxeToolkit\haxe\std/js/html/ElementRegistrationOptions.hx"><a>
	<prototype>
		<t path="Null"><d/></t>
		<meta><m n=":optional"/></meta>
	</prototype>
	<extends_>
		<t path="Null"><c path="String"/></t>
		<meta>
			<m n=":native"><e>"extends"</e></m>
			<m n=":optional"/>
		</meta>
	</extends_>
</a></typedef>
	<class path="js.html.EmbedElement" params="" file="C:\HaxeToolkit\haxe\std/js/html/EmbedElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<src public="1"><c path="String"/></src>
		<type public="1"><c path="String"/></type>
		<width public="1"><c path="String"/></width>
		<height public="1"><c path="String"/></height>
		<align public="1"><c path="String"/></align>
		<name public="1"><c path="String"/></name>
		<getSVGDocument public="1" set="method"><f a=""><c path="js.html.HTMLDocument"/></f></getSVGDocument>
		<meta><m n=":native"><e>"HTMLEmbedElement"</e></m></meta>
	</class>
	<class path="js.html.Event" params="" file="C:\HaxeToolkit\haxe\std/js/html/Event.hx" extern="1">
		<NONE public="1" get="inline" set="null" expr="0" line="30" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</NONE>
		<CAPTURING_PHASE public="1" get="inline" set="null" expr="1" line="31" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</CAPTURING_PHASE>
		<AT_TARGET public="1" get="inline" set="null" expr="2" line="32" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2</e></m></meta>
		</AT_TARGET>
		<BUBBLING_PHASE public="1" get="inline" set="null" expr="3" line="33" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3</e></m></meta>
		</BUBBLING_PHASE>
		<ALT_MASK public="1" get="inline" set="null" expr="1" line="34" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</ALT_MASK>
		<CONTROL_MASK public="1" get="inline" set="null" expr="2" line="35" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2</e></m></meta>
		</CONTROL_MASK>
		<SHIFT_MASK public="1" get="inline" set="null" expr="4" line="36" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>4</e></m></meta>
		</SHIFT_MASK>
		<META_MASK public="1" get="inline" set="null" expr="8" line="37" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>8</e></m></meta>
		</META_MASK>
		<type public="1" set="null"><c path="String"/></type>
		<target public="1" set="null"><c path="js.html.EventTarget"/></target>
		<currentTarget public="1" set="null"><c path="js.html.EventTarget"/></currentTarget>
		<eventPhase public="1" set="null"><x path="Int"/></eventPhase>
		<bubbles public="1" set="null"><x path="Bool"/></bubbles>
		<cancelable public="1" set="null"><x path="Bool"/></cancelable>
		<defaultPrevented public="1" set="null"><x path="Bool"/></defaultPrevented>
		<isTrusted public="1" set="null"><x path="Bool"/></isTrusted>
		<timeStamp public="1" set="null"><x path="Float"/></timeStamp>
		<originalTarget public="1" set="null"><c path="js.html.EventTarget"/></originalTarget>
		<explicitOriginalTarget public="1" set="null"><c path="js.html.EventTarget"/></explicitOriginalTarget>
		<stopPropagation public="1" set="method"><f a=""><x path="Void"/></f></stopPropagation>
		<stopImmediatePropagation public="1" set="method"><f a=""><x path="Void"/></f></stopImmediatePropagation>
		<preventDefault public="1" set="method"><f a=""><x path="Void"/></f></preventDefault>
		<initEvent public="1" set="method">
			<f a="type:bubbles:cancelable">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</initEvent>
		<getPreventDefault public="1" set="method"><f a=""><x path="Bool"/></f></getPreventDefault>
		<new public="1" set="method">
			<f a="type:?eventInitDict">
				<c path="String"/>
				<t path="js.html.EventInit"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</new>
		<meta><m n=":native"><e>"Event"</e></m></meta>
	</class>
	<typedef path="js.html.EventInit" params="" file="C:\HaxeToolkit\haxe\std/js/html/EventInit.hx"><a>
	<cancelable>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</cancelable>
	<bubbles>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</bubbles>
</a></typedef>
	<class path="js.html.EventListener" params="" file="C:\HaxeToolkit\haxe\std/js/html/EventListener.hx" extern="1">
		<handleEvent public="1" set="method"><f a="event">
	<c path="js.html.Event"/>
	<x path="Void"/>
</f></handleEvent>
		<meta><m n=":native"><e>"EventListener"</e></m></meta>
	</class>
	<class path="js.html.FieldSetElement" params="" file="C:\HaxeToolkit\haxe\std/js/html/FieldSetElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<disabled public="1"><x path="Bool"/></disabled>
		<form public="1" set="null"><c path="js.html.FormElement"/></form>
		<name public="1"><c path="String"/></name>
		<type public="1" set="null"><c path="String"/></type>
		<elements public="1" set="null"><c path="js.html.HTMLCollection"/></elements>
		<willValidate public="1" set="null"><x path="Bool"/></willValidate>
		<validity public="1" set="null"><c path="js.html.ValidityState"/></validity>
		<validationMessage public="1" set="null"><c path="String"/></validationMessage>
		<checkValidity public="1" set="method"><f a=""><x path="Bool"/></f></checkValidity>
		<setCustomValidity public="1" set="method"><f a="error">
	<c path="String"/>
	<x path="Void"/>
</f></setCustomValidity>
		<meta><m n=":native"><e>"HTMLFieldSetElement"</e></m></meta>
	</class>
	<class path="js.html.File" params="" file="C:\HaxeToolkit\haxe\std/js/html/File.hx" extern="1">
		<extends path="js.html.Blob"/>
		<name public="1" set="null"><c path="String"/></name>
		<lastModified public="1" set="null"><x path="Int"/></lastModified>
		<lastModifiedDate public="1" set="null"><c path="Date"/></lastModifiedDate>
		<new public="1" set="method">
			<f a="fileBits:?options">
				<c path="String"/>
				<t path="js.html.ChromeFilePropertyBag"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
			<overloads>
				<new public="1" set="method">
					<f a="fileBits:fileName:?options">
						<c path="Array"><x path="haxe.extern.EitherType">
	<c path="js.html.ArrayBuffer"/>
	<x path="haxe.extern.EitherType">
		<c path="js.html.ArrayBufferView"/>
		<x path="haxe.extern.EitherType">
			<c path="js.html.Blob"/>
			<c path="String"/>
		</x>
	</x>
</x></c>
						<c path="String"/>
						<t path="js.html.FilePropertyBag"/>
						<x path="Void"/>
					</f>
					<haxe_doc>@throws DOMError</haxe_doc>
				</new>
				<new public="1" set="method">
					<f a="fileBits:?options">
						<c path="js.html.Blob"/>
						<t path="js.html.ChromeFilePropertyBag"/>
						<x path="Void"/>
					</f>
					<haxe_doc>@throws DOMError</haxe_doc>
				</new>
				<new public="1" set="method">
					<f a="fileBits:?options">
						<d/>
						<t path="js.html.ChromeFilePropertyBag"/>
						<x path="Void"/>
					</f>
					<haxe_doc>@throws DOMError</haxe_doc>
				</new>
			</overloads>
		</new>
		<meta><m n=":native"><e>"File"</e></m></meta>
	</class>
	<class path="js.html.FileList" params="" file="C:\HaxeToolkit\haxe\std/js/html/FileList.hx" extern="1">
		<length public="1" set="null"><x path="Int"/></length>
		<item public="1" set="method"><f a="index">
	<x path="Int"/>
	<c path="js.html.File"/>
</f></item>
		<meta><m n=":native"><e>"FileList"</e></m></meta>
	</class>
	<typedef path="js.html.FilePropertyBag" params="" file="C:\HaxeToolkit\haxe\std/js/html/FilePropertyBag.hx"><a>
	<type>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</type>
	<lastModified>
		<t path="Null"><x path="Int"/></t>
		<meta><m n=":optional"/></meta>
	</lastModified>
</a></typedef>
	<class path="js.html.Float32Array" params="" file="C:\HaxeToolkit\haxe\std/js/html/Float32Array.hx" extern="1">
		<extends path="js.html.ArrayBufferView"/>
		<BYTES_PER_ELEMENT public="1" get="inline" set="null" expr="4" line="30" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>4</e></m></meta>
		</BYTES_PER_ELEMENT>
		<length public="1" set="null"><x path="Int"/></length>
		<get public="1" set="method"><f a="index">
	<x path="Int"/>
	<x path="Float"/>
</f></get>
		<set public="1" set="method">
			<f a="array:?offset">
				<c path="Array"><x path="Float"/></c>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<overloads>
				<set public="1" set="method"><f a="index:value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Void"/>
</f></set>
				<set public="1" set="method"><f a="array:?offset">
	<c path="js.html.Float32Array"/>
	<x path="Int"/>
	<x path="Void"/>
</f></set>
			</overloads>
		</set>
		<subarray public="1" set="method"><f a="start:end">
	<x path="Int"/>
	<x path="Int"/>
	<c path="js.html.Float32Array"/>
</f></subarray>
		<new public="1" set="method">
			<f a="buffer:?byteOffset:?length">
				<c path="js.html.ArrayBuffer"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
			<overloads>
				<new public="1" set="method">
					<f a="length">
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>@throws DOMError</haxe_doc>
				</new>
				<new public="1" set="method">
					<f a="array">
						<c path="js.html.Float32Array"/>
						<x path="Void"/>
					</f>
					<haxe_doc>@throws DOMError</haxe_doc>
				</new>
				<new public="1" set="method">
					<f a="array">
						<c path="Array"><x path="Float"/></c>
						<x path="Void"/>
					</f>
					<haxe_doc>@throws DOMError</haxe_doc>
				</new>
			</overloads>
		</new>
		<meta><m n=":native"><e>"Float32Array"</e></m></meta>
	</class>
	<class path="js.html.FontElement" params="" file="C:\HaxeToolkit\haxe\std/js/html/FontElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<color public="1"><c path="String"/></color>
		<face public="1"><c path="String"/></face>
		<size public="1"><c path="String"/></size>
		<meta><m n=":native"><e>"HTMLFontElement"</e></m></meta>
	</class>
	<class path="js.html.FontFace" params="" file="C:\HaxeToolkit\haxe\std/js/html/FontFace.hx" extern="1">
		<family public="1"><c path="String"/></family>
		<style public="1"><c path="String"/></style>
		<weight public="1"><c path="String"/></weight>
		<stretch public="1"><c path="String"/></stretch>
		<unicodeRange public="1"><c path="String"/></unicodeRange>
		<variant public="1"><c path="String"/></variant>
		<featureSettings public="1"><c path="String"/></featureSettings>
		<status public="1" set="null"><x path="js.html.FontFaceLoadStatus"/></status>
		<loaded public="1" set="null"><c path="js.Promise"><c path="js.html.FontFace"/></c></loaded>
		<load public="1" set="method">
			<f a=""><c path="js.Promise"><c path="js.html.FontFace"/></c></f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</load>
		<new public="1" set="method">
			<f a="family:source:?descriptors">
				<c path="String"/>
				<x path="haxe.extern.EitherType">
					<c path="String"/>
					<x path="haxe.extern.EitherType">
						<c path="js.html.ArrayBuffer"/>
						<c path="js.html.ArrayBufferView"/>
					</x>
				</x>
				<t path="js.html.FontFaceDescriptors"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</new>
		<meta><m n=":native"><e>"FontFace"</e></m></meta>
	</class>
	<typedef path="js.html.FontFaceDescriptors" params="" file="C:\HaxeToolkit\haxe\std/js/html/FontFaceDescriptors.hx"><a>
	<weight>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</weight>
	<variant>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</variant>
	<unicodeRange>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</unicodeRange>
	<style>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</style>
	<stretch>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</stretch>
	<featureSettings>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</featureSettings>
</a></typedef>
	<abstract path="js.html.FontFaceLoadStatus" params="" file="C:\HaxeToolkit\haxe\std/js/html/FontFaceLoadStatus.hx">
		<this><c path="String"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="js.html._FontFaceLoadStatus.FontFaceLoadStatus_Impl_" params="" file="C:\HaxeToolkit\haxe\std/js/html/FontFaceLoadStatus.hx" private="1" module="js.html.FontFaceLoadStatus"><meta>
	<m n=":keep"/>
	<m n=":enum"/>
</meta></class></impl>
	</abstract>
	<class path="js.html.FontFaceSet" params="" file="C:\HaxeToolkit\haxe\std/js/html/FontFaceSet.hx" extern="1">
		<extends path="js.html.EventTarget"/>
		<onloading public="1"><x path="haxe.Function"/></onloading>
		<onloadingdone public="1"><x path="haxe.Function"/></onloadingdone>
		<onloadingerror public="1"><x path="haxe.Function"/></onloadingerror>
		<ready public="1" set="null"><c path="js.Promise"><x path="Void"/></c></ready>
		<status public="1" set="null"><x path="js.html.FontFaceSetLoadStatus"/></status>
		<length public="1" set="null"><x path="Int"/></length>
		<add public="1" set="method">
			<f a="font">
				<c path="js.html.FontFace"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</add>
		<has public="1" set="method"><f a="font">
	<c path="js.html.FontFace"/>
	<x path="Bool"/>
</f></has>
		<delete_ public="1" set="method">
			<f a="font">
				<c path="js.html.FontFace"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":native"><e>"delete"</e></m></meta>
			<haxe_doc>@throws DOMError</haxe_doc>
		</delete_>
		<clear public="1" set="method"><f a=""><x path="Void"/></f></clear>
		<load public="1" set="method">
			<f a="font:?text" v=":&quot; &quot;">
				<c path="String"/>
				<c path="String"/>
				<c path="js.Promise"><c path="Array"><c path="js.html.FontFace"/></c></c>
			</f>
			<meta><m n=":value"><e>{text:" "}</e></m></meta>
			<haxe_doc>@throws DOMError</haxe_doc>
		</load>
		<meta><m n=":native"><e>"FontFaceSet"</e></m></meta>
	</class>
	<abstract path="js.html.FontFaceSetLoadStatus" params="" file="C:\HaxeToolkit\haxe\std/js/html/FontFaceSetLoadStatus.hx">
		<this><c path="String"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="js.html._FontFaceSetLoadStatus.FontFaceSetLoadStatus_Impl_" params="" file="C:\HaxeToolkit\haxe\std/js/html/FontFaceSetLoadStatus.hx" private="1" module="js.html.FontFaceSetLoadStatus"><meta>
	<m n=":keep"/>
	<m n=":enum"/>
</meta></class></impl>
	</abstract>
	<class path="js.html.FormData" params="" file="C:\HaxeToolkit\haxe\std/js/html/FormData.hx" extern="1">
		<append public="1" set="method">
			<f a="name:value">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<overloads><append public="1" set="method"><f a="name:value:?filename">
	<c path="String"/>
	<c path="js.html.Blob"/>
	<c path="String"/>
	<x path="Void"/>
</f></append></overloads>
		</append>
		<new public="1" set="method">
			<f a="?form">
				<c path="js.html.FormElement"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</new>
		<meta><m n=":native"><e>"FormData"</e></m></meta>
	</class>
	<class path="js.html.FormElement" params="" file="C:\HaxeToolkit\haxe\std/js/html/FormElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<acceptCharset public="1"><c path="String"/></acceptCharset>
		<action public="1"><c path="String"/></action>
		<autocomplete public="1"><c path="String"/></autocomplete>
		<enctype public="1"><c path="String"/></enctype>
		<encoding public="1"><c path="String"/></encoding>
		<method public="1"><c path="String"/></method>
		<name public="1"><c path="String"/></name>
		<noValidate public="1"><x path="Bool"/></noValidate>
		<target public="1"><c path="String"/></target>
		<elements public="1" set="null"><c path="js.html.HTMLCollection"/></elements>
		<length public="1" set="null"><x path="Int"/></length>
		<submit public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</submit>
		<reset public="1" set="method"><f a=""><x path="Void"/></f></reset>
		<checkValidity public="1" set="method"><f a=""><x path="Bool"/></f></checkValidity>
		<meta><m n=":native"><e>"HTMLFormElement"</e></m></meta>
	</class>
	<class path="js.html.FrameElement" params="" file="C:\HaxeToolkit\haxe\std/js/html/FrameElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<name public="1"><c path="String"/></name>
		<scrolling public="1"><c path="String"/></scrolling>
		<src public="1"><c path="String"/></src>
		<frameBorder public="1"><c path="String"/></frameBorder>
		<longDesc public="1"><c path="String"/></longDesc>
		<noResize public="1"><x path="Bool"/></noResize>
		<contentDocument public="1" set="null"><c path="js.html.HTMLDocument"/></contentDocument>
		<contentWindow public="1" set="null"><c path="js.html.Window"/></contentWindow>
		<marginHeight public="1"><c path="String"/></marginHeight>
		<marginWidth public="1"><c path="String"/></marginWidth>
		<meta><m n=":native"><e>"HTMLFrameElement"</e></m></meta>
	</class>
	<class path="js.html.FrameSetElement" params="" file="C:\HaxeToolkit\haxe\std/js/html/FrameSetElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<cols public="1"><c path="String"/></cols>
		<rows public="1"><c path="String"/></rows>
		<onafterprint public="1"><x path="haxe.Function"/></onafterprint>
		<onbeforeprint public="1"><x path="haxe.Function"/></onbeforeprint>
		<onbeforeunload public="1"><f a="">
	<c path="js.html.Event"/>
	<c path="String"/>
</f></onbeforeunload>
		<onhashchange public="1"><x path="haxe.Function"/></onhashchange>
		<onlanguagechange public="1"><x path="haxe.Function"/></onlanguagechange>
		<onmessage public="1"><x path="haxe.Function"/></onmessage>
		<onoffline public="1"><x path="haxe.Function"/></onoffline>
		<ononline public="1"><x path="haxe.Function"/></ononline>
		<onpagehide public="1"><x path="haxe.Function"/></onpagehide>
		<onpageshow public="1"><x path="haxe.Function"/></onpageshow>
		<onpopstate public="1"><x path="haxe.Function"/></onpopstate>
		<onresize public="1"><x path="haxe.Function"/></onresize>
		<onunload public="1"><x path="haxe.Function"/></onunload>
		<meta><m n=":native"><e>"HTMLFrameSetElement"</e></m></meta>
	</class>
	<class path="js.html.Gamepad" params="" file="C:\HaxeToolkit\haxe\std/js/html/Gamepad.hx" extern="1">
		<id public="1" set="null"><c path="String"/></id>
		<index public="1" set="null"><x path="Int"/></index>
		<mapping public="1" set="null"><x path="js.html.GamepadMappingType"/></mapping>
		<connected public="1" set="null"><x path="Bool"/></connected>
		<buttons public="1" set="null"><c path="Array"><c path="js.html.GamepadButton"/></c></buttons>
		<axes public="1" set="null"><c path="Array"><x path="Float"/></c></axes>
		<timestamp public="1" set="null"><x path="Float"/></timestamp>
		<meta><m n=":native"><e>"Gamepad"</e></m></meta>
	</class>
	<class path="js.html.GamepadButton" params="" file="C:\HaxeToolkit\haxe\std/js/html/GamepadButton.hx" extern="1">
		<pressed public="1" set="null"><x path="Bool"/></pressed>
		<value public="1" set="null"><x path="Float"/></value>
		<meta><m n=":native"><e>"GamepadButton"</e></m></meta>
	</class>
	<abstract path="js.html.GamepadMappingType" params="" file="C:\HaxeToolkit\haxe\std/js/html/GamepadMappingType.hx">
		<this><c path="String"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="js.html._GamepadMappingType.GamepadMappingType_Impl_" params="" file="C:\HaxeToolkit\haxe\std/js/html/GamepadMappingType.hx" private="1" module="js.html.GamepadMappingType"><meta>
	<m n=":keep"/>
	<m n=":enum"/>
</meta></class></impl>
	</abstract>
	<class path="js.html.Geolocation" params="" file="C:\HaxeToolkit\haxe\std/js/html/Geolocation.hx" extern="1">
		<getCurrentPosition public="1" set="method">
			<f a="successCallback:?errorCallback:?options">
				<f a="">
					<c path="js.html.Position"/>
					<x path="Void"/>
				</f>
				<f a="">
					<c path="js.html.PositionError"/>
					<x path="Void"/>
				</f>
				<t path="js.html.PositionOptions"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</getCurrentPosition>
		<watchPosition public="1" set="method">
			<f a="successCallback:?errorCallback:?options">
				<f a="">
					<c path="js.html.Position"/>
					<x path="Void"/>
				</f>
				<f a="">
					<c path="js.html.PositionError"/>
					<x path="Void"/>
				</f>
				<t path="js.html.PositionOptions"/>
				<x path="Int"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</watchPosition>
		<clearWatch public="1" set="method"><f a="watchId">
	<x path="Int"/>
	<x path="Void"/>
</f></clearWatch>
		<meta><m n=":native"><e>"Geolocation"</e></m></meta>
	</class>
	<class path="js.html.HRElement" params="" file="C:\HaxeToolkit\haxe\std/js/html/HRElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<align public="1"><c path="String"/></align>
		<color public="1"><c path="String"/></color>
		<noShade public="1"><x path="Bool"/></noShade>
		<size public="1"><c path="String"/></size>
		<width public="1"><c path="String"/></width>
		<meta><m n=":native"><e>"HTMLHRElement"</e></m></meta>
	</class>
	<class path="js.html.HTMLAllCollection" params="" file="C:\HaxeToolkit\haxe\std/js/html/HTMLAllCollection.hx" extern="1">
		<length public="1" set="null"><x path="Int"/></length>
		<item public="1" set="method">
			<f a="name">
				<c path="String"/>
				<x path="haxe.extern.EitherType">
					<c path="js.html.Node"/>
					<c path="js.html.HTMLCollection"/>
				</x>
			</f>
			<overloads><item public="1" set="method"><f a="index">
	<x path="Int"/>
	<c path="js.html.Node"/>
</f></item></overloads>
		</item>
		<namedItem public="1" set="method"><f a="name">
	<c path="String"/>
	<x path="haxe.extern.EitherType">
		<c path="js.html.Node"/>
		<c path="js.html.HTMLCollection"/>
	</x>
</f></namedItem>
		<meta><m n=":native"><e>"HTMLAllCollection"</e></m></meta>
	</class>
	<class path="js.html.HTMLCollection" params="" file="C:\HaxeToolkit\haxe\std/js/html/HTMLCollection.hx" extern="1">
		<length public="1" set="null"><x path="Int"/></length>
		<item public="1" set="method"><f a="index">
	<x path="Int"/>
	<c path="js.html.Element"/>
</f></item>
		<namedItem public="1" set="method"><f a="name">
	<c path="String"/>
	<c path="js.html.Element"/>
</f></namedItem>
		<meta><m n=":native"><e>"HTMLCollection"</e></m></meta>
	</class>
	<class path="js.html.HTMLDocument" params="" file="C:\HaxeToolkit\haxe\std/js/html/HTMLDocument.hx" extern="1">
		<extends path="js.html.Document"/>
		<domain public="1"><c path="String"/></domain>
		<cookie public="1"><c path="String"/></cookie>
		<body public="1"><c path="js.html.Element"/></body>
		<head public="1" set="null"><c path="js.html.HeadElement"/></head>
		<images public="1" set="null"><c path="js.html.HTMLCollection"/></images>
		<embeds public="1" set="null"><c path="js.html.HTMLCollection"/></embeds>
		<plugins public="1" set="null"><c path="js.html.HTMLCollection"/></plugins>
		<links public="1" set="null"><c path="js.html.HTMLCollection"/></links>
		<forms public="1" set="null"><c path="js.html.HTMLCollection"/></forms>
		<scripts public="1" set="null"><c path="js.html.HTMLCollection"/></scripts>
		<designMode public="1"><c path="String"/></designMode>
		<fgColor public="1"><c path="String"/></fgColor>
		<linkColor public="1"><c path="String"/></linkColor>
		<vlinkColor public="1"><c path="String"/></vlinkColor>
		<alinkColor public="1"><c path="String"/></alinkColor>
		<bgColor public="1"><c path="String"/></bgColor>
		<anchors public="1" set="null"><c path="js.html.HTMLCollection"/></anchors>
		<applets public="1" set="null"><c path="js.html.HTMLCollection"/></applets>
		<all public="1" set="null"><c path="js.html.HTMLAllCollection"/></all>
		<getElementsByName public="1" set="method"><f a="elementName">
	<c path="String"/>
	<c path="js.html.NodeList"/>
</f></getElementsByName>
		<getItems public="1" set="method">
			<f a="?typeNames" v="&quot;&quot;">
				<c path="String"/>
				<c path="js.html.NodeList"/>
			</f>
			<meta><m n=":value"><e>{typeNames:""}</e></m></meta>
		</getItems>
		<open public="1" set="method">
			<f a="url:name:features:?replace" v=":::false">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<x path="Bool"/>
				<c path="js.html.Window"/>
			</f>
			<meta><m n=":value"><e>{replace:false}</e></m></meta>
			<haxe_doc>@throws DOMError</haxe_doc>
			<overloads><open public="1" set="method">
	<f a="?type:?replace" v="&quot;text/html&quot;:&quot;&quot;">
		<c path="String"/>
		<c path="String"/>
		<c path="js.html.HTMLDocument"/>
	</f>
	<meta><m n=":value"><e>{replace:"",type:"text/html"}</e></m></meta>
	<haxe_doc>@throws DOMError</haxe_doc>
</open></overloads>
		</open>
		<close public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</close>
		<write public="1" set="method">
			<f a="text">
				<x path="haxe.extern.Rest"><c path="String"/></x>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</write>
		<writeln public="1" set="method">
			<f a="text">
				<x path="haxe.extern.Rest"><c path="String"/></x>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</writeln>
		<execCommand public="1" set="method">
			<f a="commandId:?showUI:?value" v=":false:&quot;&quot;">
				<c path="String"/>
				<x path="Bool"/>
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>{value:"",showUI:false}</e></m></meta>
			<haxe_doc>@throws DOMError</haxe_doc>
		</execCommand>
		<queryCommandEnabled public="1" set="method">
			<f a="commandId">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</queryCommandEnabled>
		<queryCommandIndeterm public="1" set="method">
			<f a="commandId">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</queryCommandIndeterm>
		<queryCommandState public="1" set="method">
			<f a="commandId">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</queryCommandState>
		<queryCommandSupported public="1" set="method"><f a="commandId">
	<c path="String"/>
	<x path="Bool"/>
</f></queryCommandSupported>
		<queryCommandValue public="1" set="method">
			<f a="commandId">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</queryCommandValue>
		<clear public="1" set="method"><f a=""><x path="Void"/></f></clear>
		<getSelection public="1" set="method">
			<f a=""><c path="js.html.Selection"/></f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</getSelection>
		<captureEvents public="1" set="method"><f a=""><x path="Void"/></f></captureEvents>
		<releaseEvents public="1" set="method"><f a=""><x path="Void"/></f></releaseEvents>
		<createTableCellElement public="1" get="inline" set="null" line="78">
			<f a=""><c path="js.html.TableCellElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <td> element.]]></haxe_doc>
		</createTableCellElement>
		<createHRElement public="1" get="inline" set="null" line="80">
			<f a=""><c path="js.html.HRElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <hr> element.]]></haxe_doc>
		</createHRElement>
		<createSelectElement public="1" get="inline" set="null" line="82">
			<f a=""><c path="js.html.SelectElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <select> element.]]></haxe_doc>
		</createSelectElement>
		<createMapElement public="1" get="inline" set="null" line="84">
			<f a=""><c path="js.html.MapElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <map> element.]]></haxe_doc>
		</createMapElement>
		<createFormElement public="1" get="inline" set="null" line="86">
			<f a=""><c path="js.html.FormElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <form> element.]]></haxe_doc>
		</createFormElement>
		<createOptionElement public="1" get="inline" set="null" line="88">
			<f a=""><c path="js.html.OptionElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <option> element.]]></haxe_doc>
		</createOptionElement>
		<createLabelElement public="1" get="inline" set="null" line="90">
			<f a=""><c path="js.html.LabelElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <label> element.]]></haxe_doc>
		</createLabelElement>
		<createMetaElement public="1" get="inline" set="null" line="92">
			<f a=""><c path="js.html.MetaElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <meta> element.]]></haxe_doc>
		</createMetaElement>
		<createImageElement public="1" get="inline" set="null" line="94">
			<f a=""><c path="js.html.ImageElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <img> element.]]></haxe_doc>
		</createImageElement>
		<createDListElement public="1" get="inline" set="null" line="96">
			<f a=""><c path="js.html.DListElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <dl> element.]]></haxe_doc>
		</createDListElement>
		<createFrameElement public="1" get="inline" set="null" line="98">
			<f a=""><c path="js.html.FrameElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <frame> element.]]></haxe_doc>
		</createFrameElement>
		<createModElement public="1" get="inline" set="null" line="100">
			<f a=""><c path="js.html.ModElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <mod> element.]]></haxe_doc>
		</createModElement>
		<createUListElement public="1" get="inline" set="null" line="102">
			<f a=""><c path="js.html.UListElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <ul> element.]]></haxe_doc>
		</createUListElement>
		<createOutputElement public="1" get="inline" set="null" line="104">
			<f a=""><c path="js.html.OutputElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <output> element.]]></haxe_doc>
		</createOutputElement>
		<createOListElement public="1" get="inline" set="null" line="106">
			<f a=""><c path="js.html.OListElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <ol> element.]]></haxe_doc>
		</createOListElement>
		<createShadowElement public="1" get="inline" set="null" line="108">
			<f a=""><c path="js.html.ShadowElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <shadow> element.]]></haxe_doc>
		</createShadowElement>
		<createLIElement public="1" get="inline" set="null" line="110">
			<f a=""><c path="js.html.LIElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <li> element.]]></haxe_doc>
		</createLIElement>
		<createDataListElement public="1" get="inline" set="null" line="112">
			<f a=""><c path="js.html.DataListElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <datalist> element.]]></haxe_doc>
		</createDataListElement>
		<createParamElement public="1" get="inline" set="null" line="114">
			<f a=""><c path="js.html.ParamElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <param> element.]]></haxe_doc>
		</createParamElement>
		<createFontElement public="1" get="inline" set="null" line="116">
			<f a=""><c path="js.html.FontElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <font> element.]]></haxe_doc>
		</createFontElement>
		<createTrackElement public="1" get="inline" set="null" line="118">
			<f a=""><c path="js.html.TrackElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <track> element.]]></haxe_doc>
		</createTrackElement>
		<createAppletElement public="1" get="inline" set="null" line="120">
			<f a=""><c path="js.html.AppletElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <applet> element.]]></haxe_doc>
		</createAppletElement>
		<createAreaElement public="1" get="inline" set="null" line="122">
			<f a=""><c path="js.html.AreaElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <area> element.]]></haxe_doc>
		</createAreaElement>
		<createLinkElement public="1" get="inline" set="null" line="124">
			<f a=""><c path="js.html.LinkElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <link> element.]]></haxe_doc>
		</createLinkElement>
		<createDivElement public="1" get="inline" set="null" line="126">
			<f a=""><c path="js.html.DivElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <div> element.]]></haxe_doc>
		</createDivElement>
		<createTitleElement public="1" get="inline" set="null" line="128">
			<f a=""><c path="js.html.TitleElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <title> element.]]></haxe_doc>
		</createTitleElement>
		<createStyleElement public="1" get="inline" set="null" line="130">
			<f a=""><c path="js.html.StyleElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <style> element.]]></haxe_doc>
		</createStyleElement>
		<createProgressElement public="1" get="inline" set="null" line="132">
			<f a=""><c path="js.html.ProgressElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <progress> element.]]></haxe_doc>
		</createProgressElement>
		<createButtonElement public="1" get="inline" set="null" line="134">
			<f a=""><c path="js.html.ButtonElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <button> element.]]></haxe_doc>
		</createButtonElement>
		<createFieldSetElement public="1" get="inline" set="null" line="136">
			<f a=""><c path="js.html.FieldSetElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <fieldset> element.]]></haxe_doc>
		</createFieldSetElement>
		<createAnchorElement public="1" get="inline" set="null" line="138">
			<f a=""><c path="js.html.AnchorElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <a> element.]]></haxe_doc>
		</createAnchorElement>
		<createIFrameElement public="1" get="inline" set="null" line="140">
			<f a=""><c path="js.html.IFrameElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <iframe> element.]]></haxe_doc>
		</createIFrameElement>
		<createSpanElement public="1" get="inline" set="null" line="142">
			<f a=""><c path="js.html.SpanElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <span> element.]]></haxe_doc>
		</createSpanElement>
		<createBodyElement public="1" get="inline" set="null" line="144">
			<f a=""><c path="js.html.BodyElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <body> element.]]></haxe_doc>
		</createBodyElement>
		<createInputElement public="1" get="inline" set="null" line="146">
			<f a=""><c path="js.html.InputElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <input> element.]]></haxe_doc>
		</createInputElement>
		<createEmbedElement public="1" get="inline" set="null" line="148">
			<f a=""><c path="js.html.EmbedElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <embed> element.]]></haxe_doc>
		</createEmbedElement>
		<createMeterElement public="1" get="inline" set="null" line="150">
			<f a=""><c path="js.html.MeterElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <meter> element.]]></haxe_doc>
		</createMeterElement>
		<createPictureElement public="1" get="inline" set="null" line="152">
			<f a=""><c path="js.html.PictureElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <picture> element.]]></haxe_doc>
		</createPictureElement>
		<createPreElement public="1" get="inline" set="null" line="154">
			<f a=""><c path="js.html.PreElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <pre> element.]]></haxe_doc>
		</createPreElement>
		<createTableSectionElement public="1" get="inline" set="null" line="156">
			<f a=""><c path="js.html.TableSectionElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <thead> element.]]></haxe_doc>
		</createTableSectionElement>
		<createHeadElement public="1" get="inline" set="null" line="158">
			<f a=""><c path="js.html.HeadElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <head> element.]]></haxe_doc>
		</createHeadElement>
		<createBaseElement public="1" get="inline" set="null" line="160">
			<f a=""><c path="js.html.BaseElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <base> element.]]></haxe_doc>
		</createBaseElement>
		<createOptGroupElement public="1" get="inline" set="null" line="162">
			<f a=""><c path="js.html.OptGroupElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <optgroup> element.]]></haxe_doc>
		</createOptGroupElement>
		<createQuoteElement public="1" get="inline" set="null" line="164">
			<f a=""><c path="js.html.QuoteElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <quote> element.]]></haxe_doc>
		</createQuoteElement>
		<createAudioElement public="1" get="inline" set="null" line="166">
			<f a=""><c path="js.html.AudioElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <audio> element.]]></haxe_doc>
		</createAudioElement>
		<createVideoElement public="1" get="inline" set="null" line="168">
			<f a=""><c path="js.html.VideoElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <video> element.]]></haxe_doc>
		</createVideoElement>
		<createLegendElement public="1" get="inline" set="null" line="170">
			<f a=""><c path="js.html.LegendElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <legend> element.]]></haxe_doc>
		</createLegendElement>
		<createMenuElement public="1" get="inline" set="null" line="172">
			<f a=""><c path="js.html.MenuElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <menu> element.]]></haxe_doc>
		</createMenuElement>
		<createFrameSetElement public="1" get="inline" set="null" line="174">
			<f a=""><c path="js.html.FrameSetElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <frameset> element.]]></haxe_doc>
		</createFrameSetElement>
		<createCanvasElement public="1" get="inline" set="null" line="176">
			<f a=""><c path="js.html.CanvasElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <canvas> element.]]></haxe_doc>
		</createCanvasElement>
		<createParagraphElement public="1" get="inline" set="null" line="178">
			<f a=""><c path="js.html.ParagraphElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <p> element.]]></haxe_doc>
		</createParagraphElement>
		<createTableColElement public="1" get="inline" set="null" line="180">
			<f a=""><c path="js.html.TableColElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <col> element.]]></haxe_doc>
		</createTableColElement>
		<createDirectoryElement public="1" get="inline" set="null" line="182">
			<f a=""><c path="js.html.DirectoryElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <dir> element.]]></haxe_doc>
		</createDirectoryElement>
		<createTableElement public="1" get="inline" set="null" line="184">
			<f a=""><c path="js.html.TableElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <table> element.]]></haxe_doc>
		</createTableElement>
		<createTableRowElement public="1" get="inline" set="null" line="186">
			<f a=""><c path="js.html.TableRowElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <tr> element.]]></haxe_doc>
		</createTableRowElement>
		<createScriptElement public="1" get="inline" set="null" line="188">
			<f a=""><c path="js.html.ScriptElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <script> element.]]></haxe_doc>
		</createScriptElement>
		<createSourceElement public="1" get="inline" set="null" line="190">
			<f a=""><c path="js.html.SourceElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <source> element.]]></haxe_doc>
		</createSourceElement>
		<createContentElement public="1" get="inline" set="null" line="192">
			<f a=""><c path="js.html.ContentElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <content> element.]]></haxe_doc>
		</createContentElement>
		<createBRElement public="1" get="inline" set="null" line="194">
			<f a=""><c path="js.html.BRElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <br> element.]]></haxe_doc>
		</createBRElement>
		<createHtmlElement public="1" get="inline" set="null" line="196">
			<f a=""><c path="js.html.HtmlElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <html> element.]]></haxe_doc>
		</createHtmlElement>
		<createTextAreaElement public="1" get="inline" set="null" line="198">
			<f a=""><c path="js.html.TextAreaElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <textarea> element.]]></haxe_doc>
		</createTextAreaElement>
		<createMediaElement public="1" get="inline" set="null" line="200">
			<f a=""><c path="js.html.MediaElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <media> element.]]></haxe_doc>
		</createMediaElement>
		<createObjectElement public="1" get="inline" set="null" line="202">
			<f a=""><c path="js.html.ObjectElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <object> element.]]></haxe_doc>
		</createObjectElement>
		<createTableCaptionElement public="1" get="inline" set="null" line="204">
			<f a=""><c path="js.html.TableCaptionElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <caption> element.]]></haxe_doc>
		</createTableCaptionElement>
		<meta><m n=":native"><e>"HTMLDocument"</e></m></meta>
	</class>
	<class path="js.html.HTMLOptionsCollection" params="" file="C:\HaxeToolkit\haxe\std/js/html/HTMLOptionsCollection.hx" extern="1">
		<extends path="js.html.HTMLCollection"/>
		<selectedIndex public="1"><x path="Int"/></selectedIndex>
		<add public="1" set="method">
			<f a="element:?before">
				<x path="haxe.extern.EitherType">
					<c path="js.html.OptionElement"/>
					<c path="js.html.OptGroupElement"/>
				</x>
				<x path="haxe.extern.EitherType">
					<c path="js.html.Element"/>
					<x path="Int"/>
				</x>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</add>
		<remove public="1" set="method">
			<f a="index">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</remove>
		<meta><m n=":native"><e>"HTMLOptionsCollection"</e></m></meta>
	</class>
	<class path="js.html.HTMLPropertiesCollection" params="" file="C:\HaxeToolkit\haxe\std/js/html/HTMLPropertiesCollection.hx" extern="1">
		<extends path="js.html.HTMLCollection"/>
		<names public="1" set="null"><c path="js.html.DOMStringList"/></names>
		<meta><m n=":native"><e>"HTMLPropertiesCollection"</e></m></meta>
	</class>
	<class path="js.html.HeadElement" params="" file="C:\HaxeToolkit\haxe\std/js/html/HeadElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<meta><m n=":native"><e>"HTMLHeadElement"</e></m></meta>
	</class>
	<class path="js.html.History" params="" file="C:\HaxeToolkit\haxe\std/js/html/History.hx" extern="1">
		<length public="1" set="null"><x path="Int"/></length>
		<state public="1" set="null"><d/></state>
		<go public="1" set="method">
			<f a="?delta" v="0">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{delta:0}</e></m></meta>
			<haxe_doc>@throws DOMError</haxe_doc>
		</go>
		<back public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</back>
		<forward public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</forward>
		<pushState public="1" set="method">
			<f a="data:title:?url">
				<d/>
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</pushState>
		<replaceState public="1" set="method">
			<f a="data:title:?url">
				<d/>
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</replaceState>
		<meta><m n=":native"><e>"History"</e></m></meta>
	</class>
	<typedef path="js.html.HitRegionOptions" params="" file="C:\HaxeToolkit\haxe\std/js/html/HitRegionOptions.hx"><a>
	<id>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</id>
	<control>
		<t path="Null"><c path="js.html.Element"/></t>
		<meta><m n=":optional"/></meta>
	</control>
</a></typedef>
	<class path="js.html.HtmlElement" params="" file="C:\HaxeToolkit\haxe\std/js/html/HtmlElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<version public="1"><c path="String"/></version>
		<meta><m n=":native"><e>"HTMLHtmlElement"</e></m></meta>
	</class>
	<class path="js.html.IFrameElement" params="" file="C:\HaxeToolkit\haxe\std/js/html/IFrameElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<src public="1"><c path="String"/></src>
		<srcdoc public="1"><c path="String"/></srcdoc>
		<name public="1"><c path="String"/></name>
		<sandbox public="1" set="null"><c path="js.html.DOMSettableTokenList"/></sandbox>
		<allowFullscreen public="1"><x path="Bool"/></allowFullscreen>
		<width public="1"><c path="String"/></width>
		<height public="1"><c path="String"/></height>
		<contentDocument public="1" set="null"><c path="js.html.HTMLDocument"/></contentDocument>
		<contentWindow public="1" set="null"><c path="js.html.Window"/></contentWindow>
		<align public="1"><c path="String"/></align>
		<scrolling public="1"><c path="String"/></scrolling>
		<frameBorder public="1"><c path="String"/></frameBorder>
		<longDesc public="1"><c path="String"/></longDesc>
		<marginHeight public="1"><c path="String"/></marginHeight>
		<marginWidth public="1"><c path="String"/></marginWidth>
		<getSVGDocument public="1" set="method"><f a=""><c path="js.html.HTMLDocument"/></f></getSVGDocument>
		<meta><m n=":native"><e>"HTMLIFrameElement"</e></m></meta>
	</class>
	<class path="js.html.ImageElement" params="" file="C:\HaxeToolkit\haxe\std/js/html/ImageElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<alt public="1"><c path="String"/></alt>
		<src public="1"><c path="String"/></src>
		<srcset public="1"><c path="String"/></srcset>
		<crossOrigin public="1"><c path="String"/></crossOrigin>
		<useMap public="1"><c path="String"/></useMap>
		<isMap public="1"><x path="Bool"/></isMap>
		<width public="1"><x path="Int"/></width>
		<height public="1"><x path="Int"/></height>
		<naturalWidth public="1" set="null"><x path="Int"/></naturalWidth>
		<naturalHeight public="1" set="null"><x path="Int"/></naturalHeight>
		<complete public="1" set="null"><x path="Bool"/></complete>
		<name public="1"><c path="String"/></name>
		<align public="1"><c path="String"/></align>
		<hspace public="1"><x path="Int"/></hspace>
		<vspace public="1"><x path="Int"/></vspace>
		<longDesc public="1"><c path="String"/></longDesc>
		<border public="1"><c path="String"/></border>
		<sizes public="1"><c path="String"/></sizes>
		<currentSrc public="1" set="null"><c path="String"/></currentSrc>
		<lowsrc public="1"><c path="String"/></lowsrc>
		<x public="1" set="null"><x path="Int"/></x>
		<y public="1" set="null"><x path="Int"/></y>
		<meta><m n=":native"><e>"HTMLImageElement"</e></m></meta>
	</class>
	<class path="js.html.Image" params="" file="C:\HaxeToolkit\haxe\std/js/html/Image.hx" extern="1">
		<extends path="js.html.ImageElement"/>
		<new public="1" set="method">
			<f a="?width:?height">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":native"><e>"Image"</e></m>
		</meta>
	</class>
	<class path="js.html.ImageData" params="" file="C:\HaxeToolkit\haxe\std/js/html/ImageData.hx" extern="1">
		<width public="1" set="null"><x path="Int"/></width>
		<height public="1" set="null"><x path="Int"/></height>
		<data public="1" set="null"><c path="js.html.Uint8ClampedArray"/></data>
		<new public="1" set="method">
			<f a="data:sw:?sh">
				<c path="js.html.Uint8ClampedArray"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
			<overloads><new public="1" set="method">
	<f a="sw:sh">
		<x path="Int"/>
		<x path="Int"/>
		<x path="Void"/>
	</f>
	<haxe_doc>@throws DOMError</haxe_doc>
</new></overloads>
		</new>
		<meta><m n=":native"><e>"ImageData"</e></m></meta>
	</class>
	<class path="js.html.InputElement" params="" file="C:\HaxeToolkit\haxe\std/js/html/InputElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<accept public="1"><c path="String"/></accept>
		<alt public="1"><c path="String"/></alt>
		<autocomplete public="1"><c path="String"/></autocomplete>
		<autofocus public="1"><x path="Bool"/></autofocus>
		<defaultChecked public="1"><x path="Bool"/></defaultChecked>
		<checked public="1"><x path="Bool"/></checked>
		<disabled public="1"><x path="Bool"/></disabled>
		<form public="1" set="null"><c path="js.html.FormElement"/></form>
		<files public="1" set="null"><c path="js.html.FileList"/></files>
		<formAction public="1"><c path="String"/></formAction>
		<formEnctype public="1"><c path="String"/></formEnctype>
		<formMethod public="1"><c path="String"/></formMethod>
		<formNoValidate public="1"><x path="Bool"/></formNoValidate>
		<formTarget public="1"><c path="String"/></formTarget>
		<height public="1"><x path="Int"/></height>
		<indeterminate public="1"><x path="Bool"/></indeterminate>
		<list public="1" set="null"><c path="js.html.Element"/></list>
		<max public="1"><c path="String"/></max>
		<maxLength public="1"><x path="Int"/></maxLength>
		<min public="1"><c path="String"/></min>
		<multiple public="1"><x path="Bool"/></multiple>
		<name public="1"><c path="String"/></name>
		<pattern public="1"><c path="String"/></pattern>
		<placeholder public="1"><c path="String"/></placeholder>
		<readOnly public="1"><x path="Bool"/></readOnly>
		<required public="1"><x path="Bool"/></required>
		<size public="1"><x path="Int"/></size>
		<src public="1"><c path="String"/></src>
		<step public="1"><c path="String"/></step>
		<type public="1"><c path="String"/></type>
		<defaultValue public="1"><c path="String"/></defaultValue>
		<value public="1"><c path="String"/></value>
		<valueAsNumber public="1"><x path="Float"/></valueAsNumber>
		<width public="1"><x path="Int"/></width>
		<willValidate public="1" set="null"><x path="Bool"/></willValidate>
		<validity public="1" set="null"><c path="js.html.ValidityState"/></validity>
		<validationMessage public="1" set="null"><c path="String"/></validationMessage>
		<selectionStart public="1"><x path="Int"/></selectionStart>
		<selectionEnd public="1"><x path="Int"/></selectionEnd>
		<selectionDirection public="1"><c path="String"/></selectionDirection>
		<align public="1"><c path="String"/></align>
		<useMap public="1"><c path="String"/></useMap>
		<textLength public="1" set="null"><x path="Int"/></textLength>
		<stepUp public="1" set="method">
			<f a="?n" v="1">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{n:1}</e></m></meta>
			<haxe_doc>@throws DOMError</haxe_doc>
		</stepUp>
		<stepDown public="1" set="method">
			<f a="?n" v="1">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{n:1}</e></m></meta>
			<haxe_doc>@throws DOMError</haxe_doc>
		</stepDown>
		<checkValidity public="1" set="method"><f a=""><x path="Bool"/></f></checkValidity>
		<setCustomValidity public="1" set="method"><f a="error">
	<c path="String"/>
	<x path="Void"/>
</f></setCustomValidity>
		<select public="1" set="method"><f a=""><x path="Void"/></f></select>
		<setRangeText public="1" set="method">
			<f a="replacement:start:end:?selectionMode" v=":::&quot;preserve&quot;">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="js.html.SelectionMode"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{selectionMode:"preserve"}</e></m></meta>
			<haxe_doc>@throws DOMError</haxe_doc>
			<overloads><setRangeText public="1" set="method">
	<f a="replacement">
		<c path="String"/>
		<x path="Void"/>
	</f>
	<haxe_doc>@throws DOMError</haxe_doc>
</setRangeText></overloads>
		</setRangeText>
		<setSelectionRange public="1" set="method">
			<f a="start:end:?direction">
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</setSelectionRange>
		<meta><m n=":native"><e>"HTMLInputElement"</e></m></meta>
	</class>
	<class path="js.html.Int32Array" params="" file="C:\HaxeToolkit\haxe\std/js/html/Int32Array.hx" extern="1">
		<extends path="js.html.ArrayBufferView"/>
		<BYTES_PER_ELEMENT public="1" get="inline" set="null" expr="4" line="30" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>4</e></m></meta>
		</BYTES_PER_ELEMENT>
		<length public="1" set="null"><x path="Int"/></length>
		<get public="1" set="method"><f a="index">
	<x path="Int"/>
	<x path="Int"/>
</f></get>
		<set public="1" set="method">
			<f a="array:?offset">
				<c path="Array"><x path="Int"/></c>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<overloads>
				<set public="1" set="method"><f a="index:value">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></set>
				<set public="1" set="method"><f a="array:?offset">
	<c path="js.html.Int32Array"/>
	<x path="Int"/>
	<x path="Void"/>
</f></set>
			</overloads>
		</set>
		<subarray public="1" set="method"><f a="start:end">
	<x path="Int"/>
	<x path="Int"/>
	<c path="js.html.Int32Array"/>
</f></subarray>
		<new public="1" set="method">
			<f a="buffer:?byteOffset:?length">
				<c path="js.html.ArrayBuffer"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
			<overloads>
				<new public="1" set="method">
					<f a="length">
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>@throws DOMError</haxe_doc>
				</new>
				<new public="1" set="method">
					<f a="array">
						<c path="js.html.Int32Array"/>
						<x path="Void"/>
					</f>
					<haxe_doc>@throws DOMError</haxe_doc>
				</new>
				<new public="1" set="method">
					<f a="array">
						<c path="Array"><x path="Int"/></c>
						<x path="Void"/>
					</f>
					<haxe_doc>@throws DOMError</haxe_doc>
				</new>
			</overloads>
		</new>
		<meta><m n=":native"><e>"Int32Array"</e></m></meta>
	</class>
	<class path="js.html.LIElement" params="" file="C:\HaxeToolkit\haxe\std/js/html/LIElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<value public="1"><x path="Int"/></value>
		<type public="1"><c path="String"/></type>
		<meta><m n=":native"><e>"HTMLLIElement"</e></m></meta>
	</class>
	<class path="js.html.LabelElement" params="" file="C:\HaxeToolkit\haxe\std/js/html/LabelElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<form public="1" set="null"><c path="js.html.FormElement"/></form>
		<htmlFor public="1"><c path="String"/></htmlFor>
		<control public="1" set="null"><c path="js.html.Element"/></control>
		<meta><m n=":native"><e>"HTMLLabelElement"</e></m></meta>
	</class>
	<class path="js.html.LegendElement" params="" file="C:\HaxeToolkit\haxe\std/js/html/LegendElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<form public="1" set="null"><c path="js.html.FormElement"/></form>
		<align public="1"><c path="String"/></align>
		<meta><m n=":native"><e>"HTMLLegendElement"</e></m></meta>
	</class>
	<class path="js.html.LinkElement" params="" file="C:\HaxeToolkit\haxe\std/js/html/LinkElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<disabled public="1"><x path="Bool"/></disabled>
		<href public="1"><c path="String"/></href>
		<crossOrigin public="1"><c path="String"/></crossOrigin>
		<rel public="1"><c path="String"/></rel>
		<relList public="1" set="null"><c path="js.html.DOMTokenList"/></relList>
		<media public="1"><c path="String"/></media>
		<hreflang public="1"><c path="String"/></hreflang>
		<type public="1"><c path="String"/></type>
		<sizes public="1" set="null"><c path="js.html.DOMSettableTokenList"/></sizes>
		<charset public="1"><c path="String"/></charset>
		<rev public="1"><c path="String"/></rev>
		<target public="1"><c path="String"/></target>
		<import_ public="1" set="null">
			<c path="js.html.HTMLDocument"/>
			<meta><m n=":native"><e>"import"</e></m></meta>
		</import_>
		<sheet public="1" set="null"><c path="js.html.StyleSheet"/></sheet>
		<meta><m n=":native"><e>"HTMLLinkElement"</e></m></meta>
	</class>
	<class path="js.html.Location" params="" file="C:\HaxeToolkit\haxe\std/js/html/Location.hx" extern="1">
		<href public="1"><c path="String"/></href>
		<origin public="1" set="null"><c path="String"/></origin>
		<protocol public="1"><c path="String"/></protocol>
		<username public="1"><c path="String"/></username>
		<password public="1"><c path="String"/></password>
		<host public="1"><c path="String"/></host>
		<hostname public="1"><c path="String"/></hostname>
		<port public="1"><c path="String"/></port>
		<pathname public="1"><c path="String"/></pathname>
		<search public="1"><c path="String"/></search>
		<hash public="1"><c path="String"/></hash>
		<assign public="1" set="method">
			<f a="url">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</assign>
		<replace public="1" set="method">
			<f a="url">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</replace>
		<reload public="1" set="method">
			<f a="?forceget" v="false">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{forceget:false}</e></m></meta>
			<haxe_doc>@throws DOMError</haxe_doc>
		</reload>
		<meta><m n=":native"><e>"Location"</e></m></meta>
	</class>
	<class path="js.html.MapElement" params="" file="C:\HaxeToolkit\haxe\std/js/html/MapElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<name public="1"><c path="String"/></name>
		<areas public="1" set="null"><c path="js.html.HTMLCollection"/></areas>
		<meta><m n=":native"><e>"HTMLMapElement"</e></m></meta>
	</class>
	<class path="js.html.MediaError" params="" file="C:\HaxeToolkit\haxe\std/js/html/MediaError.hx" extern="1">
		<MEDIA_ERR_ABORTED public="1" get="inline" set="null" expr="1" line="30" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</MEDIA_ERR_ABORTED>
		<MEDIA_ERR_NETWORK public="1" get="inline" set="null" expr="2" line="31" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2</e></m></meta>
		</MEDIA_ERR_NETWORK>
		<MEDIA_ERR_DECODE public="1" get="inline" set="null" expr="3" line="32" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3</e></m></meta>
		</MEDIA_ERR_DECODE>
		<MEDIA_ERR_SRC_NOT_SUPPORTED public="1" get="inline" set="null" expr="4" line="33" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>4</e></m></meta>
		</MEDIA_ERR_SRC_NOT_SUPPORTED>
		<code public="1" set="null"><x path="Int"/></code>
		<meta><m n=":native"><e>"MediaError"</e></m></meta>
	</class>
	<class path="js.html.MediaKeyError" params="" file="C:\HaxeToolkit\haxe\std/js/html/MediaKeyError.hx" extern="1">
		<extends path="js.html.Event"/>
		<systemCode public="1" set="null"><x path="Int"/></systemCode>
		<meta><m n=":native"><e>"MediaKeyError"</e></m></meta>
	</class>
	<class path="js.html.MediaKeySession" params="" file="C:\HaxeToolkit\haxe\std/js/html/MediaKeySession.hx" extern="1">
		<extends path="js.html.EventTarget"/>
		<error public="1" set="null"><c path="js.html.MediaKeyError"/></error>
		<keySystem public="1" set="null"><c path="String"/></keySystem>
		<sessionId public="1" set="null"><c path="String"/></sessionId>
		<expiration public="1" set="null"><x path="Float"/></expiration>
		<closed public="1" set="null"><c path="js.Promise"><x path="Void"/></c></closed>
		<generateRequest public="1" set="method"><f a="initDataType:initData">
	<c path="String"/>
	<x path="haxe.extern.EitherType">
		<c path="js.html.ArrayBufferView"/>
		<c path="js.html.ArrayBuffer"/>
	</x>
	<c path="js.Promise"><x path="Void"/></c>
</f></generateRequest>
		<load public="1" set="method"><f a="sessionId">
	<c path="String"/>
	<c path="js.Promise"><x path="Bool"/></c>
</f></load>
		<update public="1" set="method"><f a="response">
	<x path="haxe.extern.EitherType">
		<c path="js.html.ArrayBufferView"/>
		<c path="js.html.ArrayBuffer"/>
	</x>
	<c path="js.Promise"><x path="Void"/></c>
</f></update>
		<close public="1" set="method"><f a=""><c path="js.Promise"><x path="Void"/></c></f></close>
		<remove public="1" set="method"><f a=""><c path="js.Promise"><x path="Void"/></c></f></remove>
		<getUsableKeyIds public="1" set="method"><f a=""><c path="js.Promise"><c path="Array"><c path="js.html.ArrayBuffer"/></c></c></f></getUsableKeyIds>
		<meta><m n=":native"><e>"MediaKeySession"</e></m></meta>
	</class>
	<class path="js.html.MediaKeySystemAccess" params="" file="C:\HaxeToolkit\haxe\std/js/html/MediaKeySystemAccess.hx" extern="1">
		<keySystem public="1" set="null"><c path="String"/></keySystem>
		<createMediaKeys public="1" set="method"><f a=""><c path="js.Promise"><c path="js.html.MediaKeys"/></c></f></createMediaKeys>
		<meta><m n=":native"><e>"MediaKeySystemAccess"</e></m></meta>
	</class>
	<typedef path="js.html.MediaKeySystemOptions" params="" file="C:\HaxeToolkit\haxe\std/js/html/MediaKeySystemOptions.hx"><a>
	<videoType>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</videoType>
	<videoCapability>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</videoCapability>
	<uniqueidentifier>
		<t path="Null"><d/></t>
		<meta><m n=":optional"/></meta>
	</uniqueidentifier>
	<stateful>
		<t path="Null"><d/></t>
		<meta><m n=":optional"/></meta>
	</stateful>
	<initDataType>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</initDataType>
	<audioType>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</audioType>
	<audioCapability>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</audioCapability>
</a></typedef>
	<class path="js.html.MediaKeys" params="" file="C:\HaxeToolkit\haxe\std/js/html/MediaKeys.hx" extern="1">
		<keySystem public="1" set="null"><c path="String"/></keySystem>
		<createSession public="1" set="method">
			<f a="?sessionType" v="&quot;temporary&quot;">
				<x path="js.html.SessionType"/>
				<c path="js.html.MediaKeySession"/>
			</f>
			<meta><m n=":value"><e>{sessionType:"temporary"}</e></m></meta>
			<haxe_doc>@throws DOMError</haxe_doc>
		</createSession>
		<setServerCertificate public="1" set="method"><f a="serverCertificate">
	<x path="haxe.extern.EitherType">
		<c path="js.html.ArrayBufferView"/>
		<c path="js.html.ArrayBuffer"/>
	</x>
	<c path="js.Promise"><x path="Void"/></c>
</f></setServerCertificate>
		<meta><m n=":native"><e>"MediaKeys"</e></m></meta>
	</class>
	<class path="js.html.MediaList" params="" file="C:\HaxeToolkit\haxe\std/js/html/MediaList.hx" extern="1">
		<mediaText public="1"><c path="String"/></mediaText>
		<length public="1" set="null"><x path="Int"/></length>
		<item public="1" set="method"><f a="index">
	<x path="Int"/>
	<c path="String"/>
</f></item>
		<deleteMedium public="1" set="method">
			<f a="oldMedium">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</deleteMedium>
		<appendMedium public="1" set="method">
			<f a="newMedium">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</appendMedium>
		<meta><m n=":native"><e>"MediaList"</e></m></meta>
	</class>
	<class path="js.html.MediaQueryList" params="" file="C:\HaxeToolkit\haxe\std/js/html/MediaQueryList.hx" extern="1">
		<media public="1" set="null"><c path="String"/></media>
		<matches public="1" set="null"><x path="Bool"/></matches>
		<addListener public="1" set="method"><f a="listener">
	<f a="">
		<c path="js.html.MediaQueryList"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></addListener>
		<removeListener public="1" set="method"><f a="listener">
	<f a="">
		<c path="js.html.MediaQueryList"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></removeListener>
		<meta><m n=":native"><e>"MediaQueryList"</e></m></meta>
	</class>
	<class path="js.html.MediaStream" params="" file="C:\HaxeToolkit\haxe\std/js/html/MediaStream.hx" extern="1">
		<extends path="js.html.EventTarget"/>
		<currentTime public="1" set="null"><x path="Float"/></currentTime>
		<getAudioTracks public="1" set="method"><f a=""><c path="Array"><c path="js.html.AudioStreamTrack"/></c></f></getAudioTracks>
		<getVideoTracks public="1" set="method"><f a=""><c path="Array"><c path="js.html.VideoStreamTrack"/></c></f></getVideoTracks>
		<getTracks public="1" set="method"><f a=""><c path="Array"><c path="js.html.MediaStreamTrack"/></c></f></getTracks>
		<meta><m n=":native"><e>"MediaStream"</e></m></meta>
	</class>
	<abstract path="js.html.MediaWaitingFor" params="" file="C:\HaxeToolkit\haxe\std/js/html/MediaWaitingFor.hx">
		<this><c path="String"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="js.html._MediaWaitingFor.MediaWaitingFor_Impl_" params="" file="C:\HaxeToolkit\haxe\std/js/html/MediaWaitingFor.hx" private="1" module="js.html.MediaWaitingFor"><meta>
	<m n=":keep"/>
	<m n=":enum"/>
</meta></class></impl>
	</abstract>
	<class path="js.html.MenuElement" params="" file="C:\HaxeToolkit\haxe\std/js/html/MenuElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<type public="1"><c path="String"/></type>
		<label public="1"><c path="String"/></label>
		<compact public="1"><x path="Bool"/></compact>
		<meta><m n=":native"><e>"HTMLMenuElement"</e></m></meta>
	</class>
	<class path="js.html.MetaElement" params="" file="C:\HaxeToolkit\haxe\std/js/html/MetaElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<name public="1"><c path="String"/></name>
		<httpEquiv public="1"><c path="String"/></httpEquiv>
		<content public="1"><c path="String"/></content>
		<scheme public="1"><c path="String"/></scheme>
		<meta><m n=":native"><e>"HTMLMetaElement"</e></m></meta>
	</class>
	<class path="js.html.MeterElement" params="" file="C:\HaxeToolkit\haxe\std/js/html/MeterElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<value public="1"><x path="Float"/></value>
		<min public="1"><x path="Float"/></min>
		<max public="1"><x path="Float"/></max>
		<low public="1"><x path="Float"/></low>
		<high public="1"><x path="Float"/></high>
		<optimum public="1"><x path="Float"/></optimum>
		<meta><m n=":native"><e>"HTMLMeterElement"</e></m></meta>
	</class>
	<class path="js.html.MimeType" params="" file="C:\HaxeToolkit\haxe\std/js/html/MimeType.hx" extern="1">
		<description public="1" set="null"><c path="String"/></description>
		<enabledPlugin public="1" set="null"><c path="js.html.Plugin"/></enabledPlugin>
		<suffixes public="1" set="null"><c path="String"/></suffixes>
		<type public="1" set="null"><c path="String"/></type>
		<meta><m n=":native"><e>"MimeType"</e></m></meta>
	</class>
	<class path="js.html.MimeTypeArray" params="" file="C:\HaxeToolkit\haxe\std/js/html/MimeTypeArray.hx" extern="1">
		<length public="1" set="null"><x path="Int"/></length>
		<item public="1" set="method"><f a="index">
	<x path="Int"/>
	<c path="js.html.MimeType"/>
</f></item>
		<namedItem public="1" set="method"><f a="name">
	<c path="String"/>
	<c path="js.html.MimeType"/>
</f></namedItem>
		<meta><m n=":native"><e>"MimeTypeArray"</e></m></meta>
	</class>
	<class path="js.html.ModElement" params="" file="C:\HaxeToolkit\haxe\std/js/html/ModElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<cite public="1"><c path="String"/></cite>
		<dateTime public="1"><c path="String"/></dateTime>
		<meta><m n=":native"><e>"HTMLModElement"</e></m></meta>
	</class>
	<class path="js.html.UIEvent" params="" file="C:\HaxeToolkit\haxe\std/js/html/UIEvent.hx" extern="1">
		<extends path="js.html.Event"/>
		<SCROLL_PAGE_UP public="1" get="inline" set="null" expr="-32768" line="30" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>-32768</e></m></meta>
		</SCROLL_PAGE_UP>
		<SCROLL_PAGE_DOWN public="1" get="inline" set="null" expr="32768" line="31" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>32768</e></m></meta>
		</SCROLL_PAGE_DOWN>
		<view public="1" set="null"><c path="js.html.Window"/></view>
		<detail public="1" set="null"><x path="Int"/></detail>
		<layerX public="1" set="null"><x path="Int"/></layerX>
		<layerY public="1" set="null"><x path="Int"/></layerY>
		<pageX public="1" set="null"><x path="Int"/></pageX>
		<pageY public="1" set="null"><x path="Int"/></pageY>
		<which public="1" set="null"><x path="Int"/></which>
		<rangeParent public="1" set="null"><c path="js.html.Node"/></rangeParent>
		<rangeOffset public="1" set="null"><x path="Int"/></rangeOffset>
		<cancelBubble public="1"><x path="Bool"/></cancelBubble>
		<isChar public="1" set="null"><x path="Bool"/></isChar>
		<initUIEvent public="1" set="method"><f a="aType:aCanBubble:aCancelable:aView:aDetail">
	<c path="String"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<c path="js.html.Window"/>
	<x path="Int"/>
	<x path="Void"/>
</f></initUIEvent>
		<new public="1" set="method">
			<f a="type:?eventInitDict">
				<c path="String"/>
				<t path="js.html.UIEventInit"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</new>
		<meta><m n=":native"><e>"UIEvent"</e></m></meta>
	</class>
	<class path="js.html.MouseEvent" params="" file="C:\HaxeToolkit\haxe\std/js/html/MouseEvent.hx" extern="1">
		<extends path="js.html.UIEvent"/>
		<screenX public="1" set="null"><x path="Int"/></screenX>
		<screenY public="1" set="null"><x path="Int"/></screenY>
		<clientX public="1" set="null"><x path="Int"/></clientX>
		<clientY public="1" set="null"><x path="Int"/></clientY>
		<ctrlKey public="1" set="null"><x path="Bool"/></ctrlKey>
		<shiftKey public="1" set="null"><x path="Bool"/></shiftKey>
		<altKey public="1" set="null"><x path="Bool"/></altKey>
		<metaKey public="1" set="null"><x path="Bool"/></metaKey>
		<button public="1" set="null"><x path="Int"/></button>
		<buttons public="1" set="null"><x path="Int"/></buttons>
		<relatedTarget public="1" set="null"><c path="js.html.EventTarget"/></relatedTarget>
		<region public="1" set="null"><c path="String"/></region>
		<movementX public="1" set="null"><x path="Int"/></movementX>
		<movementY public="1" set="null"><x path="Int"/></movementY>
		<initMouseEvent public="1" set="method">
			<f a="typeArg:canBubbleArg:cancelableArg:viewArg:detailArg:screenXArg:screenYArg:clientXArg:clientYArg:ctrlKeyArg:altKeyArg:shiftKeyArg:metaKeyArg:buttonArg:relatedTargetArg">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<c path="js.html.Window"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Int"/>
				<c path="js.html.EventTarget"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</initMouseEvent>
		<getModifierState public="1" set="method"><f a="keyArg">
	<c path="String"/>
	<x path="Bool"/>
</f></getModifierState>
		<initNSMouseEvent public="1" set="method">
			<f a="typeArg:canBubbleArg:cancelableArg:viewArg:detailArg:screenXArg:screenYArg:clientXArg:clientYArg:ctrlKeyArg:altKeyArg:shiftKeyArg:metaKeyArg:buttonArg:relatedTargetArg:pressure:inputSourceArg">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<c path="js.html.Window"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Int"/>
				<c path="js.html.EventTarget"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</initNSMouseEvent>
		<new public="1" set="method">
			<f a="typeArg:?mouseEventInitDict">
				<c path="String"/>
				<t path="js.html.MouseEventInit"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</new>
		<meta><m n=":native"><e>"MouseEvent"</e></m></meta>
	</class>
	<typedef path="js.html.MouseEventInit" params="" file="C:\HaxeToolkit\haxe\std/js/html/MouseEventInit.hx"><a>
	<view>
		<t path="Null"><c path="js.html.Window"/></t>
		<meta><m n=":optional"/></meta>
	</view>
	<shiftKey>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</shiftKey>
	<screenY>
		<t path="Null"><x path="Int"/></t>
		<meta><m n=":optional"/></meta>
	</screenY>
	<screenX>
		<t path="Null"><x path="Int"/></t>
		<meta><m n=":optional"/></meta>
	</screenX>
	<relatedTarget>
		<t path="Null"><c path="js.html.EventTarget"/></t>
		<meta><m n=":optional"/></meta>
	</relatedTarget>
	<metaKey>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</metaKey>
	<detail>
		<t path="Null"><x path="Int"/></t>
		<meta><m n=":optional"/></meta>
	</detail>
	<ctrlKey>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</ctrlKey>
	<clientY>
		<t path="Null"><x path="Int"/></t>
		<meta><m n=":optional"/></meta>
	</clientY>
	<clientX>
		<t path="Null"><x path="Int"/></t>
		<meta><m n=":optional"/></meta>
	</clientX>
	<cancelable>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</cancelable>
	<buttons>
		<t path="Null"><x path="Int"/></t>
		<meta><m n=":optional"/></meta>
	</buttons>
	<button>
		<t path="Null"><x path="Int"/></t>
		<meta><m n=":optional"/></meta>
	</button>
	<bubbles>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</bubbles>
	<altKey>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</altKey>
</a></typedef>
	<class path="js.html.NamedNodeMap" params="" file="C:\HaxeToolkit\haxe\std/js/html/NamedNodeMap.hx" extern="1">
		<length public="1" set="null"><x path="Int"/></length>
		<getNamedItem public="1" set="method"><f a="name">
	<c path="String"/>
	<c path="js.html.Attr"/>
</f></getNamedItem>
		<setNamedItem public="1" set="method">
			<f a="arg">
				<c path="js.html.Attr"/>
				<c path="js.html.Attr"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</setNamedItem>
		<removeNamedItem public="1" set="method">
			<f a="name">
				<c path="String"/>
				<c path="js.html.Attr"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</removeNamedItem>
		<item public="1" set="method"><f a="index">
	<x path="Int"/>
	<c path="js.html.Attr"/>
</f></item>
		<getNamedItemNS public="1" set="method"><f a="namespaceURI:localName">
	<c path="String"/>
	<c path="String"/>
	<c path="js.html.Attr"/>
</f></getNamedItemNS>
		<setNamedItemNS public="1" set="method">
			<f a="arg">
				<c path="js.html.Attr"/>
				<c path="js.html.Attr"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</setNamedItemNS>
		<removeNamedItemNS public="1" set="method">
			<f a="namespaceURI:localName">
				<c path="String"/>
				<c path="String"/>
				<c path="js.html.Attr"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</removeNamedItemNS>
		<meta><m n=":native"><e>"NamedNodeMap"</e></m></meta>
	</class>
	<class path="js.html.Navigator" params="" file="C:\HaxeToolkit\haxe\std/js/html/Navigator.hx" extern="1">
		<mimeTypes public="1" set="null"><c path="js.html.MimeTypeArray"/></mimeTypes>
		<plugins public="1" set="null"><c path="js.html.PluginArray"/></plugins>
		<doNotTrack public="1" set="null"><c path="String"/></doNotTrack>
		<maxTouchPoints public="1" set="null"><x path="Int"/></maxTouchPoints>
		<oscpu public="1" set="null"><c path="String"/></oscpu>
		<vendor public="1" set="null"><c path="String"/></vendor>
		<vendorSub public="1" set="null"><c path="String"/></vendorSub>
		<productSub public="1" set="null"><c path="String"/></productSub>
		<cookieEnabled public="1" set="null"><x path="Bool"/></cookieEnabled>
		<buildID public="1" set="null"><c path="String"/></buildID>
		<battery public="1" set="null"><c path="js.html.BatteryManager"/></battery>
		<geolocation public="1" set="null"><c path="js.html.Geolocation"/></geolocation>
		<appCodeName public="1" set="null"><c path="String"/></appCodeName>
		<appName public="1" set="null"><c path="String"/></appName>
		<appVersion public="1" set="null"><c path="String"/></appVersion>
		<platform public="1" set="null"><c path="String"/></platform>
		<userAgent public="1" set="null"><c path="String"/></userAgent>
		<product public="1" set="null"><c path="String"/></product>
		<language public="1" set="null"><c path="String"/></language>
		<languages public="1" set="null"><c path="Array"><c path="String"/></c></languages>
		<onLine public="1" set="null"><x path="Bool"/></onLine>
		<vibrate public="1" set="method">
			<f a="pattern">
				<c path="Array"><x path="Int"/></c>
				<x path="Bool"/>
			</f>
			<overloads><vibrate public="1" set="method"><f a="duration">
	<x path="Int"/>
	<x path="Bool"/>
</f></vibrate></overloads>
		</vibrate>
		<javaEnabled public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</javaEnabled>
		<getGamepads public="1" set="method">
			<f a=""><c path="Array"><c path="js.html.Gamepad"/></c></f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</getGamepads>
		<sendBeacon public="1" set="method">
			<f a="url:?data">
				<c path="String"/>
				<x path="haxe.extern.EitherType">
					<c path="js.html.ArrayBufferView"/>
					<x path="haxe.extern.EitherType">
						<c path="js.html.Blob"/>
						<x path="haxe.extern.EitherType">
							<c path="String"/>
							<c path="js.html.FormData"/>
						</x>
					</x>
				</x>
				<x path="Bool"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</sendBeacon>
		<requestMediaKeySystemAccess public="1" set="method"><f a="keySystem:?supportedConfigurations">
	<c path="String"/>
	<c path="Array"><t path="js.html.MediaKeySystemOptions"/></c>
	<c path="js.Promise"><c path="js.html.MediaKeySystemAccess"/></c>
</f></requestMediaKeySystemAccess>
		<registerProtocolHandler public="1" set="method">
			<f a="scheme:url:title">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</registerProtocolHandler>
		<registerContentHandler public="1" set="method">
			<f a="mimeType:url:title">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</registerContentHandler>
		<taintEnabled public="1" set="method"><f a=""><x path="Bool"/></f></taintEnabled>
		<meta><m n=":native"><e>"Navigator"</e></m></meta>
	</class>
	<class path="js.html.NodeFilter" params="" file="C:\HaxeToolkit\haxe\std/js/html/NodeFilter.hx" extern="1">
		<FILTER_ACCEPT public="1" get="inline" set="null" expr="1" line="30" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</FILTER_ACCEPT>
		<FILTER_REJECT public="1" get="inline" set="null" expr="2" line="31" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2</e></m></meta>
		</FILTER_REJECT>
		<FILTER_SKIP public="1" get="inline" set="null" expr="3" line="32" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3</e></m></meta>
		</FILTER_SKIP>
		<SHOW_ALL public="1" get="inline" set="null" expr="&apos;???&apos;" line="33" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>'???'</e></m></meta>
		</SHOW_ALL>
		<SHOW_ELEMENT public="1" get="inline" set="null" expr="1" line="34" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</SHOW_ELEMENT>
		<SHOW_ATTRIBUTE public="1" get="inline" set="null" expr="2" line="35" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2</e></m></meta>
		</SHOW_ATTRIBUTE>
		<SHOW_TEXT public="1" get="inline" set="null" expr="4" line="36" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>4</e></m></meta>
		</SHOW_TEXT>
		<SHOW_CDATA_SECTION public="1" get="inline" set="null" expr="8" line="37" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>8</e></m></meta>
		</SHOW_CDATA_SECTION>
		<SHOW_ENTITY_REFERENCE public="1" get="inline" set="null" expr="16" line="38" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>16</e></m></meta>
		</SHOW_ENTITY_REFERENCE>
		<SHOW_ENTITY public="1" get="inline" set="null" expr="32" line="39" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>32</e></m></meta>
		</SHOW_ENTITY>
		<SHOW_PROCESSING_INSTRUCTION public="1" get="inline" set="null" expr="64" line="40" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>64</e></m></meta>
		</SHOW_PROCESSING_INSTRUCTION>
		<SHOW_COMMENT public="1" get="inline" set="null" expr="128" line="41" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>128</e></m></meta>
		</SHOW_COMMENT>
		<SHOW_DOCUMENT public="1" get="inline" set="null" expr="256" line="42" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>256</e></m></meta>
		</SHOW_DOCUMENT>
		<SHOW_DOCUMENT_TYPE public="1" get="inline" set="null" expr="512" line="43" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>512</e></m></meta>
		</SHOW_DOCUMENT_TYPE>
		<SHOW_DOCUMENT_FRAGMENT public="1" get="inline" set="null" expr="1024" line="44" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1024</e></m></meta>
		</SHOW_DOCUMENT_FRAGMENT>
		<SHOW_NOTATION public="1" get="inline" set="null" expr="2048" line="45" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2048</e></m></meta>
		</SHOW_NOTATION>
		<acceptNode public="1" set="method"><f a="node">
	<c path="js.html.Node"/>
	<x path="Int"/>
</f></acceptNode>
		<meta><m n=":native"><e>"NodeFilter"</e></m></meta>
	</class>
	<class path="js.html.NodeIterator" params="" file="C:\HaxeToolkit\haxe\std/js/html/NodeIterator.hx" extern="1">
		<root public="1" set="null"><c path="js.html.Node"/></root>
		<referenceNode public="1" set="null"><c path="js.html.Node"/></referenceNode>
		<pointerBeforeReferenceNode public="1" set="null"><x path="Bool"/></pointerBeforeReferenceNode>
		<whatToShow public="1" set="null"><x path="Int"/></whatToShow>
		<filter public="1" set="null"><c path="js.html.NodeFilter"/></filter>
		<nextNode public="1" set="method">
			<f a=""><c path="js.html.Node"/></f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</nextNode>
		<previousNode public="1" set="method">
			<f a=""><c path="js.html.Node"/></f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</previousNode>
		<detach public="1" set="method"><f a=""><x path="Void"/></f></detach>
		<meta><m n=":native"><e>"NodeIterator"</e></m></meta>
	</class>
	<class path="js.html.NodeList" params="" file="C:\HaxeToolkit\haxe\std/js/html/NodeList.hx" extern="1">
		<length public="1" set="null"><x path="Int"/></length>
		<item public="1" set="method"><f a="index">
	<x path="Int"/>
	<c path="js.html.Node"/>
</f></item>
		<meta><m n=":native"><e>"NodeList"</e></m></meta>
	</class>
	<class path="js.html.OListElement" params="" file="C:\HaxeToolkit\haxe\std/js/html/OListElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<reversed public="1"><x path="Bool"/></reversed>
		<start public="1"><x path="Int"/></start>
		<type public="1"><c path="String"/></type>
		<compact public="1"><x path="Bool"/></compact>
		<meta><m n=":native"><e>"HTMLOListElement"</e></m></meta>
	</class>
	<class path="js.html.ObjectElement" params="" file="C:\HaxeToolkit\haxe\std/js/html/ObjectElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<data public="1"><c path="String"/></data>
		<type public="1"><c path="String"/></type>
		<typeMustMatch public="1"><x path="Bool"/></typeMustMatch>
		<name public="1"><c path="String"/></name>
		<useMap public="1"><c path="String"/></useMap>
		<form public="1" set="null"><c path="js.html.FormElement"/></form>
		<width public="1"><c path="String"/></width>
		<height public="1"><c path="String"/></height>
		<contentDocument public="1" set="null"><c path="js.html.HTMLDocument"/></contentDocument>
		<contentWindow public="1" set="null"><c path="js.html.Window"/></contentWindow>
		<willValidate public="1" set="null"><x path="Bool"/></willValidate>
		<validity public="1" set="null"><c path="js.html.ValidityState"/></validity>
		<validationMessage public="1" set="null"><c path="String"/></validationMessage>
		<align public="1"><c path="String"/></align>
		<archive public="1"><c path="String"/></archive>
		<code public="1"><c path="String"/></code>
		<declare public="1"><x path="Bool"/></declare>
		<hspace public="1"><x path="Int"/></hspace>
		<standby public="1"><c path="String"/></standby>
		<vspace public="1"><x path="Int"/></vspace>
		<codeBase public="1"><c path="String"/></codeBase>
		<codeType public="1"><c path="String"/></codeType>
		<border public="1"><c path="String"/></border>
		<checkValidity public="1" set="method"><f a=""><x path="Bool"/></f></checkValidity>
		<setCustomValidity public="1" set="method"><f a="error">
	<c path="String"/>
	<x path="Void"/>
</f></setCustomValidity>
		<getSVGDocument public="1" set="method"><f a=""><c path="js.html.HTMLDocument"/></f></getSVGDocument>
		<meta><m n=":native"><e>"HTMLObjectElement"</e></m></meta>
	</class>
	<class path="js.html.OptGroupElement" params="" file="C:\HaxeToolkit\haxe\std/js/html/OptGroupElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<disabled public="1"><x path="Bool"/></disabled>
		<label public="1"><c path="String"/></label>
		<meta><m n=":native"><e>"HTMLOptGroupElement"</e></m></meta>
	</class>
	<class path="js.html.OptionElement" params="" file="C:\HaxeToolkit\haxe\std/js/html/OptionElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<disabled public="1"><x path="Bool"/></disabled>
		<form public="1" set="null"><c path="js.html.FormElement"/></form>
		<label public="1"><c path="String"/></label>
		<defaultSelected public="1"><x path="Bool"/></defaultSelected>
		<selected public="1"><x path="Bool"/></selected>
		<value public="1"><c path="String"/></value>
		<text public="1"><c path="String"/></text>
		<index public="1" set="null"><x path="Int"/></index>
		<meta><m n=":native"><e>"HTMLOptionElement"</e></m></meta>
	</class>
	<class path="js.html.OutputElement" params="" file="C:\HaxeToolkit\haxe\std/js/html/OutputElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<htmlFor public="1" set="null"><c path="js.html.DOMSettableTokenList"/></htmlFor>
		<form public="1" set="null"><c path="js.html.FormElement"/></form>
		<name public="1"><c path="String"/></name>
		<type public="1" set="null"><c path="String"/></type>
		<defaultValue public="1"><c path="String"/></defaultValue>
		<value public="1"><c path="String"/></value>
		<willValidate public="1" set="null"><x path="Bool"/></willValidate>
		<validity public="1" set="null"><c path="js.html.ValidityState"/></validity>
		<validationMessage public="1" set="null"><c path="String"/></validationMessage>
		<checkValidity public="1" set="method"><f a=""><x path="Bool"/></f></checkValidity>
		<setCustomValidity public="1" set="method"><f a="error">
	<c path="String"/>
	<x path="Void"/>
</f></setCustomValidity>
		<meta><m n=":native"><e>"HTMLOutputElement"</e></m></meta>
	</class>
	<class path="js.html.ParagraphElement" params="" file="C:\HaxeToolkit\haxe\std/js/html/ParagraphElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<align public="1"><c path="String"/></align>
		<meta><m n=":native"><e>"HTMLParagraphElement"</e></m></meta>
	</class>
	<class path="js.html.ParamElement" params="" file="C:\HaxeToolkit\haxe\std/js/html/ParamElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<name public="1"><c path="String"/></name>
		<value public="1"><c path="String"/></value>
		<type public="1"><c path="String"/></type>
		<valueType public="1"><c path="String"/></valueType>
		<meta><m n=":native"><e>"HTMLParamElement"</e></m></meta>
	</class>
	<class path="js.html.Path2D" params="" file="C:\HaxeToolkit\haxe\std/js/html/Path2D.hx" extern="1">
		<addPath public="1" set="method"><f a="path:?transformation">
	<c path="js.html.Path2D"/>
	<c path="js.html.svg.Matrix"/>
	<x path="Void"/>
</f></addPath>
		<closePath public="1" set="method"><f a=""><x path="Void"/></f></closePath>
		<moveTo public="1" set="method"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></moveTo>
		<lineTo public="1" set="method"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></lineTo>
		<quadraticCurveTo public="1" set="method"><f a="cpx:cpy:x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></quadraticCurveTo>
		<bezierCurveTo public="1" set="method"><f a="cp1x:cp1y:cp2x:cp2y:x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></bezierCurveTo>
		<arcTo public="1" set="method">
			<f a="x1:y1:x2:y2:radius">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</arcTo>
		<rect public="1" set="method"><f a="x:y:w:h">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></rect>
		<arc public="1" set="method">
			<f a="x:y:radius:startAngle:endAngle:?anticlockwise" v=":::::false">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{anticlockwise:false}</e></m></meta>
			<haxe_doc>@throws DOMError</haxe_doc>
		</arc>
		<new public="1" set="method">
			<f a="pathString">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
			<overloads>
				<new public="1" set="method">
					<f a=""><x path="Void"/></f>
					<haxe_doc>@throws DOMError</haxe_doc>
				</new>
				<new public="1" set="method">
					<f a="other">
						<c path="js.html.Path2D"/>
						<x path="Void"/>
					</f>
					<haxe_doc>@throws DOMError</haxe_doc>
				</new>
			</overloads>
		</new>
		<meta><m n=":native"><e>"Path2D"</e></m></meta>
	</class>
	<class path="js.html.Performance" params="" file="C:\HaxeToolkit\haxe\std/js/html/Performance.hx" extern="1">
		<timing public="1" set="null"><c path="js.html.PerformanceTiming"/></timing>
		<navigation public="1" set="null"><c path="js.html.PerformanceNavigation"/></navigation>
		<now public="1" set="method"><f a=""><x path="Float"/></f></now>
		<meta><m n=":native"><e>"Performance"</e></m></meta>
	</class>
	<class path="js.html.PerformanceNavigation" params="" file="C:\HaxeToolkit\haxe\std/js/html/PerformanceNavigation.hx" extern="1">
		<TYPE_NAVIGATE public="1" get="inline" set="null" expr="0" line="30" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</TYPE_NAVIGATE>
		<TYPE_RELOAD public="1" get="inline" set="null" expr="1" line="31" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</TYPE_RELOAD>
		<TYPE_BACK_FORWARD public="1" get="inline" set="null" expr="2" line="32" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2</e></m></meta>
		</TYPE_BACK_FORWARD>
		<TYPE_RESERVED public="1" get="inline" set="null" expr="255" line="33" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>255</e></m></meta>
		</TYPE_RESERVED>
		<type public="1" set="null"><x path="Int"/></type>
		<redirectCount public="1" set="null"><x path="Int"/></redirectCount>
		<meta><m n=":native"><e>"PerformanceNavigation"</e></m></meta>
	</class>
	<class path="js.html.PerformanceTiming" params="" file="C:\HaxeToolkit\haxe\std/js/html/PerformanceTiming.hx" extern="1">
		<navigationStart public="1" set="null"><x path="Int"/></navigationStart>
		<unloadEventStart public="1" set="null"><x path="Int"/></unloadEventStart>
		<unloadEventEnd public="1" set="null"><x path="Int"/></unloadEventEnd>
		<redirectStart public="1" set="null"><x path="Int"/></redirectStart>
		<redirectEnd public="1" set="null"><x path="Int"/></redirectEnd>
		<fetchStart public="1" set="null"><x path="Int"/></fetchStart>
		<domainLookupStart public="1" set="null"><x path="Int"/></domainLookupStart>
		<domainLookupEnd public="1" set="null"><x path="Int"/></domainLookupEnd>
		<connectStart public="1" set="null"><x path="Int"/></connectStart>
		<connectEnd public="1" set="null"><x path="Int"/></connectEnd>
		<requestStart public="1" set="null"><x path="Int"/></requestStart>
		<responseStart public="1" set="null"><x path="Int"/></responseStart>
		<responseEnd public="1" set="null"><x path="Int"/></responseEnd>
		<domLoading public="1" set="null"><x path="Int"/></domLoading>
		<domInteractive public="1" set="null"><x path="Int"/></domInteractive>
		<domContentLoadedEventStart public="1" set="null"><x path="Int"/></domContentLoadedEventStart>
		<domContentLoadedEventEnd public="1" set="null"><x path="Int"/></domContentLoadedEventEnd>
		<domComplete public="1" set="null"><x path="Int"/></domComplete>
		<loadEventStart public="1" set="null"><x path="Int"/></loadEventStart>
		<loadEventEnd public="1" set="null"><x path="Int"/></loadEventEnd>
		<meta><m n=":native"><e>"PerformanceTiming"</e></m></meta>
	</class>
	<class path="js.html.PictureElement" params="" file="C:\HaxeToolkit\haxe\std/js/html/PictureElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<meta><m n=":native"><e>"HTMLPictureElement"</e></m></meta>
	</class>
	<class path="js.html.Plugin" params="" file="C:\HaxeToolkit\haxe\std/js/html/Plugin.hx" extern="1">
		<description public="1" set="null"><c path="String"/></description>
		<filename public="1" set="null"><c path="String"/></filename>
		<version public="1" set="null"><c path="String"/></version>
		<name public="1" set="null"><c path="String"/></name>
		<length public="1" set="null"><x path="Int"/></length>
		<item public="1" set="method"><f a="index">
	<x path="Int"/>
	<c path="js.html.MimeType"/>
</f></item>
		<namedItem public="1" set="method"><f a="name">
	<c path="String"/>
	<c path="js.html.MimeType"/>
</f></namedItem>
		<meta><m n=":native"><e>"Plugin"</e></m></meta>
	</class>
	<class path="js.html.PluginArray" params="" file="C:\HaxeToolkit\haxe\std/js/html/PluginArray.hx" extern="1">
		<length public="1" set="null"><x path="Int"/></length>
		<item public="1" set="method"><f a="index">
	<x path="Int"/>
	<c path="js.html.Plugin"/>
</f></item>
		<namedItem public="1" set="method"><f a="name">
	<c path="String"/>
	<c path="js.html.Plugin"/>
</f></namedItem>
		<refresh public="1" set="method">
			<f a="?reloadDocuments" v="false">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{reloadDocuments:false}</e></m></meta>
		</refresh>
		<meta><m n=":native"><e>"PluginArray"</e></m></meta>
	</class>
	<class path="js.html.Position" params="" file="C:\HaxeToolkit\haxe\std/js/html/Position.hx" extern="1">
		<coords public="1" set="null"><c path="js.html.Coordinates"/></coords>
		<timestamp public="1" set="null"><x path="Int"/></timestamp>
		<meta><m n=":native"><e>"Position"</e></m></meta>
	</class>
	<class path="js.html.PositionError" params="" file="C:\HaxeToolkit\haxe\std/js/html/PositionError.hx" extern="1">
		<PERMISSION_DENIED public="1" get="inline" set="null" expr="1" line="30" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</PERMISSION_DENIED>
		<POSITION_UNAVAILABLE public="1" get="inline" set="null" expr="2" line="31" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2</e></m></meta>
		</POSITION_UNAVAILABLE>
		<TIMEOUT public="1" get="inline" set="null" expr="3" line="32" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3</e></m></meta>
		</TIMEOUT>
		<code public="1" set="null"><x path="Int"/></code>
		<message public="1" set="null"><c path="String"/></message>
		<meta><m n=":native"><e>"PositionError"</e></m></meta>
	</class>
	<typedef path="js.html.PositionOptions" params="" file="C:\HaxeToolkit\haxe\std/js/html/PositionOptions.hx"><a>
	<timeout>
		<t path="Null"><x path="Int"/></t>
		<meta><m n=":optional"/></meta>
	</timeout>
	<maximumAge>
		<t path="Null"><x path="Int"/></t>
		<meta><m n=":optional"/></meta>
	</maximumAge>
	<enableHighAccuracy>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</enableHighAccuracy>
</a></typedef>
	<class path="js.html.PreElement" params="" file="C:\HaxeToolkit\haxe\std/js/html/PreElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<width public="1"><x path="Int"/></width>
		<meta><m n=":native"><e>"HTMLPreElement"</e></m></meta>
	</class>
	<class path="js.html.ProcessingInstruction" params="" file="C:\HaxeToolkit\haxe\std/js/html/ProcessingInstruction.hx" extern="1">
		<extends path="js.html.CharacterData"/>
		<target public="1" set="null"><c path="String"/></target>
		<meta><m n=":native"><e>"ProcessingInstruction"</e></m></meta>
	</class>
	<class path="js.html.ProgressElement" params="" file="C:\HaxeToolkit\haxe\std/js/html/ProgressElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<value public="1"><x path="Float"/></value>
		<max public="1"><x path="Float"/></max>
		<position public="1" set="null"><x path="Float"/></position>
		<meta><m n=":native"><e>"HTMLProgressElement"</e></m></meta>
	</class>
	<class path="js.html.QuoteElement" params="" file="C:\HaxeToolkit\haxe\std/js/html/QuoteElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<cite public="1"><c path="String"/></cite>
		<meta><m n=":native"><e>"HTMLQuoteElement"</e></m></meta>
	</class>
	<class path="js.html.RGBColor" params="" file="C:\HaxeToolkit\haxe\std/js/html/RGBColor.hx" extern="1">
		<red public="1" set="null"><c path="js.html.CSSPrimitiveValue"/></red>
		<green public="1" set="null"><c path="js.html.CSSPrimitiveValue"/></green>
		<blue public="1" set="null"><c path="js.html.CSSPrimitiveValue"/></blue>
		<alpha public="1" set="null"><c path="js.html.CSSPrimitiveValue"/></alpha>
		<meta><m n=":native"><e>"RGBColor"</e></m></meta>
	</class>
	<class path="js.html.Range" params="" file="C:\HaxeToolkit\haxe\std/js/html/Range.hx" extern="1">
		<START_TO_START public="1" get="inline" set="null" expr="0" line="30" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</START_TO_START>
		<START_TO_END public="1" get="inline" set="null" expr="1" line="31" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</START_TO_END>
		<END_TO_END public="1" get="inline" set="null" expr="2" line="32" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2</e></m></meta>
		</END_TO_END>
		<END_TO_START public="1" get="inline" set="null" expr="3" line="33" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3</e></m></meta>
		</END_TO_START>
		<startContainer public="1" set="null"><c path="js.html.Node"/></startContainer>
		<startOffset public="1" set="null"><x path="Int"/></startOffset>
		<endContainer public="1" set="null"><c path="js.html.Node"/></endContainer>
		<endOffset public="1" set="null"><x path="Int"/></endOffset>
		<collapsed public="1" set="null"><x path="Bool"/></collapsed>
		<commonAncestorContainer public="1" set="null"><c path="js.html.Node"/></commonAncestorContainer>
		<setStart public="1" set="method">
			<f a="refNode:offset">
				<c path="js.html.Node"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</setStart>
		<setEnd public="1" set="method">
			<f a="refNode:offset">
				<c path="js.html.Node"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</setEnd>
		<setStartBefore public="1" set="method">
			<f a="refNode">
				<c path="js.html.Node"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</setStartBefore>
		<setStartAfter public="1" set="method">
			<f a="refNode">
				<c path="js.html.Node"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</setStartAfter>
		<setEndBefore public="1" set="method">
			<f a="refNode">
				<c path="js.html.Node"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</setEndBefore>
		<setEndAfter public="1" set="method">
			<f a="refNode">
				<c path="js.html.Node"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</setEndAfter>
		<collapse public="1" set="method">
			<f a="?toStart" v="false">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{toStart:false}</e></m></meta>
		</collapse>
		<selectNode public="1" set="method">
			<f a="refNode">
				<c path="js.html.Node"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</selectNode>
		<selectNodeContents public="1" set="method">
			<f a="refNode">
				<c path="js.html.Node"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</selectNodeContents>
		<compareBoundaryPoints public="1" set="method">
			<f a="how:sourceRange">
				<x path="Int"/>
				<c path="js.html.Range"/>
				<x path="Int"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</compareBoundaryPoints>
		<deleteContents public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</deleteContents>
		<extractContents public="1" set="method">
			<f a=""><c path="js.html.DocumentFragment"/></f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</extractContents>
		<cloneContents public="1" set="method">
			<f a=""><c path="js.html.DocumentFragment"/></f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</cloneContents>
		<insertNode public="1" set="method">
			<f a="node">
				<c path="js.html.Node"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</insertNode>
		<surroundContents public="1" set="method">
			<f a="newParent">
				<c path="js.html.Node"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</surroundContents>
		<cloneRange public="1" set="method"><f a=""><c path="js.html.Range"/></f></cloneRange>
		<detach public="1" set="method"><f a=""><x path="Void"/></f></detach>
		<isPointInRange public="1" set="method">
			<f a="node:offset">
				<c path="js.html.Node"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</isPointInRange>
		<comparePoint public="1" set="method">
			<f a="node:offset">
				<c path="js.html.Node"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</comparePoint>
		<intersectsNode public="1" set="method">
			<f a="node">
				<c path="js.html.Node"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</intersectsNode>
		<createContextualFragment public="1" set="method">
			<f a="fragment">
				<c path="String"/>
				<c path="js.html.DocumentFragment"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</createContextualFragment>
		<getClientRects public="1" set="method"><f a=""><c path="js.html.DOMRectList"/></f></getClientRects>
		<getBoundingClientRect public="1" set="method"><f a=""><c path="js.html.DOMRect"/></f></getBoundingClientRect>
		<new public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</new>
		<meta><m n=":native"><e>"Range"</e></m></meta>
	</class>
	<class path="js.html.Rect" params="" file="C:\HaxeToolkit\haxe\std/js/html/Rect.hx" extern="1">
		<top public="1" set="null"><c path="js.html.CSSPrimitiveValue"/></top>
		<right public="1" set="null"><c path="js.html.CSSPrimitiveValue"/></right>
		<bottom public="1" set="null"><c path="js.html.CSSPrimitiveValue"/></bottom>
		<left public="1" set="null"><c path="js.html.CSSPrimitiveValue"/></left>
		<meta><m n=":native"><e>"Rect"</e></m></meta>
	</class>
	<class path="js.html.Screen" params="" file="C:\HaxeToolkit\haxe\std/js/html/Screen.hx" extern="1">
		<extends path="js.html.EventTarget"/>
		<availWidth public="1" set="null"><x path="Int"/></availWidth>
		<availHeight public="1" set="null"><x path="Int"/></availHeight>
		<width public="1" set="null"><x path="Int"/></width>
		<height public="1" set="null"><x path="Int"/></height>
		<colorDepth public="1" set="null"><x path="Int"/></colorDepth>
		<pixelDepth public="1" set="null"><x path="Int"/></pixelDepth>
		<top public="1" set="null"><x path="Int"/></top>
		<left public="1" set="null"><x path="Int"/></left>
		<availTop public="1" set="null"><x path="Int"/></availTop>
		<availLeft public="1" set="null"><x path="Int"/></availLeft>
		<meta><m n=":native"><e>"Screen"</e></m></meta>
	</class>
	<class path="js.html.ScriptElement" params="" file="C:\HaxeToolkit\haxe\std/js/html/ScriptElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<src public="1"><c path="String"/></src>
		<type public="1"><c path="String"/></type>
		<charset public="1"><c path="String"/></charset>
		<async public="1"><x path="Bool"/></async>
		<defer public="1"><x path="Bool"/></defer>
		<crossOrigin public="1"><c path="String"/></crossOrigin>
		<text public="1"><c path="String"/></text>
		<event public="1"><c path="String"/></event>
		<htmlFor public="1"><c path="String"/></htmlFor>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":native"><e>"HTMLScriptElement"</e></m>
		</meta>
	</class>
	<typedef path="js.html.ScrollIntoViewOptions" params="" file="C:\HaxeToolkit\haxe\std/js/html/ScrollIntoViewOptions.hx"><a>
	<block>
		<t path="Null"><d/></t>
		<meta><m n=":optional"/></meta>
	</block>
	<behavior>
		<t path="Null"><d/></t>
		<meta><m n=":optional"/></meta>
	</behavior>
</a></typedef>
	<typedef path="js.html.ScrollOptions" params="" file="C:\HaxeToolkit\haxe\std/js/html/ScrollOptions.hx"><a><behavior>
	<t path="Null"><d/></t>
	<meta><m n=":optional"/></meta>
</behavior></a></typedef>
	<typedef path="js.html.ScrollToOptions" params="" file="C:\HaxeToolkit\haxe\std/js/html/ScrollToOptions.hx"><a>
	<top>
		<t path="Null"><x path="Float"/></t>
		<meta><m n=":optional"/></meta>
	</top>
	<left>
		<t path="Null"><x path="Float"/></t>
		<meta><m n=":optional"/></meta>
	</left>
	<behavior>
		<t path="Null"><d/></t>
		<meta><m n=":optional"/></meta>
	</behavior>
</a></typedef>
	<class path="js.html.SelectElement" params="" file="C:\HaxeToolkit\haxe\std/js/html/SelectElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<autofocus public="1"><x path="Bool"/></autofocus>
		<disabled public="1"><x path="Bool"/></disabled>
		<form public="1" set="null"><c path="js.html.FormElement"/></form>
		<multiple public="1"><x path="Bool"/></multiple>
		<name public="1"><c path="String"/></name>
		<required public="1"><x path="Bool"/></required>
		<size public="1"><x path="Int"/></size>
		<type public="1" set="null"><c path="String"/></type>
		<options public="1" set="null"><c path="js.html.HTMLOptionsCollection"/></options>
		<length public="1"><x path="Int"/></length>
		<selectedOptions public="1" set="null"><c path="js.html.HTMLCollection"/></selectedOptions>
		<selectedIndex public="1"><x path="Int"/></selectedIndex>
		<value public="1"><c path="String"/></value>
		<willValidate public="1" set="null"><x path="Bool"/></willValidate>
		<validity public="1" set="null"><c path="js.html.ValidityState"/></validity>
		<validationMessage public="1" set="null"><c path="String"/></validationMessage>
		<item public="1" set="method"><f a="index">
	<x path="Int"/>
	<c path="js.html.Element"/>
</f></item>
		<namedItem public="1" set="method"><f a="name">
	<c path="String"/>
	<c path="js.html.OptionElement"/>
</f></namedItem>
		<add public="1" set="method">
			<f a="element:?before">
				<x path="haxe.extern.EitherType">
					<c path="js.html.OptionElement"/>
					<c path="js.html.OptGroupElement"/>
				</x>
				<x path="haxe.extern.EitherType">
					<c path="js.html.Element"/>
					<x path="Int"/>
				</x>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</add>
		<checkValidity public="1" set="method"><f a=""><x path="Bool"/></f></checkValidity>
		<setCustomValidity public="1" set="method"><f a="error">
	<c path="String"/>
	<x path="Void"/>
</f></setCustomValidity>
		<meta><m n=":native"><e>"HTMLSelectElement"</e></m></meta>
	</class>
	<class path="js.html.Selection" params="" file="C:\HaxeToolkit\haxe\std/js/html/Selection.hx" extern="1">
		<anchorNode public="1" set="null"><c path="js.html.Node"/></anchorNode>
		<anchorOffset public="1" set="null"><x path="Int"/></anchorOffset>
		<focusNode public="1" set="null"><c path="js.html.Node"/></focusNode>
		<focusOffset public="1" set="null"><x path="Int"/></focusOffset>
		<isCollapsed public="1" set="null"><x path="Bool"/></isCollapsed>
		<rangeCount public="1" set="null"><x path="Int"/></rangeCount>
		<collapse public="1" set="method">
			<f a="node:offset">
				<c path="js.html.Node"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</collapse>
		<collapseToStart public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</collapseToStart>
		<collapseToEnd public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</collapseToEnd>
		<extend public="1" set="method">
			<f a="node:offset">
				<c path="js.html.Node"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</extend>
		<selectAllChildren public="1" set="method">
			<f a="node">
				<c path="js.html.Node"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</selectAllChildren>
		<deleteFromDocument public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</deleteFromDocument>
		<getRangeAt public="1" set="method">
			<f a="index">
				<x path="Int"/>
				<c path="js.html.Range"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</getRangeAt>
		<addRange public="1" set="method">
			<f a="range">
				<c path="js.html.Range"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</addRange>
		<removeRange public="1" set="method">
			<f a="range">
				<c path="js.html.Range"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</removeRange>
		<removeAllRanges public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</removeAllRanges>
		<containsNode public="1" set="method">
			<f a="node:allowPartialContainment">
				<c path="js.html.Node"/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</containsNode>
		<modify public="1" set="method">
			<f a="alter:direction:granularity">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</modify>
		<meta><m n=":native"><e>"Selection"</e></m></meta>
	</class>
	<abstract path="js.html.SelectionMode" params="" file="C:\HaxeToolkit\haxe\std/js/html/SelectionMode.hx">
		<this><c path="String"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="js.html._SelectionMode.SelectionMode_Impl_" params="" file="C:\HaxeToolkit\haxe\std/js/html/SelectionMode.hx" private="1" module="js.html.SelectionMode"><meta>
	<m n=":keep"/>
	<m n=":enum"/>
</meta></class></impl>
	</abstract>
	<abstract path="js.html.SessionType" params="" file="C:\HaxeToolkit\haxe\std/js/html/SessionType.hx">
		<this><c path="String"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="js.html._SessionType.SessionType_Impl_" params="" file="C:\HaxeToolkit\haxe\std/js/html/SessionType.hx" private="1" module="js.html.SessionType"><meta>
	<m n=":keep"/>
	<m n=":enum"/>
</meta></class></impl>
	</abstract>
	<class path="js.html.ShadowElement" params="" file="C:\HaxeToolkit\haxe\std/js/html/ShadowElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<olderShadowRoot public="1" set="null"><c path="js.html.ShadowRoot"/></olderShadowRoot>
		<meta><m n=":native"><e>"HTMLShadowElement"</e></m></meta>
	</class>
	<class path="js.html.ShadowRoot" params="" file="C:\HaxeToolkit\haxe\std/js/html/ShadowRoot.hx" extern="1">
		<extends path="js.html.DocumentFragment"/>
		<innerHTML public="1"><c path="String"/></innerHTML>
		<host public="1" set="null"><c path="js.html.Element"/></host>
		<olderShadowRoot public="1" set="null"><c path="js.html.ShadowRoot"/></olderShadowRoot>
		<applyAuthorStyles public="1"><x path="Bool"/></applyAuthorStyles>
		<styleSheets public="1" set="null"><c path="js.html.StyleSheetList"/></styleSheets>
		<getElementsByTagName public="1" set="method"><f a="localName">
	<c path="String"/>
	<c path="js.html.HTMLCollection"/>
</f></getElementsByTagName>
		<getElementsByTagNameNS public="1" set="method"><f a="namespace_:localName">
	<c path="String"/>
	<c path="String"/>
	<c path="js.html.HTMLCollection"/>
</f></getElementsByTagNameNS>
		<getElementsByClassName public="1" set="method"><f a="classNames">
	<c path="String"/>
	<c path="js.html.HTMLCollection"/>
</f></getElementsByClassName>
		<meta><m n=":native"><e>"ShadowRoot"</e></m></meta>
	</class>
	<class path="js.html.SourceElement" params="" file="C:\HaxeToolkit\haxe\std/js/html/SourceElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<src public="1"><c path="String"/></src>
		<type public="1"><c path="String"/></type>
		<srcset public="1"><c path="String"/></srcset>
		<sizes public="1"><c path="String"/></sizes>
		<media public="1"><c path="String"/></media>
		<meta><m n=":native"><e>"HTMLSourceElement"</e></m></meta>
	</class>
	<class path="js.html.SpanElement" params="" file="C:\HaxeToolkit\haxe\std/js/html/SpanElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<meta><m n=":native"><e>"HTMLSpanElement"</e></m></meta>
	</class>
	<class path="js.html.SpeechSynthesis" params="" file="C:\HaxeToolkit\haxe\std/js/html/SpeechSynthesis.hx" extern="1">
		<pending public="1" set="null"><x path="Bool"/></pending>
		<speaking public="1" set="null"><x path="Bool"/></speaking>
		<paused public="1" set="null"><x path="Bool"/></paused>
		<speak public="1" set="method"><f a="utterance">
	<c path="js.html.SpeechSynthesisUtterance"/>
	<x path="Void"/>
</f></speak>
		<cancel public="1" set="method"><f a=""><x path="Void"/></f></cancel>
		<pause public="1" set="method"><f a=""><x path="Void"/></f></pause>
		<resume public="1" set="method"><f a=""><x path="Void"/></f></resume>
		<getVoices public="1" set="method"><f a=""><c path="Array"><c path="js.html.SpeechSynthesisVoice"/></c></f></getVoices>
		<meta><m n=":native"><e>"SpeechSynthesis"</e></m></meta>
	</class>
	<class path="js.html.SpeechSynthesisUtterance" params="" file="C:\HaxeToolkit\haxe\std/js/html/SpeechSynthesisUtterance.hx" extern="1">
		<extends path="js.html.EventTarget"/>
		<text public="1"><c path="String"/></text>
		<lang public="1"><c path="String"/></lang>
		<voice public="1"><c path="js.html.SpeechSynthesisVoice"/></voice>
		<volume public="1"><x path="Float"/></volume>
		<rate public="1"><x path="Float"/></rate>
		<pitch public="1"><x path="Float"/></pitch>
		<onstart public="1"><x path="haxe.Function"/></onstart>
		<onend public="1"><x path="haxe.Function"/></onend>
		<onerror public="1"><x path="haxe.Function"/></onerror>
		<onpause public="1"><x path="haxe.Function"/></onpause>
		<onresume public="1"><x path="haxe.Function"/></onresume>
		<onmark public="1"><x path="haxe.Function"/></onmark>
		<onboundary public="1"><x path="haxe.Function"/></onboundary>
		<new public="1" set="method">
			<f a="text">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
			<overloads><new public="1" set="method">
	<f a=""><x path="Void"/></f>
	<haxe_doc>@throws DOMError</haxe_doc>
</new></overloads>
		</new>
		<meta><m n=":native"><e>"SpeechSynthesisUtterance"</e></m></meta>
	</class>
	<class path="js.html.SpeechSynthesisVoice" params="" file="C:\HaxeToolkit\haxe\std/js/html/SpeechSynthesisVoice.hx" extern="1">
		<voiceURI public="1" set="null"><c path="String"/></voiceURI>
		<name public="1" set="null"><c path="String"/></name>
		<lang public="1" set="null"><c path="String"/></lang>
		<localService public="1" set="null"><x path="Bool"/></localService>
		<default_ public="1" set="null">
			<x path="Bool"/>
			<meta><m n=":native"><e>"default"</e></m></meta>
		</default_>
		<meta><m n=":native"><e>"SpeechSynthesisVoice"</e></m></meta>
	</class>
	<class path="js.html.Storage" params="" file="C:\HaxeToolkit\haxe\std/js/html/Storage.hx" extern="1">
		<length public="1" set="null"><x path="Int"/></length>
		<key public="1" set="method">
			<f a="index">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</key>
		<getItem public="1" set="method">
			<f a="key">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</getItem>
		<setItem public="1" set="method">
			<f a="key:value">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</setItem>
		<removeItem public="1" set="method">
			<f a="key">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</removeItem>
		<clear public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</clear>
		<meta><m n=":native"><e>"Storage"</e></m></meta>
	</class>
	<class path="js.html.StyleElement" params="" file="C:\HaxeToolkit\haxe\std/js/html/StyleElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<disabled public="1"><x path="Bool"/></disabled>
		<media public="1"><c path="String"/></media>
		<type public="1"><c path="String"/></type>
		<scoped public="1"><x path="Bool"/></scoped>
		<sheet public="1" set="null"><c path="js.html.StyleSheet"/></sheet>
		<meta><m n=":native"><e>"HTMLStyleElement"</e></m></meta>
	</class>
	<class path="js.html.StyleSheetList" params="" file="C:\HaxeToolkit\haxe\std/js/html/StyleSheetList.hx" extern="1">
		<length public="1" set="null"><x path="Int"/></length>
		<item public="1" set="method"><f a="index">
	<x path="Int"/>
	<c path="js.html.StyleSheet"/>
</f></item>
		<meta><m n=":native"><e>"StyleSheetList"</e></m></meta>
	</class>
	<class path="js.html.TableCaptionElement" params="" file="C:\HaxeToolkit\haxe\std/js/html/TableCaptionElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<align public="1"><c path="String"/></align>
		<meta><m n=":native"><e>"HTMLTableCaptionElement"</e></m></meta>
	</class>
	<class path="js.html.TableCellElement" params="" file="C:\HaxeToolkit\haxe\std/js/html/TableCellElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<colSpan public="1"><x path="Int"/></colSpan>
		<rowSpan public="1"><x path="Int"/></rowSpan>
		<headers public="1"><c path="String"/></headers>
		<cellIndex public="1" set="null"><x path="Int"/></cellIndex>
		<abbr public="1"><c path="String"/></abbr>
		<scope public="1"><c path="String"/></scope>
		<align public="1"><c path="String"/></align>
		<axis public="1"><c path="String"/></axis>
		<height public="1"><c path="String"/></height>
		<width public="1"><c path="String"/></width>
		<ch public="1"><c path="String"/></ch>
		<chOff public="1"><c path="String"/></chOff>
		<noWrap public="1"><x path="Bool"/></noWrap>
		<vAlign public="1"><c path="String"/></vAlign>
		<bgColor public="1"><c path="String"/></bgColor>
		<meta><m n=":native"><e>"HTMLTableCellElement"</e></m></meta>
	</class>
	<class path="js.html.TableColElement" params="" file="C:\HaxeToolkit\haxe\std/js/html/TableColElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<span public="1"><x path="Int"/></span>
		<align public="1"><c path="String"/></align>
		<ch public="1"><c path="String"/></ch>
		<chOff public="1"><c path="String"/></chOff>
		<vAlign public="1"><c path="String"/></vAlign>
		<width public="1"><c path="String"/></width>
		<meta><m n=":native"><e>"HTMLTableColElement"</e></m></meta>
	</class>
	<class path="js.html.TableElement" params="" file="C:\HaxeToolkit\haxe\std/js/html/TableElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<caption public="1"><c path="js.html.TableCaptionElement"/></caption>
		<tHead public="1"><c path="js.html.TableSectionElement"/></tHead>
		<tFoot public="1"><c path="js.html.TableSectionElement"/></tFoot>
		<tBodies public="1" set="null"><c path="js.html.HTMLCollection"/></tBodies>
		<rows public="1" set="null"><c path="js.html.HTMLCollection"/></rows>
		<align public="1"><c path="String"/></align>
		<border public="1"><c path="String"/></border>
		<frame public="1"><c path="String"/></frame>
		<rules public="1"><c path="String"/></rules>
		<summary public="1"><c path="String"/></summary>
		<width public="1"><c path="String"/></width>
		<bgColor public="1"><c path="String"/></bgColor>
		<cellPadding public="1"><c path="String"/></cellPadding>
		<cellSpacing public="1"><c path="String"/></cellSpacing>
		<createCaption public="1" set="method"><f a=""><c path="js.html.Element"/></f></createCaption>
		<deleteCaption public="1" set="method"><f a=""><x path="Void"/></f></deleteCaption>
		<createTHead public="1" set="method"><f a=""><c path="js.html.Element"/></f></createTHead>
		<deleteTHead public="1" set="method"><f a=""><x path="Void"/></f></deleteTHead>
		<createTFoot public="1" set="method"><f a=""><c path="js.html.Element"/></f></createTFoot>
		<deleteTFoot public="1" set="method"><f a=""><x path="Void"/></f></deleteTFoot>
		<createTBody public="1" set="method"><f a=""><c path="js.html.Element"/></f></createTBody>
		<insertRow public="1" set="method">
			<f a="?index" v="-1">
				<x path="Int"/>
				<c path="js.html.Element"/>
			</f>
			<meta><m n=":value"><e>{index:-1}</e></m></meta>
			<haxe_doc>@throws DOMError</haxe_doc>
		</insertRow>
		<deleteRow public="1" set="method">
			<f a="index">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</deleteRow>
		<meta><m n=":native"><e>"HTMLTableElement"</e></m></meta>
	</class>
	<class path="js.html.TableRowElement" params="" file="C:\HaxeToolkit\haxe\std/js/html/TableRowElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<rowIndex public="1" set="null"><x path="Int"/></rowIndex>
		<sectionRowIndex public="1" set="null"><x path="Int"/></sectionRowIndex>
		<cells public="1" set="null"><c path="js.html.HTMLCollection"/></cells>
		<align public="1"><c path="String"/></align>
		<ch public="1"><c path="String"/></ch>
		<chOff public="1"><c path="String"/></chOff>
		<vAlign public="1"><c path="String"/></vAlign>
		<bgColor public="1"><c path="String"/></bgColor>
		<insertCell public="1" set="method">
			<f a="?index" v="-1">
				<x path="Int"/>
				<c path="js.html.Element"/>
			</f>
			<meta><m n=":value"><e>{index:-1}</e></m></meta>
			<haxe_doc>@throws DOMError</haxe_doc>
		</insertCell>
		<deleteCell public="1" set="method">
			<f a="index">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</deleteCell>
		<meta><m n=":native"><e>"HTMLTableRowElement"</e></m></meta>
	</class>
	<class path="js.html.TableSectionElement" params="" file="C:\HaxeToolkit\haxe\std/js/html/TableSectionElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<rows public="1" set="null"><c path="js.html.HTMLCollection"/></rows>
		<align public="1"><c path="String"/></align>
		<ch public="1"><c path="String"/></ch>
		<chOff public="1"><c path="String"/></chOff>
		<vAlign public="1"><c path="String"/></vAlign>
		<insertRow public="1" set="method">
			<f a="?index" v="-1">
				<x path="Int"/>
				<c path="js.html.Element"/>
			</f>
			<meta><m n=":value"><e>{index:-1}</e></m></meta>
			<haxe_doc>@throws DOMError</haxe_doc>
		</insertRow>
		<deleteRow public="1" set="method">
			<f a="index">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</deleteRow>
		<meta><m n=":native"><e>"HTMLTableSectionElement"</e></m></meta>
	</class>
	<class path="js.html.TextAreaElement" params="" file="C:\HaxeToolkit\haxe\std/js/html/TextAreaElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<autofocus public="1"><x path="Bool"/></autofocus>
		<cols public="1"><x path="Int"/></cols>
		<disabled public="1"><x path="Bool"/></disabled>
		<form public="1" set="null"><c path="js.html.FormElement"/></form>
		<maxLength public="1"><x path="Int"/></maxLength>
		<name public="1"><c path="String"/></name>
		<placeholder public="1"><c path="String"/></placeholder>
		<readOnly public="1"><x path="Bool"/></readOnly>
		<required public="1"><x path="Bool"/></required>
		<rows public="1"><x path="Int"/></rows>
		<wrap public="1"><c path="String"/></wrap>
		<type public="1" set="null"><c path="String"/></type>
		<defaultValue public="1"><c path="String"/></defaultValue>
		<value public="1"><c path="String"/></value>
		<textLength public="1" set="null"><x path="Int"/></textLength>
		<willValidate public="1" set="null"><x path="Bool"/></willValidate>
		<validity public="1" set="null"><c path="js.html.ValidityState"/></validity>
		<validationMessage public="1" set="null"><c path="String"/></validationMessage>
		<selectionStart public="1"><x path="Int"/></selectionStart>
		<selectionEnd public="1"><x path="Int"/></selectionEnd>
		<selectionDirection public="1"><c path="String"/></selectionDirection>
		<checkValidity public="1" set="method"><f a=""><x path="Bool"/></f></checkValidity>
		<setCustomValidity public="1" set="method"><f a="error">
	<c path="String"/>
	<x path="Void"/>
</f></setCustomValidity>
		<select public="1" set="method"><f a=""><x path="Void"/></f></select>
		<setRangeText public="1" set="method">
			<f a="replacement:start:end:?selectionMode" v=":::&quot;preserve&quot;">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="js.html.SelectionMode"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{selectionMode:"preserve"}</e></m></meta>
			<haxe_doc>@throws DOMError</haxe_doc>
			<overloads><setRangeText public="1" set="method">
	<f a="replacement">
		<c path="String"/>
		<x path="Void"/>
	</f>
	<haxe_doc>@throws DOMError</haxe_doc>
</setRangeText></overloads>
		</setRangeText>
		<setSelectionRange public="1" set="method">
			<f a="start:end:?direction">
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</setSelectionRange>
		<meta><m n=":native"><e>"HTMLTextAreaElement"</e></m></meta>
	</class>
	<class path="js.html.TextMetrics" params="" file="C:\HaxeToolkit\haxe\std/js/html/TextMetrics.hx" extern="1">
		<width public="1" set="null"><x path="Float"/></width>
		<meta><m n=":native"><e>"TextMetrics"</e></m></meta>
	</class>
	<class path="js.html.TextTrack" params="" file="C:\HaxeToolkit\haxe\std/js/html/TextTrack.hx" extern="1">
		<extends path="js.html.EventTarget"/>
		<kind public="1" set="null"><x path="js.html.TextTrackKind"/></kind>
		<label public="1" set="null"><c path="String"/></label>
		<language public="1" set="null"><c path="String"/></language>
		<id public="1" set="null"><c path="String"/></id>
		<inBandMetadataTrackDispatchType public="1" set="null"><c path="String"/></inBandMetadataTrackDispatchType>
		<mode public="1"><x path="js.html.TextTrackMode"/></mode>
		<cues public="1" set="null"><c path="js.html.TextTrackCueList"/></cues>
		<activeCues public="1" set="null"><c path="js.html.TextTrackCueList"/></activeCues>
		<addCue public="1" set="method"><f a="cue">
	<c path="js.html.VTTCue"/>
	<x path="Void"/>
</f></addCue>
		<removeCue public="1" set="method">
			<f a="cue">
				<c path="js.html.VTTCue"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</removeCue>
		<meta><m n=":native"><e>"TextTrack"</e></m></meta>
	</class>
	<class path="js.html.TextTrackCueList" params="" file="C:\HaxeToolkit\haxe\std/js/html/TextTrackCueList.hx" extern="1">
		<length public="1" set="null"><x path="Int"/></length>
		<getCueById public="1" set="method"><f a="id">
	<c path="String"/>
	<c path="js.html.VTTCue"/>
</f></getCueById>
		<meta><m n=":native"><e>"TextTrackCueList"</e></m></meta>
	</class>
	<abstract path="js.html.TextTrackKind" params="" file="C:\HaxeToolkit\haxe\std/js/html/TextTrackKind.hx">
		<this><c path="String"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="js.html._TextTrackKind.TextTrackKind_Impl_" params="" file="C:\HaxeToolkit\haxe\std/js/html/TextTrackKind.hx" private="1" module="js.html.TextTrackKind"><meta>
	<m n=":keep"/>
	<m n=":enum"/>
</meta></class></impl>
	</abstract>
	<class path="js.html.TextTrackList" params="" file="C:\HaxeToolkit\haxe\std/js/html/TextTrackList.hx" extern="1">
		<extends path="js.html.EventTarget"/>
		<length public="1" set="null"><x path="Int"/></length>
		<onchange public="1"><x path="haxe.Function"/></onchange>
		<onaddtrack public="1"><x path="haxe.Function"/></onaddtrack>
		<onremovetrack public="1"><x path="haxe.Function"/></onremovetrack>
		<getTrackById public="1" set="method"><f a="id">
	<c path="String"/>
	<c path="js.html.TextTrack"/>
</f></getTrackById>
		<meta><m n=":native"><e>"TextTrackList"</e></m></meta>
	</class>
	<abstract path="js.html.TextTrackMode" params="" file="C:\HaxeToolkit\haxe\std/js/html/TextTrackMode.hx">
		<this><c path="String"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="js.html._TextTrackMode.TextTrackMode_Impl_" params="" file="C:\HaxeToolkit\haxe\std/js/html/TextTrackMode.hx" private="1" module="js.html.TextTrackMode"><meta>
	<m n=":keep"/>
	<m n=":enum"/>
</meta></class></impl>
	</abstract>
	<class path="js.html.TimeRanges" params="" file="C:\HaxeToolkit\haxe\std/js/html/TimeRanges.hx" extern="1">
		<length public="1" set="null"><x path="Int"/></length>
		<start public="1" set="method">
			<f a="index">
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</start>
		<end public="1" set="method">
			<f a="index">
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</end>
		<meta><m n=":native"><e>"TimeRanges"</e></m></meta>
	</class>
	<class path="js.html.TitleElement" params="" file="C:\HaxeToolkit\haxe\std/js/html/TitleElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<text public="1"><c path="String"/></text>
		<meta><m n=":native"><e>"HTMLTitleElement"</e></m></meta>
	</class>
	<class path="js.html.Touch" params="" file="C:\HaxeToolkit\haxe\std/js/html/Touch.hx" extern="1">
		<identifier public="1" set="null"><x path="Int"/></identifier>
		<target public="1" set="null"><c path="js.html.EventTarget"/></target>
		<screenX public="1" set="null"><x path="Int"/></screenX>
		<screenY public="1" set="null"><x path="Int"/></screenY>
		<clientX public="1" set="null"><x path="Int"/></clientX>
		<clientY public="1" set="null"><x path="Int"/></clientY>
		<pageX public="1" set="null"><x path="Int"/></pageX>
		<pageY public="1" set="null"><x path="Int"/></pageY>
		<radiusX public="1" set="null"><x path="Int"/></radiusX>
		<radiusY public="1" set="null"><x path="Int"/></radiusY>
		<rotationAngle public="1" set="null"><x path="Float"/></rotationAngle>
		<force public="1" set="null"><x path="Float"/></force>
		<meta><m n=":native"><e>"Touch"</e></m></meta>
	</class>
	<class path="js.html.TouchList" params="" file="C:\HaxeToolkit\haxe\std/js/html/TouchList.hx" extern="1">
		<length public="1" set="null"><x path="Int"/></length>
		<item public="1" set="method"><f a="index">
	<x path="Int"/>
	<c path="js.html.Touch"/>
</f></item>
		<identifiedTouch public="1" set="method"><f a="identifier">
	<x path="Int"/>
	<c path="js.html.Touch"/>
</f></identifiedTouch>
		<meta><m n=":native"><e>"TouchList"</e></m></meta>
	</class>
	<class path="js.html.TrackElement" params="" file="C:\HaxeToolkit\haxe\std/js/html/TrackElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<NONE public="1" get="inline" set="null" expr="0" line="30" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</NONE>
		<LOADING public="1" get="inline" set="null" expr="1" line="31" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</LOADING>
		<LOADED public="1" get="inline" set="null" expr="2" line="32" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2</e></m></meta>
		</LOADED>
		<ERROR public="1" get="inline" set="null" expr="3" line="33" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3</e></m></meta>
		</ERROR>
		<kind public="1"><c path="String"/></kind>
		<src public="1"><c path="String"/></src>
		<srclang public="1"><c path="String"/></srclang>
		<label public="1"><c path="String"/></label>
		<default_ public="1">
			<x path="Bool"/>
			<meta><m n=":native"><e>"default"</e></m></meta>
		</default_>
		<readyState public="1" set="null"><x path="Int"/></readyState>
		<track public="1" set="null"><c path="js.html.TextTrack"/></track>
		<meta><m n=":native"><e>"HTMLTrackElement"</e></m></meta>
	</class>
	<class path="js.html.TreeWalker" params="" file="C:\HaxeToolkit\haxe\std/js/html/TreeWalker.hx" extern="1">
		<root public="1" set="null"><c path="js.html.Node"/></root>
		<whatToShow public="1" set="null"><x path="Int"/></whatToShow>
		<filter public="1" set="null"><c path="js.html.NodeFilter"/></filter>
		<currentNode public="1"><c path="js.html.Node"/></currentNode>
		<parentNode public="1" set="method">
			<f a=""><c path="js.html.Node"/></f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</parentNode>
		<firstChild public="1" set="method">
			<f a=""><c path="js.html.Node"/></f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</firstChild>
		<lastChild public="1" set="method">
			<f a=""><c path="js.html.Node"/></f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</lastChild>
		<previousSibling public="1" set="method">
			<f a=""><c path="js.html.Node"/></f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</previousSibling>
		<nextSibling public="1" set="method">
			<f a=""><c path="js.html.Node"/></f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</nextSibling>
		<previousNode public="1" set="method">
			<f a=""><c path="js.html.Node"/></f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</previousNode>
		<nextNode public="1" set="method">
			<f a=""><c path="js.html.Node"/></f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</nextNode>
		<meta><m n=":native"><e>"TreeWalker"</e></m></meta>
	</class>
	<typedef path="js.html.UIEventInit" params="" file="C:\HaxeToolkit\haxe\std/js/html/UIEventInit.hx"><a>
	<view>
		<t path="Null"><c path="js.html.Window"/></t>
		<meta><m n=":optional"/></meta>
	</view>
	<detail>
		<t path="Null"><x path="Int"/></t>
		<meta><m n=":optional"/></meta>
	</detail>
	<cancelable>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</cancelable>
	<bubbles>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</bubbles>
</a></typedef>
	<class path="js.html.UListElement" params="" file="C:\HaxeToolkit\haxe\std/js/html/UListElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<compact public="1"><x path="Bool"/></compact>
		<type public="1"><c path="String"/></type>
		<meta><m n=":native"><e>"HTMLUListElement"</e></m></meta>
	</class>
	<class path="js.html.URLSearchParams" params="" file="C:\HaxeToolkit\haxe\std/js/html/URLSearchParams.hx" extern="1">
		<append public="1" set="method"><f a="name:value">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></append>
		<delete_ public="1" set="method">
			<f a="name">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":native"><e>"delete"</e></m></meta>
		</delete_>
		<get public="1" set="method"><f a="name">
	<c path="String"/>
	<c path="String"/>
</f></get>
		<getAll public="1" set="method"><f a="name">
	<c path="String"/>
	<c path="Array"><c path="String"/></c>
</f></getAll>
		<has public="1" set="method"><f a="name">
	<c path="String"/>
	<x path="Bool"/>
</f></has>
		<set public="1" set="method"><f a="name:value">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></set>
		<new public="1" set="method">
			<f a="init">
				<c path="js.html.URLSearchParams"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
			<overloads><new public="1" set="method">
	<f a="?init" v="&quot;&quot;">
		<c path="String"/>
		<x path="Void"/>
	</f>
	<meta><m n=":value"><e>{init:""}</e></m></meta>
	<haxe_doc>@throws DOMError</haxe_doc>
</new></overloads>
		</new>
		<meta><m n=":native"><e>"URLSearchParams"</e></m></meta>
	</class>
	<class path="js.html.Uint8Array" params="" file="C:\HaxeToolkit\haxe\std/js/html/Uint8Array.hx" extern="1">
		<extends path="js.html.ArrayBufferView"/>
		<BYTES_PER_ELEMENT public="1" get="inline" set="null" expr="1" line="30" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</BYTES_PER_ELEMENT>
		<length public="1" set="null"><x path="Int"/></length>
		<get public="1" set="method"><f a="index">
	<x path="Int"/>
	<x path="Int"/>
</f></get>
		<set public="1" set="method">
			<f a="array:?offset">
				<c path="Array"><x path="Int"/></c>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<overloads>
				<set public="1" set="method"><f a="index:value">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></set>
				<set public="1" set="method"><f a="array:?offset">
	<c path="js.html.Uint8Array"/>
	<x path="Int"/>
	<x path="Void"/>
</f></set>
			</overloads>
		</set>
		<subarray public="1" set="method"><f a="start:end">
	<x path="Int"/>
	<x path="Int"/>
	<c path="js.html.Uint8Array"/>
</f></subarray>
		<new public="1" set="method">
			<f a="buffer:?byteOffset:?length">
				<c path="js.html.ArrayBuffer"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
			<overloads>
				<new public="1" set="method">
					<f a="length">
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>@throws DOMError</haxe_doc>
				</new>
				<new public="1" set="method">
					<f a="array">
						<c path="js.html.Uint8Array"/>
						<x path="Void"/>
					</f>
					<haxe_doc>@throws DOMError</haxe_doc>
				</new>
				<new public="1" set="method">
					<f a="array">
						<c path="Array"><x path="Int"/></c>
						<x path="Void"/>
					</f>
					<haxe_doc>@throws DOMError</haxe_doc>
				</new>
			</overloads>
		</new>
		<meta><m n=":native"><e>"Uint8Array"</e></m></meta>
	</class>
	<class path="js.html.Uint8ClampedArray" params="" file="C:\HaxeToolkit\haxe\std/js/html/Uint8ClampedArray.hx" extern="1">
		<extends path="js.html.ArrayBufferView"/>
		<BYTES_PER_ELEMENT public="1" get="inline" set="null" expr="1" line="30" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</BYTES_PER_ELEMENT>
		<length public="1" set="null"><x path="Int"/></length>
		<get public="1" set="method"><f a="index">
	<x path="Int"/>
	<x path="Int"/>
</f></get>
		<set public="1" set="method">
			<f a="array:?offset">
				<c path="Array"><x path="Int"/></c>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<overloads>
				<set public="1" set="method"><f a="index:value">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></set>
				<set public="1" set="method"><f a="array:?offset">
	<c path="js.html.Uint8ClampedArray"/>
	<x path="Int"/>
	<x path="Void"/>
</f></set>
			</overloads>
		</set>
		<subarray public="1" set="method"><f a="start:end">
	<x path="Int"/>
	<x path="Int"/>
	<c path="js.html.Uint8ClampedArray"/>
</f></subarray>
		<new public="1" set="method">
			<f a="buffer:?byteOffset:?length">
				<c path="js.html.ArrayBuffer"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
			<overloads>
				<new public="1" set="method">
					<f a="length">
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>@throws DOMError</haxe_doc>
				</new>
				<new public="1" set="method">
					<f a="array">
						<c path="js.html.Uint8ClampedArray"/>
						<x path="Void"/>
					</f>
					<haxe_doc>@throws DOMError</haxe_doc>
				</new>
				<new public="1" set="method">
					<f a="array">
						<c path="Array"><x path="Int"/></c>
						<x path="Void"/>
					</f>
					<haxe_doc>@throws DOMError</haxe_doc>
				</new>
			</overloads>
		</new>
		<meta><m n=":native"><e>"Uint8ClampedArray"</e></m></meta>
	</class>
	<class path="js.html.VTTCue" params="" file="C:\HaxeToolkit\haxe\std/js/html/VTTCue.hx" extern="1">
		<extends path="js.html.EventTarget"/>
		<track public="1" set="null"><c path="js.html.TextTrack"/></track>
		<id public="1"><c path="String"/></id>
		<startTime public="1"><x path="Float"/></startTime>
		<endTime public="1"><x path="Float"/></endTime>
		<pauseOnExit public="1"><x path="Bool"/></pauseOnExit>
		<region public="1"><c path="js.html.VTTRegion"/></region>
		<vertical public="1"><x path="js.html.DirectionSetting"/></vertical>
		<snapToLines public="1"><x path="Bool"/></snapToLines>
		<line public="1"><x path="haxe.extern.EitherType">
	<x path="Int"/>
	<d/>
</x></line>
		<lineAlign public="1"><x path="js.html.AlignSetting"/></lineAlign>
		<position public="1"><x path="Int"/></position>
		<positionAlign public="1"><x path="js.html.AlignSetting"/></positionAlign>
		<size public="1"><x path="Int"/></size>
		<align public="1"><x path="js.html.AlignSetting"/></align>
		<text public="1"><c path="String"/></text>
		<onenter public="1"><x path="haxe.Function"/></onenter>
		<onexit public="1"><x path="haxe.Function"/></onexit>
		<getCueAsHTML public="1" set="method"><f a=""><c path="js.html.DocumentFragment"/></f></getCueAsHTML>
		<new public="1" set="method">
			<f a="startTime:endTime:text">
				<x path="Float"/>
				<x path="Float"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</new>
		<meta><m n=":native"><e>"VTTCue"</e></m></meta>
	</class>
	<class path="js.html.VTTRegion" params="" file="C:\HaxeToolkit\haxe\std/js/html/VTTRegion.hx" extern="1">
		<width public="1"><x path="Float"/></width>
		<lines public="1"><x path="Int"/></lines>
		<regionAnchorX public="1"><x path="Float"/></regionAnchorX>
		<regionAnchorY public="1"><x path="Float"/></regionAnchorY>
		<viewportAnchorX public="1"><x path="Float"/></viewportAnchorX>
		<viewportAnchorY public="1"><x path="Float"/></viewportAnchorY>
		<scroll public="1"><c path="String"/></scroll>
		<new public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</new>
		<meta><m n=":native"><e>"VTTRegion"</e></m></meta>
	</class>
	<class path="js.html.ValidityState" params="" file="C:\HaxeToolkit\haxe\std/js/html/ValidityState.hx" extern="1">
		<valueMissing public="1" set="null"><x path="Bool"/></valueMissing>
		<typeMismatch public="1" set="null"><x path="Bool"/></typeMismatch>
		<patternMismatch public="1" set="null"><x path="Bool"/></patternMismatch>
		<tooLong public="1" set="null"><x path="Bool"/></tooLong>
		<rangeUnderflow public="1" set="null"><x path="Bool"/></rangeUnderflow>
		<rangeOverflow public="1" set="null"><x path="Bool"/></rangeOverflow>
		<stepMismatch public="1" set="null"><x path="Bool"/></stepMismatch>
		<badInput public="1" set="null"><x path="Bool"/></badInput>
		<customError public="1" set="null"><x path="Bool"/></customError>
		<valid public="1" set="null"><x path="Bool"/></valid>
		<meta><m n=":native"><e>"ValidityState"</e></m></meta>
	</class>
	<class path="js.html.VideoElement" params="" file="C:\HaxeToolkit\haxe\std/js/html/VideoElement.hx" extern="1">
		<extends path="js.html.MediaElement"/>
		<width public="1"><x path="Int"/></width>
		<height public="1"><x path="Int"/></height>
		<videoWidth public="1" set="null"><x path="Int"/></videoWidth>
		<videoHeight public="1" set="null"><x path="Int"/></videoHeight>
		<poster public="1"><c path="String"/></poster>
		<getVideoPlaybackQuality public="1" set="method"><f a=""><c path="js.html.VideoPlaybackQuality"/></f></getVideoPlaybackQuality>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":native"><e>"HTMLVideoElement"</e></m>
		</meta>
	</class>
	<class path="js.html.VideoPlaybackQuality" params="" file="C:\HaxeToolkit\haxe\std/js/html/VideoPlaybackQuality.hx" extern="1">
		<creationTime public="1" set="null"><x path="Float"/></creationTime>
		<totalVideoFrames public="1" set="null"><x path="Int"/></totalVideoFrames>
		<droppedVideoFrames public="1" set="null"><x path="Int"/></droppedVideoFrames>
		<corruptedVideoFrames public="1" set="null"><x path="Int"/></corruptedVideoFrames>
		<meta><m n=":native"><e>"VideoPlaybackQuality"</e></m></meta>
	</class>
	<class path="js.html.VideoStreamTrack" params="" file="C:\HaxeToolkit\haxe\std/js/html/VideoStreamTrack.hx" extern="1">
		<extends path="js.html.MediaStreamTrack"/>
		<meta><m n=":native"><e>"VideoStreamTrack"</e></m></meta>
	</class>
	<class path="js.html.VideoTrack" params="" file="C:\HaxeToolkit\haxe\std/js/html/VideoTrack.hx" extern="1">
		<id public="1" set="null"><c path="String"/></id>
		<kind public="1" set="null"><c path="String"/></kind>
		<label public="1" set="null"><c path="String"/></label>
		<language public="1" set="null"><c path="String"/></language>
		<selected public="1"><x path="Bool"/></selected>
		<meta><m n=":native"><e>"VideoTrack"</e></m></meta>
	</class>
	<class path="js.html.VideoTrackList" params="" file="C:\HaxeToolkit\haxe\std/js/html/VideoTrackList.hx" extern="1">
		<extends path="js.html.EventTarget"/>
		<length public="1" set="null"><x path="Int"/></length>
		<selectedIndex public="1" set="null"><x path="Int"/></selectedIndex>
		<onchange public="1"><x path="haxe.Function"/></onchange>
		<onaddtrack public="1"><x path="haxe.Function"/></onaddtrack>
		<onremovetrack public="1"><x path="haxe.Function"/></onremovetrack>
		<getTrackById public="1" set="method"><f a="id">
	<c path="String"/>
	<c path="js.html.VideoTrack"/>
</f></getTrackById>
		<meta><m n=":native"><e>"VideoTrackList"</e></m></meta>
	</class>
	<abstract path="js.html.VisibilityState" params="" file="C:\HaxeToolkit\haxe\std/js/html/VisibilityState.hx">
		<this><c path="String"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="js.html._VisibilityState.VisibilityState_Impl_" params="" file="C:\HaxeToolkit\haxe\std/js/html/VisibilityState.hx" private="1" module="js.html.VisibilityState"><meta>
	<m n=":keep"/>
	<m n=":enum"/>
</meta></class></impl>
	</abstract>
	<class path="js.html.Window" params="" file="C:\HaxeToolkit\haxe\std/js/html/Window.hx" extern="1">
		<extends path="js.html.EventTarget"/>
		<window public="1" set="null"><c path="js.html.Window"/></window>
		<self public="1" set="null"><c path="js.html.Window"/></self>
		<document public="1" set="null"><c path="js.html.HTMLDocument"/></document>
		<name public="1"><c path="String"/></name>
		<location public="1" set="null"><c path="js.html.Location"/></location>
		<history public="1" set="null"><c path="js.html.History"/></history>
		<locationbar public="1" set="null"><c path="js.html.BarProp"/></locationbar>
		<menubar public="1" set="null"><c path="js.html.BarProp"/></menubar>
		<personalbar public="1" set="null"><c path="js.html.BarProp"/></personalbar>
		<scrollbars public="1" set="null"><c path="js.html.BarProp"/></scrollbars>
		<statusbar public="1" set="null"><c path="js.html.BarProp"/></statusbar>
		<toolbar public="1" set="null"><c path="js.html.BarProp"/></toolbar>
		<status public="1"><c path="String"/></status>
		<closed public="1" set="null"><x path="Bool"/></closed>
		<frames public="1" set="null"><c path="js.html.Window"/></frames>
		<length public="1" set="null"><x path="Int"/></length>
		<top public="1" set="null"><c path="js.html.Window"/></top>
		<opener public="1"><d/></opener>
		<parent public="1" set="null"><c path="js.html.Window"/></parent>
		<frameElement public="1" set="null"><c path="js.html.Element"/></frameElement>
		<navigator public="1" set="null"><c path="js.html.Navigator"/></navigator>
		<applicationCache public="1" set="null"><c path="js.html.ApplicationCache"/></applicationCache>
		<orientation public="1" set="null"><x path="Int"/></orientation>
		<onorientationchange public="1"><x path="haxe.Function"/></onorientationchange>
		<screen public="1" set="null"><c path="js.html.Screen"/></screen>
		<innerWidth public="1"><x path="Int"/></innerWidth>
		<innerHeight public="1"><x path="Int"/></innerHeight>
		<scrollX public="1" set="null"><x path="Int"/></scrollX>
		<pageXOffset public="1" set="null"><x path="Int"/></pageXOffset>
		<scrollY public="1" set="null"><x path="Int"/></scrollY>
		<pageYOffset public="1" set="null"><x path="Int"/></pageYOffset>
		<screenX public="1"><x path="Int"/></screenX>
		<screenY public="1"><x path="Int"/></screenY>
		<outerWidth public="1"><x path="Int"/></outerWidth>
		<outerHeight public="1"><x path="Int"/></outerHeight>
		<performance public="1" set="null"><c path="js.html.Performance"/></performance>
		<crypto public="1" set="null"><d/></crypto>
		<devicePixelRatio public="1" set="null"><x path="Float"/></devicePixelRatio>
		<scrollMaxX public="1" set="null"><x path="Int"/></scrollMaxX>
		<scrollMaxY public="1" set="null"><x path="Int"/></scrollMaxY>
		<fullScreen public="1"><x path="Bool"/></fullScreen>
		<onwheel public="1"><x path="haxe.Function"/></onwheel>
		<ondevicemotion public="1"><x path="haxe.Function"/></ondevicemotion>
		<ondeviceorientation public="1"><x path="haxe.Function"/></ondeviceorientation>
		<ondeviceproximity public="1"><x path="haxe.Function"/></ondeviceproximity>
		<onuserproximity public="1"><x path="haxe.Function"/></onuserproximity>
		<ondevicelight public="1"><x path="haxe.Function"/></ondevicelight>
		<content public="1" set="null"><d/></content>
		<console public="1" set="null"><c path="js.html.Console"/></console>
		<onabort public="1"><x path="haxe.Function"/></onabort>
		<onblur public="1"><x path="haxe.Function"/></onblur>
		<onfocus public="1"><x path="haxe.Function"/></onfocus>
		<oncanplay public="1"><x path="haxe.Function"/></oncanplay>
		<oncanplaythrough public="1"><x path="haxe.Function"/></oncanplaythrough>
		<onchange public="1"><x path="haxe.Function"/></onchange>
		<onclick public="1"><x path="haxe.Function"/></onclick>
		<oncontextmenu public="1"><x path="haxe.Function"/></oncontextmenu>
		<ondblclick public="1"><x path="haxe.Function"/></ondblclick>
		<ondrag public="1"><x path="haxe.Function"/></ondrag>
		<ondragend public="1"><x path="haxe.Function"/></ondragend>
		<ondragenter public="1"><x path="haxe.Function"/></ondragenter>
		<ondragleave public="1"><x path="haxe.Function"/></ondragleave>
		<ondragover public="1"><x path="haxe.Function"/></ondragover>
		<ondragstart public="1"><x path="haxe.Function"/></ondragstart>
		<ondrop public="1"><x path="haxe.Function"/></ondrop>
		<ondurationchange public="1"><x path="haxe.Function"/></ondurationchange>
		<onemptied public="1"><x path="haxe.Function"/></onemptied>
		<onended public="1"><x path="haxe.Function"/></onended>
		<oninput public="1"><x path="haxe.Function"/></oninput>
		<oninvalid public="1"><x path="haxe.Function"/></oninvalid>
		<onkeydown public="1"><x path="haxe.Function"/></onkeydown>
		<onkeypress public="1"><x path="haxe.Function"/></onkeypress>
		<onkeyup public="1"><x path="haxe.Function"/></onkeyup>
		<onload public="1"><x path="haxe.Function"/></onload>
		<onloadeddata public="1"><x path="haxe.Function"/></onloadeddata>
		<onloadedmetadata public="1"><x path="haxe.Function"/></onloadedmetadata>
		<onloadstart public="1"><x path="haxe.Function"/></onloadstart>
		<onmousedown public="1"><x path="haxe.Function"/></onmousedown>
		<onmouseenter public="1"><x path="haxe.Function"/></onmouseenter>
		<onmouseleave public="1"><x path="haxe.Function"/></onmouseleave>
		<onmousemove public="1"><x path="haxe.Function"/></onmousemove>
		<onmouseout public="1"><x path="haxe.Function"/></onmouseout>
		<onmouseover public="1"><x path="haxe.Function"/></onmouseover>
		<onmouseup public="1"><x path="haxe.Function"/></onmouseup>
		<onpause public="1"><x path="haxe.Function"/></onpause>
		<onplay public="1"><x path="haxe.Function"/></onplay>
		<onplaying public="1"><x path="haxe.Function"/></onplaying>
		<onprogress public="1"><x path="haxe.Function"/></onprogress>
		<onratechange public="1"><x path="haxe.Function"/></onratechange>
		<onreset public="1"><x path="haxe.Function"/></onreset>
		<onscroll public="1"><x path="haxe.Function"/></onscroll>
		<onseeked public="1"><x path="haxe.Function"/></onseeked>
		<onseeking public="1"><x path="haxe.Function"/></onseeking>
		<onselect public="1"><x path="haxe.Function"/></onselect>
		<onshow public="1"><x path="haxe.Function"/></onshow>
		<onstalled public="1"><x path="haxe.Function"/></onstalled>
		<onsubmit public="1"><x path="haxe.Function"/></onsubmit>
		<onsuspend public="1"><x path="haxe.Function"/></onsuspend>
		<ontimeupdate public="1"><x path="haxe.Function"/></ontimeupdate>
		<onvolumechange public="1"><x path="haxe.Function"/></onvolumechange>
		<onwaiting public="1"><x path="haxe.Function"/></onwaiting>
		<onpointercancel public="1"><x path="haxe.Function"/></onpointercancel>
		<onpointerdown public="1"><x path="haxe.Function"/></onpointerdown>
		<onpointerup public="1"><x path="haxe.Function"/></onpointerup>
		<onpointermove public="1"><x path="haxe.Function"/></onpointermove>
		<onpointerout public="1"><x path="haxe.Function"/></onpointerout>
		<onpointerover public="1"><x path="haxe.Function"/></onpointerover>
		<onpointerenter public="1"><x path="haxe.Function"/></onpointerenter>
		<onpointerleave public="1"><x path="haxe.Function"/></onpointerleave>
		<ongotpointercapture public="1"><x path="haxe.Function"/></ongotpointercapture>
		<onlostpointercapture public="1"><x path="haxe.Function"/></onlostpointercapture>
		<onpointerlockchange public="1"><x path="haxe.Function"/></onpointerlockchange>
		<onpointerlockerror public="1"><x path="haxe.Function"/></onpointerlockerror>
		<indexedDB public="1" set="null"><c path="js.html.idb.Factory"/></indexedDB>
		<onerror public="1"><f a="::::">
	<x path="haxe.extern.EitherType">
		<c path="js.html.Event"/>
		<c path="String"/>
	</x>
	<c path="String"/>
	<x path="Int"/>
	<x path="Int"/>
	<d/>
	<x path="Bool"/>
</f></onerror>
		<speechSynthesis public="1" set="null"><c path="js.html.SpeechSynthesis"/></speechSynthesis>
		<ontouchstart public="1"><x path="haxe.Function"/></ontouchstart>
		<ontouchend public="1"><x path="haxe.Function"/></ontouchend>
		<ontouchmove public="1"><x path="haxe.Function"/></ontouchmove>
		<ontouchcancel public="1"><x path="haxe.Function"/></ontouchcancel>
		<onafterprint public="1"><x path="haxe.Function"/></onafterprint>
		<onbeforeprint public="1"><x path="haxe.Function"/></onbeforeprint>
		<onbeforeunload public="1"><f a="">
	<c path="js.html.Event"/>
	<c path="String"/>
</f></onbeforeunload>
		<onhashchange public="1"><x path="haxe.Function"/></onhashchange>
		<onlanguagechange public="1"><x path="haxe.Function"/></onlanguagechange>
		<onmessage public="1"><x path="haxe.Function"/></onmessage>
		<onoffline public="1"><x path="haxe.Function"/></onoffline>
		<ononline public="1"><x path="haxe.Function"/></ononline>
		<onpagehide public="1"><x path="haxe.Function"/></onpagehide>
		<onpageshow public="1"><x path="haxe.Function"/></onpageshow>
		<onpopstate public="1"><x path="haxe.Function"/></onpopstate>
		<onresize public="1"><x path="haxe.Function"/></onresize>
		<onunload public="1"><x path="haxe.Function"/></onunload>
		<localStorage public="1" set="null"><c path="js.html.Storage"/></localStorage>
		<sessionStorage public="1" set="null"><c path="js.html.Storage"/></sessionStorage>
		<close public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</close>
		<stop public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</stop>
		<focus public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</focus>
		<blur public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</blur>
		<open public="1" set="method">
			<f a="?url:?target:?features" v="&quot;&quot;:&quot;&quot;:&quot;&quot;">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<c path="js.html.Window"/>
			</f>
			<meta><m n=":value"><e>{features:"",target:"",url:""}</e></m></meta>
			<haxe_doc>@throws DOMError</haxe_doc>
		</open>
		<alert public="1" set="method">
			<f a="message">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
			<overloads><alert public="1" set="method">
	<f a=""><x path="Void"/></f>
	<haxe_doc>@throws DOMError</haxe_doc>
</alert></overloads>
		</alert>
		<confirm public="1" set="method">
			<f a="?message" v="&quot;&quot;">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>{message:""}</e></m></meta>
			<haxe_doc>@throws DOMError</haxe_doc>
		</confirm>
		<prompt public="1" set="method">
			<f a="?message:?default_" v="&quot;&quot;:&quot;&quot;">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta><m n=":value"><e>{default_:"",message:""}</e></m></meta>
			<haxe_doc>@throws DOMError</haxe_doc>
		</prompt>
		<print public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</print>
		<postMessage public="1" set="method">
			<f a="message:targetOrigin:?transfer">
				<d/>
				<c path="String"/>
				<c path="Array"><d/></c>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</postMessage>
		<captureEvents public="1" set="method"><f a=""><x path="Void"/></f></captureEvents>
		<releaseEvents public="1" set="method"><f a=""><x path="Void"/></f></releaseEvents>
		<getSelection public="1" set="method">
			<f a=""><c path="js.html.Selection"/></f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</getSelection>
		<getComputedStyle public="1" set="method">
			<f a="elt:?pseudoElt" v=":&quot;&quot;">
				<c path="js.html.Element"/>
				<c path="String"/>
				<c path="js.html.CSSStyleDeclaration"/>
			</f>
			<meta><m n=":value"><e>{pseudoElt:""}</e></m></meta>
			<haxe_doc>@throws DOMError</haxe_doc>
		</getComputedStyle>
		<matchMedia public="1" set="method">
			<f a="query">
				<c path="String"/>
				<c path="js.html.MediaQueryList"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</matchMedia>
		<moveTo public="1" set="method">
			<f a="x:y">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</moveTo>
		<moveBy public="1" set="method">
			<f a="x:y">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</moveBy>
		<resizeTo public="1" set="method">
			<f a="x:y">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</resizeTo>
		<resizeBy public="1" set="method">
			<f a="x:y">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</resizeBy>
		<scroll public="1" set="method">
			<f a="?options">
				<t path="js.html.ScrollToOptions"/>
				<x path="Void"/>
			</f>
			<overloads><scroll public="1" set="method"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></scroll></overloads>
		</scroll>
		<scrollTo public="1" set="method">
			<f a="?options">
				<t path="js.html.ScrollToOptions"/>
				<x path="Void"/>
			</f>
			<overloads><scrollTo public="1" set="method"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></scrollTo></overloads>
		</scrollTo>
		<scrollBy public="1" set="method">
			<f a="?options">
				<t path="js.html.ScrollToOptions"/>
				<x path="Void"/>
			</f>
			<overloads><scrollBy public="1" set="method"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></scrollBy></overloads>
		</scrollBy>
		<requestAnimationFrame public="1" set="method">
			<f a="callback">
				<f a="">
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Int"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</requestAnimationFrame>
		<cancelAnimationFrame public="1" set="method">
			<f a="handle">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</cancelAnimationFrame>
		<getDefaultComputedStyle public="1" set="method">
			<f a="elt:?pseudoElt" v=":&quot;&quot;">
				<c path="js.html.Element"/>
				<c path="String"/>
				<c path="js.html.CSSStyleDeclaration"/>
			</f>
			<meta><m n=":value"><e>{pseudoElt:""}</e></m></meta>
			<haxe_doc>@throws DOMError</haxe_doc>
		</getDefaultComputedStyle>
		<scrollByLines public="1" set="method"><f a="numLines:?options">
	<x path="Int"/>
	<t path="js.html.ScrollOptions"/>
	<x path="Void"/>
</f></scrollByLines>
		<scrollByPages public="1" set="method"><f a="numPages:?options">
	<x path="Int"/>
	<t path="js.html.ScrollOptions"/>
	<x path="Void"/>
</f></scrollByPages>
		<sizeToContent public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</sizeToContent>
		<updateCommands public="1" set="method">
			<f a="action:?sel:?reason" v="::0">
				<c path="String"/>
				<c path="js.html.Selection"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{reason:0}</e></m></meta>
		</updateCommands>
		<find public="1" set="method">
			<f a="?str:?caseSensitive:?backwards:?wrapAround:?wholeWord:?searchInFrames:?showDialog" v="&quot;&quot;:false:false:false:false:false:false">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>{showDialog:false,searchInFrames:false,wholeWord:false,wrapAround:false,backwards:false,caseSensitive:false,str:""}</e></m></meta>
			<haxe_doc>@throws DOMError</haxe_doc>
		</find>
		<dump public="1" set="method"><f a="str">
	<c path="String"/>
	<x path="Void"/>
</f></dump>
		<setResizable public="1" set="method"><f a="resizable">
	<x path="Bool"/>
	<x path="Void"/>
</f></setResizable>
		<btoa public="1" set="method">
			<f a="btoa">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</btoa>
		<atob public="1" set="method">
			<f a="atob">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</atob>
		<setTimeout public="1" set="method">
			<f a="handler:?timeout:unused" v=":0:">
				<c path="String"/>
				<x path="Int"/>
				<x path="haxe.extern.Rest"><d/></x>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>{timeout:0}</e></m></meta>
			<haxe_doc>@throws DOMError</haxe_doc>
			<overloads><setTimeout public="1" set="method">
	<f a="handler:?timeout:arguments" v=":0:">
		<x path="haxe.Function"/>
		<x path="Int"/>
		<x path="haxe.extern.Rest"><d/></x>
		<x path="Int"/>
	</f>
	<meta><m n=":value"><e>{timeout:0}</e></m></meta>
	<haxe_doc>@throws DOMError</haxe_doc>
</setTimeout></overloads>
		</setTimeout>
		<clearTimeout public="1" set="method">
			<f a="?handle" v="0">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{handle:0}</e></m></meta>
			<haxe_doc>@throws DOMError</haxe_doc>
		</clearTimeout>
		<setInterval public="1" set="method">
			<f a="handler:?timeout:unused">
				<c path="String"/>
				<x path="Int"/>
				<x path="haxe.extern.Rest"><d/></x>
				<x path="Int"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
			<overloads><setInterval public="1" set="method">
	<f a="handler:?timeout:arguments">
		<x path="haxe.Function"/>
		<x path="Int"/>
		<x path="haxe.extern.Rest"><d/></x>
		<x path="Int"/>
	</f>
	<haxe_doc>@throws DOMError</haxe_doc>
</setInterval></overloads>
		</setInterval>
		<clearInterval public="1" set="method">
			<f a="?handle" v="0">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{handle:0}</e></m></meta>
			<haxe_doc>@throws DOMError</haxe_doc>
		</clearInterval>
		<meta><m n=":native"><e>"Window"</e></m></meta>
	</class>
	<class path="js.html.XMLHttpRequestEventTarget" params="" file="C:\HaxeToolkit\haxe\std/js/html/XMLHttpRequestEventTarget.hx" extern="1">
		<extends path="js.html.EventTarget"/>
		<onloadstart public="1"><x path="haxe.Function"/></onloadstart>
		<onprogress public="1"><x path="haxe.Function"/></onprogress>
		<onabort public="1"><x path="haxe.Function"/></onabort>
		<onerror public="1"><x path="haxe.Function"/></onerror>
		<onload public="1"><x path="haxe.Function"/></onload>
		<ontimeout public="1"><x path="haxe.Function"/></ontimeout>
		<onloadend public="1"><x path="haxe.Function"/></onloadend>
		<meta><m n=":native"><e>"XMLHttpRequestEventTarget"</e></m></meta>
	</class>
	<class path="js.html.XMLHttpRequest" params="" file="C:\HaxeToolkit\haxe\std/js/html/XMLHttpRequest.hx" extern="1">
		<extends path="js.html.XMLHttpRequestEventTarget"/>
		<UNSENT public="1" get="inline" set="null" expr="0" line="30" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</UNSENT>
		<OPENED public="1" get="inline" set="null" expr="1" line="31" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</OPENED>
		<HEADERS_RECEIVED public="1" get="inline" set="null" expr="2" line="32" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2</e></m></meta>
		</HEADERS_RECEIVED>
		<LOADING public="1" get="inline" set="null" expr="3" line="33" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3</e></m></meta>
		</LOADING>
		<DONE public="1" get="inline" set="null" expr="4" line="34" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>4</e></m></meta>
		</DONE>
		<onreadystatechange public="1"><x path="haxe.Function"/></onreadystatechange>
		<readyState public="1" set="null"><x path="Int"/></readyState>
		<timeout public="1"><x path="Int"/></timeout>
		<withCredentials public="1"><x path="Bool"/></withCredentials>
		<upload public="1" set="null"><c path="js.html.XMLHttpRequestUpload"/></upload>
		<responseURL public="1" set="null"><c path="String"/></responseURL>
		<status public="1" set="null"><x path="Int"/></status>
		<statusText public="1" set="null"><c path="String"/></statusText>
		<responseType public="1"><x path="js.html.XMLHttpRequestResponseType"/></responseType>
		<response public="1" set="null"><d/></response>
		<responseText public="1" set="null"><c path="String"/></responseText>
		<responseXML public="1" set="null"><c path="js.html.HTMLDocument"/></responseXML>
		<open public="1" set="method">
			<f a="method:url:async:?user:?password">
				<c path="String"/>
				<c path="String"/>
				<x path="Bool"/>
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
			<overloads><open public="1" set="method">
	<f a="method:url">
		<c path="String"/>
		<c path="String"/>
		<x path="Void"/>
	</f>
	<haxe_doc>@throws DOMError</haxe_doc>
</open></overloads>
		</open>
		<setRequestHeader public="1" set="method">
			<f a="header:value">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</setRequestHeader>
		<send public="1" set="method">
			<f a="data">
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
			<overloads>
				<send public="1" set="method">
					<f a=""><x path="Void"/></f>
					<haxe_doc>@throws DOMError</haxe_doc>
				</send>
				<send public="1" set="method">
					<f a="data">
						<c path="js.html.ArrayBuffer"/>
						<x path="Void"/>
					</f>
					<haxe_doc>@throws DOMError</haxe_doc>
				</send>
				<send public="1" set="method">
					<f a="data">
						<c path="js.html.ArrayBufferView"/>
						<x path="Void"/>
					</f>
					<haxe_doc>@throws DOMError</haxe_doc>
				</send>
				<send public="1" set="method">
					<f a="data">
						<c path="js.html.Blob"/>
						<x path="Void"/>
					</f>
					<haxe_doc>@throws DOMError</haxe_doc>
				</send>
				<send public="1" set="method">
					<f a="data">
						<c path="js.html.HTMLDocument"/>
						<x path="Void"/>
					</f>
					<haxe_doc>@throws DOMError</haxe_doc>
				</send>
				<send public="1" set="method">
					<f a="data">
						<c path="String"/>
						<x path="Void"/>
					</f>
					<haxe_doc>@throws DOMError</haxe_doc>
				</send>
				<send public="1" set="method">
					<f a="data">
						<c path="js.html.FormData"/>
						<x path="Void"/>
					</f>
					<haxe_doc>@throws DOMError</haxe_doc>
				</send>
			</overloads>
		</send>
		<abort public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</abort>
		<getResponseHeader public="1" set="method">
			<f a="header">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</getResponseHeader>
		<getAllResponseHeaders public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</getAllResponseHeaders>
		<overrideMimeType public="1" set="method">
			<f a="mime">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</overrideMimeType>
		<sendAsBinary public="1" set="method">
			<f a="body">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</sendAsBinary>
		<new public="1" set="method">
			<f a="ignored">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
			<overloads><new public="1" set="method">
	<f a="?params">
		<d/>
		<x path="Void"/>
	</f>
	<haxe_doc>@throws DOMError</haxe_doc>
</new></overloads>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":native"><e>"XMLHttpRequest"</e></m>
		</meta>
	</class>
	<abstract path="js.html.XMLHttpRequestResponseType" params="" file="C:\HaxeToolkit\haxe\std/js/html/XMLHttpRequestResponseType.hx">
		<this><c path="String"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="js.html._XMLHttpRequestResponseType.XMLHttpRequestResponseType_Impl_" params="" file="C:\HaxeToolkit\haxe\std/js/html/XMLHttpRequestResponseType.hx" private="1" module="js.html.XMLHttpRequestResponseType"><meta>
	<m n=":keep"/>
	<m n=":enum"/>
</meta></class></impl>
	</abstract>
	<class path="js.html.XMLHttpRequestUpload" params="" file="C:\HaxeToolkit\haxe\std/js/html/XMLHttpRequestUpload.hx" extern="1">
		<extends path="js.html.XMLHttpRequestEventTarget"/>
		<meta><m n=":native"><e>"XMLHttpRequestUpload"</e></m></meta>
	</class>
	<class path="js.html.XPathExpression" params="" file="C:\HaxeToolkit\haxe\std/js/html/XPathExpression.hx" extern="1">
		<evaluate public="1" set="method">
			<f a="contextNode:type:result">
				<c path="js.html.Node"/>
				<x path="Int"/>
				<d/>
				<c path="js.html.XPathResult"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</evaluate>
		<meta><m n=":native"><e>"XPathExpression"</e></m></meta>
	</class>
	<class path="js.html.XPathNSResolver" params="" file="C:\HaxeToolkit\haxe\std/js/html/XPathNSResolver.hx" extern="1">
		<lookupNamespaceURI public="1" set="method"><f a="prefix">
	<c path="String"/>
	<c path="String"/>
</f></lookupNamespaceURI>
		<meta><m n=":native"><e>"XPathNSResolver"</e></m></meta>
	</class>
	<class path="js.html.XPathResult" params="" file="C:\HaxeToolkit\haxe\std/js/html/XPathResult.hx" extern="1">
		<ANY_TYPE public="1" get="inline" set="null" expr="0" line="30" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</ANY_TYPE>
		<NUMBER_TYPE public="1" get="inline" set="null" expr="1" line="31" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</NUMBER_TYPE>
		<STRING_TYPE public="1" get="inline" set="null" expr="2" line="32" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2</e></m></meta>
		</STRING_TYPE>
		<BOOLEAN_TYPE public="1" get="inline" set="null" expr="3" line="33" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3</e></m></meta>
		</BOOLEAN_TYPE>
		<UNORDERED_NODE_ITERATOR_TYPE public="1" get="inline" set="null" expr="4" line="34" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>4</e></m></meta>
		</UNORDERED_NODE_ITERATOR_TYPE>
		<ORDERED_NODE_ITERATOR_TYPE public="1" get="inline" set="null" expr="5" line="35" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>5</e></m></meta>
		</ORDERED_NODE_ITERATOR_TYPE>
		<UNORDERED_NODE_SNAPSHOT_TYPE public="1" get="inline" set="null" expr="6" line="36" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>6</e></m></meta>
		</UNORDERED_NODE_SNAPSHOT_TYPE>
		<ORDERED_NODE_SNAPSHOT_TYPE public="1" get="inline" set="null" expr="7" line="37" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>7</e></m></meta>
		</ORDERED_NODE_SNAPSHOT_TYPE>
		<ANY_UNORDERED_NODE_TYPE public="1" get="inline" set="null" expr="8" line="38" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>8</e></m></meta>
		</ANY_UNORDERED_NODE_TYPE>
		<FIRST_ORDERED_NODE_TYPE public="1" get="inline" set="null" expr="9" line="39" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>9</e></m></meta>
		</FIRST_ORDERED_NODE_TYPE>
		<resultType public="1" set="null"><x path="Int"/></resultType>
		<numberValue public="1" set="null"><x path="Float"/></numberValue>
		<stringValue public="1" set="null"><c path="String"/></stringValue>
		<booleanValue public="1" set="null"><x path="Bool"/></booleanValue>
		<singleNodeValue public="1" set="null"><c path="js.html.Node"/></singleNodeValue>
		<invalidIteratorState public="1" set="null"><x path="Bool"/></invalidIteratorState>
		<snapshotLength public="1" set="null"><x path="Int"/></snapshotLength>
		<iterateNext public="1" set="method">
			<f a=""><c path="js.html.Node"/></f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</iterateNext>
		<snapshotItem public="1" set="method">
			<f a="index">
				<x path="Int"/>
				<c path="js.html.Node"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</snapshotItem>
		<meta><m n=":native"><e>"XPathResult"</e></m></meta>
	</class>
	<class path="js.html.audio.AudioNode" params="" file="C:\HaxeToolkit\haxe\std/js/html/audio/AudioNode.hx" extern="1">
		<extends path="js.html.EventTarget"/>
		<context public="1" set="null"><c path="js.html.audio.AudioContext"/></context>
		<numberOfInputs public="1" set="null"><x path="Int"/></numberOfInputs>
		<numberOfOutputs public="1" set="null"><x path="Int"/></numberOfOutputs>
		<channelCount public="1"><x path="Int"/></channelCount>
		<channelCountMode public="1"><x path="js.html.audio.ChannelCountMode"/></channelCountMode>
		<channelInterpretation public="1"><x path="js.html.audio.ChannelInterpretation"/></channelInterpretation>
		<connect public="1" set="method">
			<f a="destination:?output" v=":0">
				<c path="js.html.audio.AudioParam"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{output:0}</e></m></meta>
			<haxe_doc>@throws DOMError</haxe_doc>
			<overloads><connect public="1" set="method">
	<f a="destination:?output:?input" v=":0:0">
		<c path="js.html.audio.AudioNode"/>
		<x path="Int"/>
		<x path="Int"/>
		<x path="Void"/>
	</f>
	<meta><m n=":value"><e>{input:0,output:0}</e></m></meta>
	<haxe_doc>@throws DOMError</haxe_doc>
</connect></overloads>
		</connect>
		<disconnect public="1" set="method">
			<f a="?output" v="0">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{output:0}</e></m></meta>
			<haxe_doc>@throws DOMError</haxe_doc>
		</disconnect>
		<meta><m n=":native"><e>"AudioNode"</e></m></meta>
	</class>
	<class path="js.html.audio.AnalyserNode" params="" file="C:\HaxeToolkit\haxe\std/js/html/audio/AnalyserNode.hx" extern="1">
		<extends path="js.html.audio.AudioNode"/>
		<fftSize public="1"><x path="Int"/></fftSize>
		<frequencyBinCount public="1" set="null"><x path="Int"/></frequencyBinCount>
		<minDecibels public="1"><x path="Float"/></minDecibels>
		<maxDecibels public="1"><x path="Float"/></maxDecibels>
		<smoothingTimeConstant public="1"><x path="Float"/></smoothingTimeConstant>
		<getFloatFrequencyData public="1" set="method"><f a="array">
	<c path="js.html.Float32Array"/>
	<x path="Void"/>
</f></getFloatFrequencyData>
		<getByteFrequencyData public="1" set="method"><f a="array">
	<c path="js.html.Uint8Array"/>
	<x path="Void"/>
</f></getByteFrequencyData>
		<getFloatTimeDomainData public="1" set="method"><f a="array">
	<c path="js.html.Float32Array"/>
	<x path="Void"/>
</f></getFloatTimeDomainData>
		<getByteTimeDomainData public="1" set="method"><f a="array">
	<c path="js.html.Uint8Array"/>
	<x path="Void"/>
</f></getByteTimeDomainData>
		<meta><m n=":native"><e>"AnalyserNode"</e></m></meta>
	</class>
	<class path="js.html.audio.AudioBuffer" params="" file="C:\HaxeToolkit\haxe\std/js/html/audio/AudioBuffer.hx" extern="1">
		<sampleRate public="1" set="null"><x path="Float"/></sampleRate>
		<length public="1" set="null"><x path="Int"/></length>
		<duration public="1" set="null"><x path="Float"/></duration>
		<numberOfChannels public="1" set="null"><x path="Int"/></numberOfChannels>
		<getChannelData public="1" set="method">
			<f a="channel">
				<x path="Int"/>
				<c path="js.html.Float32Array"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</getChannelData>
		<copyFromChannel public="1" set="method">
			<f a="destination:channelNumber:?startInChannel" v="::0">
				<c path="js.html.Float32Array"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{startInChannel:0}</e></m></meta>
			<haxe_doc>@throws DOMError</haxe_doc>
		</copyFromChannel>
		<copyToChannel public="1" set="method">
			<f a="source:channelNumber:?startInChannel" v="::0">
				<c path="js.html.Float32Array"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{startInChannel:0}</e></m></meta>
			<haxe_doc>@throws DOMError</haxe_doc>
		</copyToChannel>
		<meta><m n=":native"><e>"AudioBuffer"</e></m></meta>
	</class>
	<class path="js.html.audio.AudioBufferSourceNode" params="" file="C:\HaxeToolkit\haxe\std/js/html/audio/AudioBufferSourceNode.hx" extern="1">
		<extends path="js.html.audio.AudioNode"/>
		<buffer public="1"><c path="js.html.audio.AudioBuffer"/></buffer>
		<playbackRate public="1" set="null"><c path="js.html.audio.AudioParam"/></playbackRate>
		<loop public="1"><x path="Bool"/></loop>
		<loopStart public="1"><x path="Float"/></loopStart>
		<loopEnd public="1"><x path="Float"/></loopEnd>
		<onended public="1"><x path="haxe.Function"/></onended>
		<start public="1" set="method">
			<f a="?when:?grainOffset:?grainDuration" v="0.0:0.0:">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{grainOffset:0.0,when:0.0}</e></m></meta>
			<haxe_doc>@throws DOMError</haxe_doc>
		</start>
		<stop public="1" set="method">
			<f a="?when" v="0.0">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{when:0.0}</e></m></meta>
			<haxe_doc>@throws DOMError</haxe_doc>
		</stop>
		<meta><m n=":native"><e>"AudioBufferSourceNode"</e></m></meta>
	</class>
	<class path="js.html.audio.AudioContext" params="" file="C:\HaxeToolkit\haxe\std/js/html/audio/AudioContext.hx" extern="1">
		<extends path="js.html.EventTarget"/>
		<destination public="1" set="null"><c path="js.html.audio.AudioDestinationNode"/></destination>
		<sampleRate public="1" set="null"><x path="Float"/></sampleRate>
		<currentTime public="1" set="null"><x path="Float"/></currentTime>
		<listener public="1" set="null"><c path="js.html.audio.AudioListener"/></listener>
		<createBuffer public="1" set="method">
			<f a="numberOfChannels:length:sampleRate">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Float"/>
				<c path="js.html.audio.AudioBuffer"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</createBuffer>
		<decodeAudioData public="1" set="method"><f a="audioData:?successCallback:?errorCallback">
	<c path="js.html.ArrayBuffer"/>
	<f a="">
		<c path="js.html.audio.AudioBuffer"/>
		<x path="Void"/>
	</f>
	<f a=""><x path="Void"/></f>
	<c path="js.Promise"><c path="js.html.audio.AudioBuffer"/></c>
</f></decodeAudioData>
		<createBufferSource public="1" set="method"><f a=""><c path="js.html.audio.AudioBufferSourceNode"/></f></createBufferSource>
		<createMediaStreamDestination public="1" set="method">
			<f a=""><c path="js.html.audio.MediaStreamAudioDestinationNode"/></f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</createMediaStreamDestination>
		<createScriptProcessor public="1" set="method">
			<f a="?bufferSize:?numberOfInputChannels:?numberOfOutputChannels" v="0:2:2">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="js.html.audio.ScriptProcessorNode"/>
			</f>
			<meta><m n=":value"><e>{numberOfOutputChannels:2,numberOfInputChannels:2,bufferSize:0}</e></m></meta>
			<haxe_doc>@throws DOMError</haxe_doc>
		</createScriptProcessor>
		<createStereoPanner public="1" set="method"><f a=""><c path="js.html.audio.StereoPannerNode"/></f></createStereoPanner>
		<createAnalyser public="1" set="method"><f a=""><c path="js.html.audio.AnalyserNode"/></f></createAnalyser>
		<createMediaElementSource public="1" set="method">
			<f a="mediaElement">
				<c path="js.html.MediaElement"/>
				<c path="js.html.audio.MediaElementAudioSourceNode"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</createMediaElementSource>
		<createMediaStreamSource public="1" set="method">
			<f a="mediaStream">
				<c path="js.html.MediaStream"/>
				<c path="js.html.audio.MediaStreamAudioSourceNode"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</createMediaStreamSource>
		<createGain public="1" set="method"><f a=""><c path="js.html.audio.GainNode"/></f></createGain>
		<createDelay public="1" set="method">
			<f a="?maxDelayTime" v="1.0">
				<x path="Float"/>
				<c path="js.html.audio.DelayNode"/>
			</f>
			<meta><m n=":value"><e>{maxDelayTime:1.0}</e></m></meta>
			<haxe_doc>@throws DOMError</haxe_doc>
		</createDelay>
		<createBiquadFilter public="1" set="method"><f a=""><c path="js.html.audio.BiquadFilterNode"/></f></createBiquadFilter>
		<createWaveShaper public="1" set="method"><f a=""><c path="js.html.audio.WaveShaperNode"/></f></createWaveShaper>
		<createPanner public="1" set="method"><f a=""><c path="js.html.audio.PannerNode"/></f></createPanner>
		<createConvolver public="1" set="method"><f a=""><c path="js.html.audio.ConvolverNode"/></f></createConvolver>
		<createChannelSplitter public="1" set="method">
			<f a="?numberOfOutputs" v="6">
				<x path="Int"/>
				<c path="js.html.audio.ChannelSplitterNode"/>
			</f>
			<meta><m n=":value"><e>{numberOfOutputs:6}</e></m></meta>
			<haxe_doc>@throws DOMError</haxe_doc>
		</createChannelSplitter>
		<createChannelMerger public="1" set="method">
			<f a="?numberOfInputs" v="6">
				<x path="Int"/>
				<c path="js.html.audio.ChannelMergerNode"/>
			</f>
			<meta><m n=":value"><e>{numberOfInputs:6}</e></m></meta>
			<haxe_doc>@throws DOMError</haxe_doc>
		</createChannelMerger>
		<createDynamicsCompressor public="1" set="method"><f a=""><c path="js.html.audio.DynamicsCompressorNode"/></f></createDynamicsCompressor>
		<createOscillator public="1" set="method"><f a=""><c path="js.html.audio.OscillatorNode"/></f></createOscillator>
		<createPeriodicWave public="1" set="method">
			<f a="real:imag">
				<c path="js.html.Float32Array"/>
				<c path="js.html.Float32Array"/>
				<c path="js.html.audio.PeriodicWave"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</createPeriodicWave>
		<new public="1" set="method">
			<f a="audioChannelType">
				<x path="js.html.AudioChannel"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
			<overloads><new public="1" set="method">
	<f a=""><x path="Void"/></f>
	<haxe_doc>@throws DOMError</haxe_doc>
</new></overloads>
		</new>
		<meta><m n=":native"><e>"AudioContext"</e></m></meta>
	</class>
	<class path="js.html.audio.AudioDestinationNode" params="" file="C:\HaxeToolkit\haxe\std/js/html/audio/AudioDestinationNode.hx" extern="1">
		<extends path="js.html.audio.AudioNode"/>
		<maxChannelCount public="1" set="null"><x path="Int"/></maxChannelCount>
		<meta><m n=":native"><e>"AudioDestinationNode"</e></m></meta>
	</class>
	<class path="js.html.audio.AudioListener" params="" file="C:\HaxeToolkit\haxe\std/js/html/audio/AudioListener.hx" extern="1">
		<dopplerFactor public="1"><x path="Float"/></dopplerFactor>
		<speedOfSound public="1"><x path="Float"/></speedOfSound>
		<setPosition public="1" set="method"><f a="x:y:z">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setPosition>
		<setOrientation public="1" set="method"><f a="x:y:z:xUp:yUp:zUp">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setOrientation>
		<setVelocity public="1" set="method"><f a="x:y:z">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setVelocity>
		<meta><m n=":native"><e>"AudioListener"</e></m></meta>
	</class>
	<class path="js.html.audio.AudioParam" params="" file="C:\HaxeToolkit\haxe\std/js/html/audio/AudioParam.hx" extern="1">
		<value public="1"><x path="Float"/></value>
		<defaultValue public="1" set="null"><x path="Float"/></defaultValue>
		<setValueAtTime public="1" set="method">
			<f a="value:startTime">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</setValueAtTime>
		<linearRampToValueAtTime public="1" set="method">
			<f a="value:endTime">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</linearRampToValueAtTime>
		<exponentialRampToValueAtTime public="1" set="method">
			<f a="value:endTime">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</exponentialRampToValueAtTime>
		<setTargetAtTime public="1" set="method">
			<f a="target:startTime:timeConstant">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</setTargetAtTime>
		<setValueCurveAtTime public="1" set="method">
			<f a="values:startTime:duration">
				<c path="js.html.Float32Array"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</setValueCurveAtTime>
		<cancelScheduledValues public="1" set="method">
			<f a="startTime">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</cancelScheduledValues>
		<meta><m n=":native"><e>"AudioParam"</e></m></meta>
	</class>
	<class path="js.html.audio.BiquadFilterNode" params="" file="C:\HaxeToolkit\haxe\std/js/html/audio/BiquadFilterNode.hx" extern="1">
		<extends path="js.html.audio.AudioNode"/>
		<type public="1"><x path="js.html.audio.BiquadFilterType"/></type>
		<frequency public="1" set="null"><c path="js.html.audio.AudioParam"/></frequency>
		<detune public="1" set="null"><c path="js.html.audio.AudioParam"/></detune>
		<Q public="1" set="null"><c path="js.html.audio.AudioParam"/></Q>
		<gain public="1" set="null"><c path="js.html.audio.AudioParam"/></gain>
		<getFrequencyResponse public="1" set="method"><f a="frequencyHz:magResponse:phaseResponse">
	<c path="js.html.Float32Array"/>
	<c path="js.html.Float32Array"/>
	<c path="js.html.Float32Array"/>
	<x path="Void"/>
</f></getFrequencyResponse>
		<meta><m n=":native"><e>"BiquadFilterNode"</e></m></meta>
	</class>
	<abstract path="js.html.audio.BiquadFilterType" params="" file="C:\HaxeToolkit\haxe\std/js/html/audio/BiquadFilterType.hx">
		<this><c path="String"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="js.html.audio._BiquadFilterType.BiquadFilterType_Impl_" params="" file="C:\HaxeToolkit\haxe\std/js/html/audio/BiquadFilterType.hx" private="1" module="js.html.audio.BiquadFilterType"><meta>
	<m n=":keep"/>
	<m n=":enum"/>
</meta></class></impl>
	</abstract>
	<abstract path="js.html.audio.ChannelCountMode" params="" file="C:\HaxeToolkit\haxe\std/js/html/audio/ChannelCountMode.hx">
		<this><c path="String"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="js.html.audio._ChannelCountMode.ChannelCountMode_Impl_" params="" file="C:\HaxeToolkit\haxe\std/js/html/audio/ChannelCountMode.hx" private="1" module="js.html.audio.ChannelCountMode"><meta>
	<m n=":keep"/>
	<m n=":enum"/>
</meta></class></impl>
	</abstract>
	<abstract path="js.html.audio.ChannelInterpretation" params="" file="C:\HaxeToolkit\haxe\std/js/html/audio/ChannelInterpretation.hx">
		<this><c path="String"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="js.html.audio._ChannelInterpretation.ChannelInterpretation_Impl_" params="" file="C:\HaxeToolkit\haxe\std/js/html/audio/ChannelInterpretation.hx" private="1" module="js.html.audio.ChannelInterpretation"><meta>
	<m n=":keep"/>
	<m n=":enum"/>
</meta></class></impl>
	</abstract>
	<class path="js.html.audio.ChannelMergerNode" params="" file="C:\HaxeToolkit\haxe\std/js/html/audio/ChannelMergerNode.hx" extern="1">
		<extends path="js.html.audio.AudioNode"/>
		<meta><m n=":native"><e>"ChannelMergerNode"</e></m></meta>
	</class>
	<class path="js.html.audio.ChannelSplitterNode" params="" file="C:\HaxeToolkit\haxe\std/js/html/audio/ChannelSplitterNode.hx" extern="1">
		<extends path="js.html.audio.AudioNode"/>
		<meta><m n=":native"><e>"ChannelSplitterNode"</e></m></meta>
	</class>
	<class path="js.html.audio.ConvolverNode" params="" file="C:\HaxeToolkit\haxe\std/js/html/audio/ConvolverNode.hx" extern="1">
		<extends path="js.html.audio.AudioNode"/>
		<buffer public="1"><c path="js.html.audio.AudioBuffer"/></buffer>
		<normalize public="1"><x path="Bool"/></normalize>
		<meta><m n=":native"><e>"ConvolverNode"</e></m></meta>
	</class>
	<class path="js.html.audio.DelayNode" params="" file="C:\HaxeToolkit\haxe\std/js/html/audio/DelayNode.hx" extern="1">
		<extends path="js.html.audio.AudioNode"/>
		<delayTime public="1" set="null"><c path="js.html.audio.AudioParam"/></delayTime>
		<meta><m n=":native"><e>"DelayNode"</e></m></meta>
	</class>
	<abstract path="js.html.audio.DistanceModelType" params="" file="C:\HaxeToolkit\haxe\std/js/html/audio/DistanceModelType.hx">
		<this><c path="String"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="js.html.audio._DistanceModelType.DistanceModelType_Impl_" params="" file="C:\HaxeToolkit\haxe\std/js/html/audio/DistanceModelType.hx" private="1" module="js.html.audio.DistanceModelType"><meta>
	<m n=":keep"/>
	<m n=":enum"/>
</meta></class></impl>
	</abstract>
	<class path="js.html.audio.DynamicsCompressorNode" params="" file="C:\HaxeToolkit\haxe\std/js/html/audio/DynamicsCompressorNode.hx" extern="1">
		<extends path="js.html.audio.AudioNode"/>
		<threshold public="1" set="null"><c path="js.html.audio.AudioParam"/></threshold>
		<knee public="1" set="null"><c path="js.html.audio.AudioParam"/></knee>
		<ratio public="1" set="null"><c path="js.html.audio.AudioParam"/></ratio>
		<reduction public="1" set="null"><c path="js.html.audio.AudioParam"/></reduction>
		<attack public="1" set="null"><c path="js.html.audio.AudioParam"/></attack>
		<release public="1" set="null"><c path="js.html.audio.AudioParam"/></release>
		<meta><m n=":native"><e>"DynamicsCompressorNode"</e></m></meta>
	</class>
	<class path="js.html.audio.GainNode" params="" file="C:\HaxeToolkit\haxe\std/js/html/audio/GainNode.hx" extern="1">
		<extends path="js.html.audio.AudioNode"/>
		<gain public="1" set="null"><c path="js.html.audio.AudioParam"/></gain>
		<meta><m n=":native"><e>"GainNode"</e></m></meta>
	</class>
	<class path="js.html.audio.MediaElementAudioSourceNode" params="" file="C:\HaxeToolkit\haxe\std/js/html/audio/MediaElementAudioSourceNode.hx" extern="1">
		<extends path="js.html.audio.AudioNode"/>
		<meta><m n=":native"><e>"MediaElementAudioSourceNode"</e></m></meta>
	</class>
	<class path="js.html.audio.MediaStreamAudioDestinationNode" params="" file="C:\HaxeToolkit\haxe\std/js/html/audio/MediaStreamAudioDestinationNode.hx" extern="1">
		<extends path="js.html.audio.AudioNode"/>
		<stream public="1" set="null"><c path="js.html.MediaStream"/></stream>
		<meta><m n=":native"><e>"MediaStreamAudioDestinationNode"</e></m></meta>
	</class>
	<class path="js.html.audio.MediaStreamAudioSourceNode" params="" file="C:\HaxeToolkit\haxe\std/js/html/audio/MediaStreamAudioSourceNode.hx" extern="1">
		<extends path="js.html.audio.AudioNode"/>
		<meta><m n=":native"><e>"MediaStreamAudioSourceNode"</e></m></meta>
	</class>
	<class path="js.html.audio.OscillatorNode" params="" file="C:\HaxeToolkit\haxe\std/js/html/audio/OscillatorNode.hx" extern="1">
		<extends path="js.html.audio.AudioNode"/>
		<type public="1"><x path="js.html.audio.OscillatorType"/></type>
		<frequency public="1" set="null"><c path="js.html.audio.AudioParam"/></frequency>
		<detune public="1" set="null"><c path="js.html.audio.AudioParam"/></detune>
		<onended public="1"><x path="haxe.Function"/></onended>
		<start public="1" set="method">
			<f a="?when" v="0.0">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{when:0.0}</e></m></meta>
			<haxe_doc>@throws DOMError</haxe_doc>
		</start>
		<stop public="1" set="method">
			<f a="?when" v="0.0">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{when:0.0}</e></m></meta>
			<haxe_doc>@throws DOMError</haxe_doc>
		</stop>
		<setPeriodicWave public="1" set="method"><f a="periodicWave">
	<c path="js.html.audio.PeriodicWave"/>
	<x path="Void"/>
</f></setPeriodicWave>
		<meta><m n=":native"><e>"OscillatorNode"</e></m></meta>
	</class>
	<abstract path="js.html.audio.OscillatorType" params="" file="C:\HaxeToolkit\haxe\std/js/html/audio/OscillatorType.hx">
		<this><c path="String"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="js.html.audio._OscillatorType.OscillatorType_Impl_" params="" file="C:\HaxeToolkit\haxe\std/js/html/audio/OscillatorType.hx" private="1" module="js.html.audio.OscillatorType"><meta>
	<m n=":keep"/>
	<m n=":enum"/>
</meta></class></impl>
	</abstract>
	<abstract path="js.html.audio.OverSampleType" params="" file="C:\HaxeToolkit\haxe\std/js/html/audio/OverSampleType.hx">
		<this><c path="String"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="js.html.audio._OverSampleType.OverSampleType_Impl_" params="" file="C:\HaxeToolkit\haxe\std/js/html/audio/OverSampleType.hx" private="1" module="js.html.audio.OverSampleType"><meta>
	<m n=":keep"/>
	<m n=":enum"/>
</meta></class></impl>
	</abstract>
	<class path="js.html.audio.PannerNode" params="" file="C:\HaxeToolkit\haxe\std/js/html/audio/PannerNode.hx" extern="1">
		<extends path="js.html.audio.AudioNode"/>
		<panningModel public="1"><x path="js.html.audio.PanningModelType"/></panningModel>
		<distanceModel public="1"><x path="js.html.audio.DistanceModelType"/></distanceModel>
		<refDistance public="1"><x path="Float"/></refDistance>
		<maxDistance public="1"><x path="Float"/></maxDistance>
		<rolloffFactor public="1"><x path="Float"/></rolloffFactor>
		<coneInnerAngle public="1"><x path="Float"/></coneInnerAngle>
		<coneOuterAngle public="1"><x path="Float"/></coneOuterAngle>
		<coneOuterGain public="1"><x path="Float"/></coneOuterGain>
		<setPosition public="1" set="method"><f a="x:y:z">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setPosition>
		<setOrientation public="1" set="method"><f a="x:y:z">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setOrientation>
		<setVelocity public="1" set="method"><f a="x:y:z">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setVelocity>
		<meta><m n=":native"><e>"PannerNode"</e></m></meta>
	</class>
	<abstract path="js.html.audio.PanningModelType" params="" file="C:\HaxeToolkit\haxe\std/js/html/audio/PanningModelType.hx">
		<this><c path="String"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="js.html.audio._PanningModelType.PanningModelType_Impl_" params="" file="C:\HaxeToolkit\haxe\std/js/html/audio/PanningModelType.hx" private="1" module="js.html.audio.PanningModelType"><meta>
	<m n=":keep"/>
	<m n=":enum"/>
</meta></class></impl>
	</abstract>
	<class path="js.html.audio.PeriodicWave" params="" file="C:\HaxeToolkit\haxe\std/js/html/audio/PeriodicWave.hx" extern="1"><meta><m n=":native"><e>"PeriodicWave"</e></m></meta></class>
	<class path="js.html.audio.ScriptProcessorNode" params="" file="C:\HaxeToolkit\haxe\std/js/html/audio/ScriptProcessorNode.hx" extern="1">
		<extends path="js.html.audio.AudioNode"/>
		<onaudioprocess public="1"><x path="haxe.Function"/></onaudioprocess>
		<bufferSize public="1" set="null"><x path="Int"/></bufferSize>
		<meta><m n=":native"><e>"ScriptProcessorNode"</e></m></meta>
	</class>
	<class path="js.html.audio.StereoPannerNode" params="" file="C:\HaxeToolkit\haxe\std/js/html/audio/StereoPannerNode.hx" extern="1">
		<extends path="js.html.audio.AudioNode"/>
		<pan public="1" set="null"><c path="js.html.audio.AudioParam"/></pan>
		<meta><m n=":native"><e>"StereoPannerNode"</e></m></meta>
	</class>
	<class path="js.html.audio.WaveShaperNode" params="" file="C:\HaxeToolkit\haxe\std/js/html/audio/WaveShaperNode.hx" extern="1">
		<extends path="js.html.audio.AudioNode"/>
		<curve public="1"><c path="js.html.Float32Array"/></curve>
		<oversample public="1"><x path="js.html.audio.OverSampleType"/></oversample>
		<meta><m n=":native"><e>"WaveShaperNode"</e></m></meta>
	</class>
	<class path="js.html.idb.Cursor" params="" file="C:\HaxeToolkit\haxe\std/js/html/idb/Cursor.hx" extern="1">
		<source public="1" set="null"><x path="haxe.extern.EitherType">
	<c path="js.html.idb.ObjectStore"/>
	<c path="js.html.idb.Index"/>
</x></source>
		<direction public="1" set="null"><x path="js.html.idb.CursorDirection"/></direction>
		<key public="1" set="null"><d/></key>
		<primaryKey public="1" set="null"><d/></primaryKey>
		<update public="1" set="method">
			<f a="value">
				<d/>
				<c path="js.html.idb.Request"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</update>
		<advance public="1" set="method">
			<f a="count">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</advance>
		<continue_ public="1" set="method">
			<f a="?key">
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":native"><e>"continue"</e></m></meta>
			<haxe_doc>@throws DOMError</haxe_doc>
		</continue_>
		<delete_ public="1" set="method">
			<f a=""><c path="js.html.idb.Request"/></f>
			<meta><m n=":native"><e>"delete"</e></m></meta>
			<haxe_doc>@throws DOMError</haxe_doc>
		</delete_>
		<meta><m n=":native"><e>"IDBCursor"</e></m></meta>
	</class>
	<abstract path="js.html.idb.CursorDirection" params="" file="C:\HaxeToolkit\haxe\std/js/html/idb/CursorDirection.hx">
		<this><c path="String"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="js.html.idb._CursorDirection.CursorDirection_Impl_" params="" file="C:\HaxeToolkit\haxe\std/js/html/idb/CursorDirection.hx" private="1" module="js.html.idb.CursorDirection"><meta>
	<m n=":keep"/>
	<m n=":enum"/>
</meta></class></impl>
	</abstract>
	<class path="js.html.idb.Database" params="" file="C:\HaxeToolkit\haxe\std/js/html/idb/Database.hx" extern="1">
		<extends path="js.html.EventTarget"/>
		<name public="1" set="null"><c path="String"/></name>
		<version public="1" set="null"><x path="Int"/></version>
		<objectStoreNames public="1" set="null"><c path="js.html.DOMStringList"/></objectStoreNames>
		<onabort public="1"><x path="haxe.Function"/></onabort>
		<onerror public="1"><x path="haxe.Function"/></onerror>
		<onversionchange public="1"><x path="haxe.Function"/></onversionchange>
		<createObjectStore public="1" set="method">
			<f a="name:?optionalParameters">
				<c path="String"/>
				<t path="js.html.idb.ObjectStoreParameters"/>
				<c path="js.html.idb.ObjectStore"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</createObjectStore>
		<deleteObjectStore public="1" set="method">
			<f a="name">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</deleteObjectStore>
		<transaction public="1" set="method">
			<f a="storeNames:?mode" v=":&quot;readonly&quot;">
				<c path="Array"><c path="String"/></c>
				<x path="js.html.idb.TransactionMode"/>
				<c path="js.html.idb.Transaction"/>
			</f>
			<meta><m n=":value"><e>{mode:"readonly"}</e></m></meta>
			<haxe_doc>@throws DOMError</haxe_doc>
			<overloads><transaction public="1" set="method">
	<f a="storeName:?mode" v=":&quot;readonly&quot;">
		<c path="String"/>
		<x path="js.html.idb.TransactionMode"/>
		<c path="js.html.idb.Transaction"/>
	</f>
	<meta><m n=":value"><e>{mode:"readonly"}</e></m></meta>
	<haxe_doc>@throws DOMError</haxe_doc>
</transaction></overloads>
		</transaction>
		<close public="1" set="method"><f a=""><x path="Void"/></f></close>
		<createMutableFile public="1" set="method">
			<f a="name:?type">
				<c path="String"/>
				<c path="String"/>
				<c path="js.html.idb.Request"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</createMutableFile>
		<meta><m n=":native"><e>"IDBDatabase"</e></m></meta>
	</class>
	<class path="js.html.idb.Factory" params="" file="C:\HaxeToolkit\haxe\std/js/html/idb/Factory.hx" extern="1">
		<open public="1" set="method">
			<f a="name:?options">
				<c path="String"/>
				<t path="js.html.idb.OpenDBOptions"/>
				<c path="js.html.idb.OpenDBRequest"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
			<overloads><open public="1" set="method">
	<f a="name:version">
		<c path="String"/>
		<x path="Int"/>
		<c path="js.html.idb.OpenDBRequest"/>
	</f>
	<haxe_doc>@throws DOMError</haxe_doc>
</open></overloads>
		</open>
		<deleteDatabase public="1" set="method">
			<f a="name:?options">
				<c path="String"/>
				<t path="js.html.idb.OpenDBOptions"/>
				<c path="js.html.idb.OpenDBRequest"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</deleteDatabase>
		<cmp public="1" set="method">
			<f a="first:second">
				<d/>
				<d/>
				<x path="Int"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</cmp>
		<meta><m n=":native"><e>"IDBFactory"</e></m></meta>
	</class>
	<class path="js.html.idb.Index" params="" file="C:\HaxeToolkit\haxe\std/js/html/idb/Index.hx" extern="1">
		<name public="1" set="null"><c path="String"/></name>
		<objectStore public="1" set="null"><c path="js.html.idb.ObjectStore"/></objectStore>
		<keyPath public="1" set="null"><d/></keyPath>
		<multiEntry public="1" set="null"><x path="Bool"/></multiEntry>
		<unique public="1" set="null"><x path="Bool"/></unique>
		<openCursor public="1" set="method">
			<f a="?range:?direction" v=":&quot;next&quot;">
				<d/>
				<x path="js.html.idb.CursorDirection"/>
				<c path="js.html.idb.Request"/>
			</f>
			<meta><m n=":value"><e>{direction:"next"}</e></m></meta>
			<haxe_doc>@throws DOMError</haxe_doc>
		</openCursor>
		<openKeyCursor public="1" set="method">
			<f a="?range:?direction" v=":&quot;next&quot;">
				<d/>
				<x path="js.html.idb.CursorDirection"/>
				<c path="js.html.idb.Request"/>
			</f>
			<meta><m n=":value"><e>{direction:"next"}</e></m></meta>
			<haxe_doc>@throws DOMError</haxe_doc>
		</openKeyCursor>
		<get public="1" set="method">
			<f a="key">
				<d/>
				<c path="js.html.idb.Request"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</get>
		<getKey public="1" set="method">
			<f a="key">
				<d/>
				<c path="js.html.idb.Request"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</getKey>
		<count public="1" set="method">
			<f a="?key">
				<d/>
				<c path="js.html.idb.Request"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</count>
		<meta><m n=":native"><e>"IDBIndex"</e></m></meta>
	</class>
	<typedef path="js.html.idb.IndexParameters" params="" file="C:\HaxeToolkit\haxe\std/js/html/idb/IndexParameters.hx"><a>
	<unique>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</unique>
	<multiEntry>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</multiEntry>
</a></typedef>
	<class path="js.html.idb.ObjectStore" params="" file="C:\HaxeToolkit\haxe\std/js/html/idb/ObjectStore.hx" extern="1">
		<name public="1" set="null"><c path="String"/></name>
		<keyPath public="1" set="null"><d/></keyPath>
		<indexNames public="1" set="null"><c path="js.html.DOMStringList"/></indexNames>
		<transaction public="1" set="null"><c path="js.html.idb.Transaction"/></transaction>
		<autoIncrement public="1" set="null"><x path="Bool"/></autoIncrement>
		<put public="1" set="method">
			<f a="value:?key">
				<d/>
				<d/>
				<c path="js.html.idb.Request"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</put>
		<add public="1" set="method">
			<f a="value:?key">
				<d/>
				<d/>
				<c path="js.html.idb.Request"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</add>
		<delete_ public="1" set="method">
			<f a="key">
				<d/>
				<c path="js.html.idb.Request"/>
			</f>
			<meta><m n=":native"><e>"delete"</e></m></meta>
			<haxe_doc>@throws DOMError</haxe_doc>
		</delete_>
		<get public="1" set="method">
			<f a="key">
				<d/>
				<c path="js.html.idb.Request"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</get>
		<clear public="1" set="method">
			<f a=""><c path="js.html.idb.Request"/></f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</clear>
		<openCursor public="1" set="method">
			<f a="?range:?direction" v=":&quot;next&quot;">
				<d/>
				<x path="js.html.idb.CursorDirection"/>
				<c path="js.html.idb.Request"/>
			</f>
			<meta><m n=":value"><e>{direction:"next"}</e></m></meta>
			<haxe_doc>@throws DOMError</haxe_doc>
		</openCursor>
		<createIndex public="1" set="method">
			<f a="name:keyPath:?optionalParameters">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
				<t path="js.html.idb.IndexParameters"/>
				<c path="js.html.idb.Index"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
			<overloads><createIndex public="1" set="method">
	<f a="name:keyPath:?optionalParameters">
		<c path="String"/>
		<c path="String"/>
		<t path="js.html.idb.IndexParameters"/>
		<c path="js.html.idb.Index"/>
	</f>
	<haxe_doc>@throws DOMError</haxe_doc>
</createIndex></overloads>
		</createIndex>
		<index public="1" set="method">
			<f a="name">
				<c path="String"/>
				<c path="js.html.idb.Index"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</index>
		<deleteIndex public="1" set="method">
			<f a="indexName">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</deleteIndex>
		<count public="1" set="method">
			<f a="?key">
				<d/>
				<c path="js.html.idb.Request"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</count>
		<meta><m n=":native"><e>"IDBObjectStore"</e></m></meta>
	</class>
	<typedef path="js.html.idb.ObjectStoreParameters" params="" file="C:\HaxeToolkit\haxe\std/js/html/idb/ObjectStoreParameters.hx"><a>
	<keyPath>
		<t path="Null"><x path="haxe.extern.EitherType">
	<c path="String"/>
	<c path="Array"><c path="String"/></c>
</x></t>
		<meta><m n=":optional"/></meta>
	</keyPath>
	<autoIncrement>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</autoIncrement>
</a></typedef>
	<typedef path="js.html.idb.OpenDBOptions" params="" file="C:\HaxeToolkit\haxe\std/js/html/idb/OpenDBOptions.hx"><a>
	<version>
		<t path="Null"><x path="Int"/></t>
		<meta><m n=":optional"/></meta>
	</version>
	<storage>
		<t path="Null"><d/></t>
		<meta><m n=":optional"/></meta>
	</storage>
</a></typedef>
	<class path="js.html.idb.Request" params="" file="C:\HaxeToolkit\haxe\std/js/html/idb/Request.hx" extern="1">
		<extends path="js.html.EventTarget"/>
		<result public="1" set="null"><d/></result>
		<error public="1" set="null"><c path="js.html.DOMError"/></error>
		<source public="1" set="null"><x path="haxe.extern.EitherType">
	<c path="js.html.idb.ObjectStore"/>
	<x path="haxe.extern.EitherType">
		<c path="js.html.idb.Index"/>
		<c path="js.html.idb.Cursor"/>
	</x>
</x></source>
		<transaction public="1" set="null"><c path="js.html.idb.Transaction"/></transaction>
		<readyState public="1" set="null"><x path="js.html.idb.RequestReadyState"/></readyState>
		<onsuccess public="1"><x path="haxe.Function"/></onsuccess>
		<onerror public="1"><x path="haxe.Function"/></onerror>
		<meta><m n=":native"><e>"IDBRequest"</e></m></meta>
	</class>
	<class path="js.html.idb.OpenDBRequest" params="" file="C:\HaxeToolkit\haxe\std/js/html/idb/OpenDBRequest.hx" extern="1">
		<extends path="js.html.idb.Request"/>
		<onblocked public="1"><x path="haxe.Function"/></onblocked>
		<onupgradeneeded public="1"><x path="haxe.Function"/></onupgradeneeded>
		<meta><m n=":native"><e>"IDBOpenDBRequest"</e></m></meta>
	</class>
	<abstract path="js.html.idb.RequestReadyState" params="" file="C:\HaxeToolkit\haxe\std/js/html/idb/RequestReadyState.hx">
		<this><c path="String"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="js.html.idb._RequestReadyState.RequestReadyState_Impl_" params="" file="C:\HaxeToolkit\haxe\std/js/html/idb/RequestReadyState.hx" private="1" module="js.html.idb.RequestReadyState"><meta>
	<m n=":keep"/>
	<m n=":enum"/>
</meta></class></impl>
	</abstract>
	<class path="js.html.idb.Transaction" params="" file="C:\HaxeToolkit\haxe\std/js/html/idb/Transaction.hx" extern="1">
		<extends path="js.html.EventTarget"/>
		<mode public="1" set="null"><x path="js.html.idb.TransactionMode"/></mode>
		<db public="1" set="null"><c path="js.html.idb.Database"/></db>
		<error public="1" set="null"><c path="js.html.DOMError"/></error>
		<onabort public="1"><x path="haxe.Function"/></onabort>
		<oncomplete public="1"><x path="haxe.Function"/></oncomplete>
		<onerror public="1"><x path="haxe.Function"/></onerror>
		<objectStoreNames public="1" set="null"><c path="js.html.DOMStringList"/></objectStoreNames>
		<objectStore public="1" set="method">
			<f a="name">
				<c path="String"/>
				<c path="js.html.idb.ObjectStore"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</objectStore>
		<abort public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</abort>
		<meta><m n=":native"><e>"IDBTransaction"</e></m></meta>
	</class>
	<abstract path="js.html.idb.TransactionMode" params="" file="C:\HaxeToolkit\haxe\std/js/html/idb/TransactionMode.hx">
		<this><c path="String"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="js.html.idb._TransactionMode.TransactionMode_Impl_" params="" file="C:\HaxeToolkit\haxe\std/js/html/idb/TransactionMode.hx" private="1" module="js.html.idb.TransactionMode"><meta>
	<m n=":keep"/>
	<m n=":enum"/>
</meta></class></impl>
	</abstract>
	<class path="js.html.svg.Matrix" params="" file="C:\HaxeToolkit\haxe\std/js/html/svg/Matrix.hx" extern="1">
		<a public="1"><x path="Float"/></a>
		<b public="1"><x path="Float"/></b>
		<c public="1"><x path="Float"/></c>
		<d public="1"><x path="Float"/></d>
		<e public="1"><x path="Float"/></e>
		<f public="1"><x path="Float"/></f>
		<multiply public="1" set="method"><f a="secondMatrix">
	<c path="js.html.svg.Matrix"/>
	<c path="js.html.svg.Matrix"/>
</f></multiply>
		<inverse public="1" set="method">
			<f a=""><c path="js.html.svg.Matrix"/></f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</inverse>
		<translate public="1" set="method"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<c path="js.html.svg.Matrix"/>
</f></translate>
		<scale public="1" set="method"><f a="scaleFactor">
	<x path="Float"/>
	<c path="js.html.svg.Matrix"/>
</f></scale>
		<scaleNonUniform public="1" set="method"><f a="scaleFactorX:scaleFactorY">
	<x path="Float"/>
	<x path="Float"/>
	<c path="js.html.svg.Matrix"/>
</f></scaleNonUniform>
		<rotate public="1" set="method"><f a="angle">
	<x path="Float"/>
	<c path="js.html.svg.Matrix"/>
</f></rotate>
		<rotateFromVector public="1" set="method">
			<f a="x:y">
				<x path="Float"/>
				<x path="Float"/>
				<c path="js.html.svg.Matrix"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</rotateFromVector>
		<flipX public="1" set="method"><f a=""><c path="js.html.svg.Matrix"/></f></flipX>
		<flipY public="1" set="method"><f a=""><c path="js.html.svg.Matrix"/></f></flipY>
		<skewX public="1" set="method">
			<f a="angle">
				<x path="Float"/>
				<c path="js.html.svg.Matrix"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</skewX>
		<skewY public="1" set="method">
			<f a="angle">
				<x path="Float"/>
				<c path="js.html.svg.Matrix"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</skewY>
		<meta><m n=":native"><e>"SVGMatrix"</e></m></meta>
	</class>
	<class path="js.html.webgl.ActiveInfo" params="" file="C:\HaxeToolkit\haxe\std/js/html/webgl/ActiveInfo.hx" extern="1">
		<size public="1" set="null"><x path="Int"/></size>
		<type public="1" set="null"><x path="Int"/></type>
		<name public="1" set="null"><c path="String"/></name>
		<meta><m n=":native"><e>"WebGLActiveInfo"</e></m></meta>
	</class>
	<class path="js.html.webgl.Buffer" params="" file="C:\HaxeToolkit\haxe\std/js/html/webgl/Buffer.hx" extern="1"><meta><m n=":native"><e>"WebGLBuffer"</e></m></meta></class>
	<typedef path="js.html.webgl.ContextAttributes" params="" file="C:\HaxeToolkit\haxe\std/js/html/webgl/ContextAttributes.hx"><a>
	<stencil>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</stencil>
	<preserveDrawingBuffer>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</preserveDrawingBuffer>
	<premultipliedAlpha>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</premultipliedAlpha>
	<depth>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</depth>
	<antialias>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</antialias>
	<alpha>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</alpha>
</a></typedef>
	<class path="js.html.webgl.Framebuffer" params="" file="C:\HaxeToolkit\haxe\std/js/html/webgl/Framebuffer.hx" extern="1"><meta><m n=":native"><e>"WebGLFramebuffer"</e></m></meta></class>
	<class path="js.html.webgl.Program" params="" file="C:\HaxeToolkit\haxe\std/js/html/webgl/Program.hx" extern="1"><meta><m n=":native"><e>"WebGLProgram"</e></m></meta></class>
	<class path="js.html.webgl.Renderbuffer" params="" file="C:\HaxeToolkit\haxe\std/js/html/webgl/Renderbuffer.hx" extern="1"><meta><m n=":native"><e>"WebGLRenderbuffer"</e></m></meta></class>
	<class path="js.html.webgl.RenderingContext" params="" file="C:\HaxeToolkit\haxe\std/js/html/webgl/RenderingContext.hx" extern="1">
		<DEPTH_BUFFER_BIT public="1" get="inline" set="null" expr="256" line="30" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>256</e></m></meta>
		</DEPTH_BUFFER_BIT>
		<STENCIL_BUFFER_BIT public="1" get="inline" set="null" expr="1024" line="31" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1024</e></m></meta>
		</STENCIL_BUFFER_BIT>
		<COLOR_BUFFER_BIT public="1" get="inline" set="null" expr="16384" line="32" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>16384</e></m></meta>
		</COLOR_BUFFER_BIT>
		<POINTS public="1" get="inline" set="null" expr="0" line="33" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</POINTS>
		<LINES public="1" get="inline" set="null" expr="1" line="34" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</LINES>
		<LINE_LOOP public="1" get="inline" set="null" expr="2" line="35" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2</e></m></meta>
		</LINE_LOOP>
		<LINE_STRIP public="1" get="inline" set="null" expr="3" line="36" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3</e></m></meta>
		</LINE_STRIP>
		<TRIANGLES public="1" get="inline" set="null" expr="4" line="37" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>4</e></m></meta>
		</TRIANGLES>
		<TRIANGLE_STRIP public="1" get="inline" set="null" expr="5" line="38" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>5</e></m></meta>
		</TRIANGLE_STRIP>
		<TRIANGLE_FAN public="1" get="inline" set="null" expr="6" line="39" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>6</e></m></meta>
		</TRIANGLE_FAN>
		<ZERO public="1" get="inline" set="null" expr="0" line="40" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</ZERO>
		<ONE public="1" get="inline" set="null" expr="1" line="41" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</ONE>
		<SRC_COLOR public="1" get="inline" set="null" expr="768" line="42" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>768</e></m></meta>
		</SRC_COLOR>
		<ONE_MINUS_SRC_COLOR public="1" get="inline" set="null" expr="769" line="43" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>769</e></m></meta>
		</ONE_MINUS_SRC_COLOR>
		<SRC_ALPHA public="1" get="inline" set="null" expr="770" line="44" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>770</e></m></meta>
		</SRC_ALPHA>
		<ONE_MINUS_SRC_ALPHA public="1" get="inline" set="null" expr="771" line="45" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>771</e></m></meta>
		</ONE_MINUS_SRC_ALPHA>
		<DST_ALPHA public="1" get="inline" set="null" expr="772" line="46" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>772</e></m></meta>
		</DST_ALPHA>
		<ONE_MINUS_DST_ALPHA public="1" get="inline" set="null" expr="773" line="47" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>773</e></m></meta>
		</ONE_MINUS_DST_ALPHA>
		<DST_COLOR public="1" get="inline" set="null" expr="774" line="48" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>774</e></m></meta>
		</DST_COLOR>
		<ONE_MINUS_DST_COLOR public="1" get="inline" set="null" expr="775" line="49" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>775</e></m></meta>
		</ONE_MINUS_DST_COLOR>
		<SRC_ALPHA_SATURATE public="1" get="inline" set="null" expr="776" line="50" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>776</e></m></meta>
		</SRC_ALPHA_SATURATE>
		<FUNC_ADD public="1" get="inline" set="null" expr="32774" line="51" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>32774</e></m></meta>
		</FUNC_ADD>
		<BLEND_EQUATION public="1" get="inline" set="null" expr="32777" line="52" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>32777</e></m></meta>
		</BLEND_EQUATION>
		<BLEND_EQUATION_RGB public="1" get="inline" set="null" expr="32777" line="53" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>32777</e></m></meta>
		</BLEND_EQUATION_RGB>
		<BLEND_EQUATION_ALPHA public="1" get="inline" set="null" expr="34877" line="54" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>34877</e></m></meta>
		</BLEND_EQUATION_ALPHA>
		<FUNC_SUBTRACT public="1" get="inline" set="null" expr="32778" line="55" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>32778</e></m></meta>
		</FUNC_SUBTRACT>
		<FUNC_REVERSE_SUBTRACT public="1" get="inline" set="null" expr="32779" line="56" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>32779</e></m></meta>
		</FUNC_REVERSE_SUBTRACT>
		<BLEND_DST_RGB public="1" get="inline" set="null" expr="32968" line="57" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>32968</e></m></meta>
		</BLEND_DST_RGB>
		<BLEND_SRC_RGB public="1" get="inline" set="null" expr="32969" line="58" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>32969</e></m></meta>
		</BLEND_SRC_RGB>
		<BLEND_DST_ALPHA public="1" get="inline" set="null" expr="32970" line="59" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>32970</e></m></meta>
		</BLEND_DST_ALPHA>
		<BLEND_SRC_ALPHA public="1" get="inline" set="null" expr="32971" line="60" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>32971</e></m></meta>
		</BLEND_SRC_ALPHA>
		<CONSTANT_COLOR public="1" get="inline" set="null" expr="32769" line="61" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>32769</e></m></meta>
		</CONSTANT_COLOR>
		<ONE_MINUS_CONSTANT_COLOR public="1" get="inline" set="null" expr="32770" line="62" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>32770</e></m></meta>
		</ONE_MINUS_CONSTANT_COLOR>
		<CONSTANT_ALPHA public="1" get="inline" set="null" expr="32771" line="63" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>32771</e></m></meta>
		</CONSTANT_ALPHA>
		<ONE_MINUS_CONSTANT_ALPHA public="1" get="inline" set="null" expr="32772" line="64" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>32772</e></m></meta>
		</ONE_MINUS_CONSTANT_ALPHA>
		<BLEND_COLOR public="1" get="inline" set="null" expr="32773" line="65" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>32773</e></m></meta>
		</BLEND_COLOR>
		<ARRAY_BUFFER public="1" get="inline" set="null" expr="34962" line="66" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>34962</e></m></meta>
		</ARRAY_BUFFER>
		<ELEMENT_ARRAY_BUFFER public="1" get="inline" set="null" expr="34963" line="67" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>34963</e></m></meta>
		</ELEMENT_ARRAY_BUFFER>
		<ARRAY_BUFFER_BINDING public="1" get="inline" set="null" expr="34964" line="68" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>34964</e></m></meta>
		</ARRAY_BUFFER_BINDING>
		<ELEMENT_ARRAY_BUFFER_BINDING public="1" get="inline" set="null" expr="34965" line="69" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>34965</e></m></meta>
		</ELEMENT_ARRAY_BUFFER_BINDING>
		<STREAM_DRAW public="1" get="inline" set="null" expr="35040" line="70" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>35040</e></m></meta>
		</STREAM_DRAW>
		<STATIC_DRAW public="1" get="inline" set="null" expr="35044" line="71" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>35044</e></m></meta>
		</STATIC_DRAW>
		<DYNAMIC_DRAW public="1" get="inline" set="null" expr="35048" line="72" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>35048</e></m></meta>
		</DYNAMIC_DRAW>
		<BUFFER_SIZE public="1" get="inline" set="null" expr="34660" line="73" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>34660</e></m></meta>
		</BUFFER_SIZE>
		<BUFFER_USAGE public="1" get="inline" set="null" expr="34661" line="74" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>34661</e></m></meta>
		</BUFFER_USAGE>
		<CURRENT_VERTEX_ATTRIB public="1" get="inline" set="null" expr="34342" line="75" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>34342</e></m></meta>
		</CURRENT_VERTEX_ATTRIB>
		<FRONT public="1" get="inline" set="null" expr="1028" line="76" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1028</e></m></meta>
		</FRONT>
		<BACK public="1" get="inline" set="null" expr="1029" line="77" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1029</e></m></meta>
		</BACK>
		<FRONT_AND_BACK public="1" get="inline" set="null" expr="1032" line="78" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1032</e></m></meta>
		</FRONT_AND_BACK>
		<CULL_FACE public="1" get="inline" set="null" expr="2884" line="79" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2884</e></m></meta>
		</CULL_FACE>
		<BLEND public="1" get="inline" set="null" expr="3042" line="80" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3042</e></m></meta>
		</BLEND>
		<DITHER public="1" get="inline" set="null" expr="3024" line="81" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3024</e></m></meta>
		</DITHER>
		<STENCIL_TEST public="1" get="inline" set="null" expr="2960" line="82" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2960</e></m></meta>
		</STENCIL_TEST>
		<DEPTH_TEST public="1" get="inline" set="null" expr="2929" line="83" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2929</e></m></meta>
		</DEPTH_TEST>
		<SCISSOR_TEST public="1" get="inline" set="null" expr="3089" line="84" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3089</e></m></meta>
		</SCISSOR_TEST>
		<POLYGON_OFFSET_FILL public="1" get="inline" set="null" expr="32823" line="85" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>32823</e></m></meta>
		</POLYGON_OFFSET_FILL>
		<SAMPLE_ALPHA_TO_COVERAGE public="1" get="inline" set="null" expr="32926" line="86" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>32926</e></m></meta>
		</SAMPLE_ALPHA_TO_COVERAGE>
		<SAMPLE_COVERAGE public="1" get="inline" set="null" expr="32928" line="87" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>32928</e></m></meta>
		</SAMPLE_COVERAGE>
		<NO_ERROR public="1" get="inline" set="null" expr="0" line="88" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</NO_ERROR>
		<INVALID_ENUM public="1" get="inline" set="null" expr="1280" line="89" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1280</e></m></meta>
		</INVALID_ENUM>
		<INVALID_VALUE public="1" get="inline" set="null" expr="1281" line="90" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1281</e></m></meta>
		</INVALID_VALUE>
		<INVALID_OPERATION public="1" get="inline" set="null" expr="1282" line="91" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1282</e></m></meta>
		</INVALID_OPERATION>
		<OUT_OF_MEMORY public="1" get="inline" set="null" expr="1285" line="92" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1285</e></m></meta>
		</OUT_OF_MEMORY>
		<CW public="1" get="inline" set="null" expr="2304" line="93" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2304</e></m></meta>
		</CW>
		<CCW public="1" get="inline" set="null" expr="2305" line="94" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2305</e></m></meta>
		</CCW>
		<LINE_WIDTH public="1" get="inline" set="null" expr="2849" line="95" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2849</e></m></meta>
		</LINE_WIDTH>
		<ALIASED_POINT_SIZE_RANGE public="1" get="inline" set="null" expr="33901" line="96" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>33901</e></m></meta>
		</ALIASED_POINT_SIZE_RANGE>
		<ALIASED_LINE_WIDTH_RANGE public="1" get="inline" set="null" expr="33902" line="97" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>33902</e></m></meta>
		</ALIASED_LINE_WIDTH_RANGE>
		<CULL_FACE_MODE public="1" get="inline" set="null" expr="2885" line="98" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2885</e></m></meta>
		</CULL_FACE_MODE>
		<FRONT_FACE public="1" get="inline" set="null" expr="2886" line="99" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2886</e></m></meta>
		</FRONT_FACE>
		<DEPTH_RANGE public="1" get="inline" set="null" expr="2928" line="100" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2928</e></m></meta>
		</DEPTH_RANGE>
		<DEPTH_WRITEMASK public="1" get="inline" set="null" expr="2930" line="101" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2930</e></m></meta>
		</DEPTH_WRITEMASK>
		<DEPTH_CLEAR_VALUE public="1" get="inline" set="null" expr="2931" line="102" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2931</e></m></meta>
		</DEPTH_CLEAR_VALUE>
		<DEPTH_FUNC public="1" get="inline" set="null" expr="2932" line="103" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2932</e></m></meta>
		</DEPTH_FUNC>
		<STENCIL_CLEAR_VALUE public="1" get="inline" set="null" expr="2961" line="104" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2961</e></m></meta>
		</STENCIL_CLEAR_VALUE>
		<STENCIL_FUNC public="1" get="inline" set="null" expr="2962" line="105" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2962</e></m></meta>
		</STENCIL_FUNC>
		<STENCIL_FAIL public="1" get="inline" set="null" expr="2964" line="106" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2964</e></m></meta>
		</STENCIL_FAIL>
		<STENCIL_PASS_DEPTH_FAIL public="1" get="inline" set="null" expr="2965" line="107" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2965</e></m></meta>
		</STENCIL_PASS_DEPTH_FAIL>
		<STENCIL_PASS_DEPTH_PASS public="1" get="inline" set="null" expr="2966" line="108" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2966</e></m></meta>
		</STENCIL_PASS_DEPTH_PASS>
		<STENCIL_REF public="1" get="inline" set="null" expr="2967" line="109" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2967</e></m></meta>
		</STENCIL_REF>
		<STENCIL_VALUE_MASK public="1" get="inline" set="null" expr="2963" line="110" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2963</e></m></meta>
		</STENCIL_VALUE_MASK>
		<STENCIL_WRITEMASK public="1" get="inline" set="null" expr="2968" line="111" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2968</e></m></meta>
		</STENCIL_WRITEMASK>
		<STENCIL_BACK_FUNC public="1" get="inline" set="null" expr="34816" line="112" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>34816</e></m></meta>
		</STENCIL_BACK_FUNC>
		<STENCIL_BACK_FAIL public="1" get="inline" set="null" expr="34817" line="113" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>34817</e></m></meta>
		</STENCIL_BACK_FAIL>
		<STENCIL_BACK_PASS_DEPTH_FAIL public="1" get="inline" set="null" expr="34818" line="114" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>34818</e></m></meta>
		</STENCIL_BACK_PASS_DEPTH_FAIL>
		<STENCIL_BACK_PASS_DEPTH_PASS public="1" get="inline" set="null" expr="34819" line="115" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>34819</e></m></meta>
		</STENCIL_BACK_PASS_DEPTH_PASS>
		<STENCIL_BACK_REF public="1" get="inline" set="null" expr="36003" line="116" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>36003</e></m></meta>
		</STENCIL_BACK_REF>
		<STENCIL_BACK_VALUE_MASK public="1" get="inline" set="null" expr="36004" line="117" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>36004</e></m></meta>
		</STENCIL_BACK_VALUE_MASK>
		<STENCIL_BACK_WRITEMASK public="1" get="inline" set="null" expr="36005" line="118" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>36005</e></m></meta>
		</STENCIL_BACK_WRITEMASK>
		<VIEWPORT public="1" get="inline" set="null" expr="2978" line="119" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2978</e></m></meta>
		</VIEWPORT>
		<SCISSOR_BOX public="1" get="inline" set="null" expr="3088" line="120" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3088</e></m></meta>
		</SCISSOR_BOX>
		<COLOR_CLEAR_VALUE public="1" get="inline" set="null" expr="3106" line="121" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3106</e></m></meta>
		</COLOR_CLEAR_VALUE>
		<COLOR_WRITEMASK public="1" get="inline" set="null" expr="3107" line="122" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3107</e></m></meta>
		</COLOR_WRITEMASK>
		<UNPACK_ALIGNMENT public="1" get="inline" set="null" expr="3317" line="123" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3317</e></m></meta>
		</UNPACK_ALIGNMENT>
		<PACK_ALIGNMENT public="1" get="inline" set="null" expr="3333" line="124" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3333</e></m></meta>
		</PACK_ALIGNMENT>
		<MAX_TEXTURE_SIZE public="1" get="inline" set="null" expr="3379" line="125" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3379</e></m></meta>
		</MAX_TEXTURE_SIZE>
		<MAX_VIEWPORT_DIMS public="1" get="inline" set="null" expr="3386" line="126" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3386</e></m></meta>
		</MAX_VIEWPORT_DIMS>
		<SUBPIXEL_BITS public="1" get="inline" set="null" expr="3408" line="127" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3408</e></m></meta>
		</SUBPIXEL_BITS>
		<RED_BITS public="1" get="inline" set="null" expr="3410" line="128" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3410</e></m></meta>
		</RED_BITS>
		<GREEN_BITS public="1" get="inline" set="null" expr="3411" line="129" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3411</e></m></meta>
		</GREEN_BITS>
		<BLUE_BITS public="1" get="inline" set="null" expr="3412" line="130" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3412</e></m></meta>
		</BLUE_BITS>
		<ALPHA_BITS public="1" get="inline" set="null" expr="3413" line="131" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3413</e></m></meta>
		</ALPHA_BITS>
		<DEPTH_BITS public="1" get="inline" set="null" expr="3414" line="132" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3414</e></m></meta>
		</DEPTH_BITS>
		<STENCIL_BITS public="1" get="inline" set="null" expr="3415" line="133" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3415</e></m></meta>
		</STENCIL_BITS>
		<POLYGON_OFFSET_UNITS public="1" get="inline" set="null" expr="10752" line="134" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>10752</e></m></meta>
		</POLYGON_OFFSET_UNITS>
		<POLYGON_OFFSET_FACTOR public="1" get="inline" set="null" expr="32824" line="135" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>32824</e></m></meta>
		</POLYGON_OFFSET_FACTOR>
		<TEXTURE_BINDING_2D public="1" get="inline" set="null" expr="32873" line="136" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>32873</e></m></meta>
		</TEXTURE_BINDING_2D>
		<SAMPLE_BUFFERS public="1" get="inline" set="null" expr="32936" line="137" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>32936</e></m></meta>
		</SAMPLE_BUFFERS>
		<SAMPLES public="1" get="inline" set="null" expr="32937" line="138" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>32937</e></m></meta>
		</SAMPLES>
		<SAMPLE_COVERAGE_VALUE public="1" get="inline" set="null" expr="32938" line="139" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>32938</e></m></meta>
		</SAMPLE_COVERAGE_VALUE>
		<SAMPLE_COVERAGE_INVERT public="1" get="inline" set="null" expr="32939" line="140" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>32939</e></m></meta>
		</SAMPLE_COVERAGE_INVERT>
		<COMPRESSED_TEXTURE_FORMATS public="1" get="inline" set="null" expr="34467" line="141" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>34467</e></m></meta>
		</COMPRESSED_TEXTURE_FORMATS>
		<DONT_CARE public="1" get="inline" set="null" expr="4352" line="142" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>4352</e></m></meta>
		</DONT_CARE>
		<FASTEST public="1" get="inline" set="null" expr="4353" line="143" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>4353</e></m></meta>
		</FASTEST>
		<NICEST public="1" get="inline" set="null" expr="4354" line="144" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>4354</e></m></meta>
		</NICEST>
		<GENERATE_MIPMAP_HINT public="1" get="inline" set="null" expr="33170" line="145" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>33170</e></m></meta>
		</GENERATE_MIPMAP_HINT>
		<BYTE public="1" get="inline" set="null" expr="5120" line="146" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>5120</e></m></meta>
		</BYTE>
		<UNSIGNED_BYTE public="1" get="inline" set="null" expr="5121" line="147" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>5121</e></m></meta>
		</UNSIGNED_BYTE>
		<SHORT public="1" get="inline" set="null" expr="5122" line="148" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>5122</e></m></meta>
		</SHORT>
		<UNSIGNED_SHORT public="1" get="inline" set="null" expr="5123" line="149" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>5123</e></m></meta>
		</UNSIGNED_SHORT>
		<INT public="1" get="inline" set="null" expr="5124" line="150" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>5124</e></m></meta>
		</INT>
		<UNSIGNED_INT public="1" get="inline" set="null" expr="5125" line="151" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>5125</e></m></meta>
		</UNSIGNED_INT>
		<FLOAT public="1" get="inline" set="null" expr="5126" line="152" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>5126</e></m></meta>
		</FLOAT>
		<DEPTH_COMPONENT public="1" get="inline" set="null" expr="6402" line="153" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>6402</e></m></meta>
		</DEPTH_COMPONENT>
		<ALPHA public="1" get="inline" set="null" expr="6406" line="154" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>6406</e></m></meta>
		</ALPHA>
		<RGB public="1" get="inline" set="null" expr="6407" line="155" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>6407</e></m></meta>
		</RGB>
		<RGBA public="1" get="inline" set="null" expr="6408" line="156" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>6408</e></m></meta>
		</RGBA>
		<LUMINANCE public="1" get="inline" set="null" expr="6409" line="157" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>6409</e></m></meta>
		</LUMINANCE>
		<LUMINANCE_ALPHA public="1" get="inline" set="null" expr="6410" line="158" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>6410</e></m></meta>
		</LUMINANCE_ALPHA>
		<UNSIGNED_SHORT_4_4_4_4 public="1" get="inline" set="null" expr="32819" line="159" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>32819</e></m></meta>
		</UNSIGNED_SHORT_4_4_4_4>
		<UNSIGNED_SHORT_5_5_5_1 public="1" get="inline" set="null" expr="32820" line="160" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>32820</e></m></meta>
		</UNSIGNED_SHORT_5_5_5_1>
		<UNSIGNED_SHORT_5_6_5 public="1" get="inline" set="null" expr="33635" line="161" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>33635</e></m></meta>
		</UNSIGNED_SHORT_5_6_5>
		<FRAGMENT_SHADER public="1" get="inline" set="null" expr="35632" line="162" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>35632</e></m></meta>
		</FRAGMENT_SHADER>
		<VERTEX_SHADER public="1" get="inline" set="null" expr="35633" line="163" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>35633</e></m></meta>
		</VERTEX_SHADER>
		<MAX_VERTEX_ATTRIBS public="1" get="inline" set="null" expr="34921" line="164" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>34921</e></m></meta>
		</MAX_VERTEX_ATTRIBS>
		<MAX_VERTEX_UNIFORM_VECTORS public="1" get="inline" set="null" expr="36347" line="165" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>36347</e></m></meta>
		</MAX_VERTEX_UNIFORM_VECTORS>
		<MAX_VARYING_VECTORS public="1" get="inline" set="null" expr="36348" line="166" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>36348</e></m></meta>
		</MAX_VARYING_VECTORS>
		<MAX_COMBINED_TEXTURE_IMAGE_UNITS public="1" get="inline" set="null" expr="35661" line="167" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>35661</e></m></meta>
		</MAX_COMBINED_TEXTURE_IMAGE_UNITS>
		<MAX_VERTEX_TEXTURE_IMAGE_UNITS public="1" get="inline" set="null" expr="35660" line="168" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>35660</e></m></meta>
		</MAX_VERTEX_TEXTURE_IMAGE_UNITS>
		<MAX_TEXTURE_IMAGE_UNITS public="1" get="inline" set="null" expr="34930" line="169" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>34930</e></m></meta>
		</MAX_TEXTURE_IMAGE_UNITS>
		<MAX_FRAGMENT_UNIFORM_VECTORS public="1" get="inline" set="null" expr="36349" line="170" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>36349</e></m></meta>
		</MAX_FRAGMENT_UNIFORM_VECTORS>
		<SHADER_TYPE public="1" get="inline" set="null" expr="35663" line="171" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>35663</e></m></meta>
		</SHADER_TYPE>
		<DELETE_STATUS public="1" get="inline" set="null" expr="35712" line="172" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>35712</e></m></meta>
		</DELETE_STATUS>
		<LINK_STATUS public="1" get="inline" set="null" expr="35714" line="173" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>35714</e></m></meta>
		</LINK_STATUS>
		<VALIDATE_STATUS public="1" get="inline" set="null" expr="35715" line="174" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>35715</e></m></meta>
		</VALIDATE_STATUS>
		<ATTACHED_SHADERS public="1" get="inline" set="null" expr="35717" line="175" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>35717</e></m></meta>
		</ATTACHED_SHADERS>
		<ACTIVE_UNIFORMS public="1" get="inline" set="null" expr="35718" line="176" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>35718</e></m></meta>
		</ACTIVE_UNIFORMS>
		<ACTIVE_ATTRIBUTES public="1" get="inline" set="null" expr="35721" line="177" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>35721</e></m></meta>
		</ACTIVE_ATTRIBUTES>
		<SHADING_LANGUAGE_VERSION public="1" get="inline" set="null" expr="35724" line="178" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>35724</e></m></meta>
		</SHADING_LANGUAGE_VERSION>
		<CURRENT_PROGRAM public="1" get="inline" set="null" expr="35725" line="179" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>35725</e></m></meta>
		</CURRENT_PROGRAM>
		<NEVER public="1" get="inline" set="null" expr="512" line="180" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>512</e></m></meta>
		</NEVER>
		<LESS public="1" get="inline" set="null" expr="513" line="181" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>513</e></m></meta>
		</LESS>
		<EQUAL public="1" get="inline" set="null" expr="514" line="182" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>514</e></m></meta>
		</EQUAL>
		<LEQUAL public="1" get="inline" set="null" expr="515" line="183" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>515</e></m></meta>
		</LEQUAL>
		<GREATER public="1" get="inline" set="null" expr="516" line="184" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>516</e></m></meta>
		</GREATER>
		<NOTEQUAL public="1" get="inline" set="null" expr="517" line="185" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>517</e></m></meta>
		</NOTEQUAL>
		<GEQUAL public="1" get="inline" set="null" expr="518" line="186" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>518</e></m></meta>
		</GEQUAL>
		<ALWAYS public="1" get="inline" set="null" expr="519" line="187" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>519</e></m></meta>
		</ALWAYS>
		<KEEP public="1" get="inline" set="null" expr="7680" line="188" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>7680</e></m></meta>
		</KEEP>
		<REPLACE public="1" get="inline" set="null" expr="7681" line="189" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>7681</e></m></meta>
		</REPLACE>
		<INCR public="1" get="inline" set="null" expr="7682" line="190" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>7682</e></m></meta>
		</INCR>
		<DECR public="1" get="inline" set="null" expr="7683" line="191" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>7683</e></m></meta>
		</DECR>
		<INVERT public="1" get="inline" set="null" expr="5386" line="192" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>5386</e></m></meta>
		</INVERT>
		<INCR_WRAP public="1" get="inline" set="null" expr="34055" line="193" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>34055</e></m></meta>
		</INCR_WRAP>
		<DECR_WRAP public="1" get="inline" set="null" expr="34056" line="194" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>34056</e></m></meta>
		</DECR_WRAP>
		<VENDOR public="1" get="inline" set="null" expr="7936" line="195" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>7936</e></m></meta>
		</VENDOR>
		<RENDERER public="1" get="inline" set="null" expr="7937" line="196" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>7937</e></m></meta>
		</RENDERER>
		<VERSION public="1" get="inline" set="null" expr="7938" line="197" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>7938</e></m></meta>
		</VERSION>
		<NEAREST public="1" get="inline" set="null" expr="9728" line="198" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>9728</e></m></meta>
		</NEAREST>
		<LINEAR public="1" get="inline" set="null" expr="9729" line="199" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>9729</e></m></meta>
		</LINEAR>
		<NEAREST_MIPMAP_NEAREST public="1" get="inline" set="null" expr="9984" line="200" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>9984</e></m></meta>
		</NEAREST_MIPMAP_NEAREST>
		<LINEAR_MIPMAP_NEAREST public="1" get="inline" set="null" expr="9985" line="201" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>9985</e></m></meta>
		</LINEAR_MIPMAP_NEAREST>
		<NEAREST_MIPMAP_LINEAR public="1" get="inline" set="null" expr="9986" line="202" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>9986</e></m></meta>
		</NEAREST_MIPMAP_LINEAR>
		<LINEAR_MIPMAP_LINEAR public="1" get="inline" set="null" expr="9987" line="203" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>9987</e></m></meta>
		</LINEAR_MIPMAP_LINEAR>
		<TEXTURE_MAG_FILTER public="1" get="inline" set="null" expr="10240" line="204" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>10240</e></m></meta>
		</TEXTURE_MAG_FILTER>
		<TEXTURE_MIN_FILTER public="1" get="inline" set="null" expr="10241" line="205" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>10241</e></m></meta>
		</TEXTURE_MIN_FILTER>
		<TEXTURE_WRAP_S public="1" get="inline" set="null" expr="10242" line="206" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>10242</e></m></meta>
		</TEXTURE_WRAP_S>
		<TEXTURE_WRAP_T public="1" get="inline" set="null" expr="10243" line="207" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>10243</e></m></meta>
		</TEXTURE_WRAP_T>
		<TEXTURE_2D public="1" get="inline" set="null" expr="3553" line="208" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3553</e></m></meta>
		</TEXTURE_2D>
		<TEXTURE public="1" get="inline" set="null" expr="5890" line="209" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>5890</e></m></meta>
		</TEXTURE>
		<TEXTURE_CUBE_MAP public="1" get="inline" set="null" expr="34067" line="210" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>34067</e></m></meta>
		</TEXTURE_CUBE_MAP>
		<TEXTURE_BINDING_CUBE_MAP public="1" get="inline" set="null" expr="34068" line="211" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>34068</e></m></meta>
		</TEXTURE_BINDING_CUBE_MAP>
		<TEXTURE_CUBE_MAP_POSITIVE_X public="1" get="inline" set="null" expr="34069" line="212" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>34069</e></m></meta>
		</TEXTURE_CUBE_MAP_POSITIVE_X>
		<TEXTURE_CUBE_MAP_NEGATIVE_X public="1" get="inline" set="null" expr="34070" line="213" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>34070</e></m></meta>
		</TEXTURE_CUBE_MAP_NEGATIVE_X>
		<TEXTURE_CUBE_MAP_POSITIVE_Y public="1" get="inline" set="null" expr="34071" line="214" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>34071</e></m></meta>
		</TEXTURE_CUBE_MAP_POSITIVE_Y>
		<TEXTURE_CUBE_MAP_NEGATIVE_Y public="1" get="inline" set="null" expr="34072" line="215" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>34072</e></m></meta>
		</TEXTURE_CUBE_MAP_NEGATIVE_Y>
		<TEXTURE_CUBE_MAP_POSITIVE_Z public="1" get="inline" set="null" expr="34073" line="216" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>34073</e></m></meta>
		</TEXTURE_CUBE_MAP_POSITIVE_Z>
		<TEXTURE_CUBE_MAP_NEGATIVE_Z public="1" get="inline" set="null" expr="34074" line="217" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>34074</e></m></meta>
		</TEXTURE_CUBE_MAP_NEGATIVE_Z>
		<MAX_CUBE_MAP_TEXTURE_SIZE public="1" get="inline" set="null" expr="34076" line="218" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>34076</e></m></meta>
		</MAX_CUBE_MAP_TEXTURE_SIZE>
		<TEXTURE0 public="1" get="inline" set="null" expr="33984" line="219" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>33984</e></m></meta>
		</TEXTURE0>
		<TEXTURE1 public="1" get="inline" set="null" expr="33985" line="220" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>33985</e></m></meta>
		</TEXTURE1>
		<TEXTURE2 public="1" get="inline" set="null" expr="33986" line="221" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>33986</e></m></meta>
		</TEXTURE2>
		<TEXTURE3 public="1" get="inline" set="null" expr="33987" line="222" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>33987</e></m></meta>
		</TEXTURE3>
		<TEXTURE4 public="1" get="inline" set="null" expr="33988" line="223" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>33988</e></m></meta>
		</TEXTURE4>
		<TEXTURE5 public="1" get="inline" set="null" expr="33989" line="224" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>33989</e></m></meta>
		</TEXTURE5>
		<TEXTURE6 public="1" get="inline" set="null" expr="33990" line="225" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>33990</e></m></meta>
		</TEXTURE6>
		<TEXTURE7 public="1" get="inline" set="null" expr="33991" line="226" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>33991</e></m></meta>
		</TEXTURE7>
		<TEXTURE8 public="1" get="inline" set="null" expr="33992" line="227" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>33992</e></m></meta>
		</TEXTURE8>
		<TEXTURE9 public="1" get="inline" set="null" expr="33993" line="228" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>33993</e></m></meta>
		</TEXTURE9>
		<TEXTURE10 public="1" get="inline" set="null" expr="33994" line="229" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>33994</e></m></meta>
		</TEXTURE10>
		<TEXTURE11 public="1" get="inline" set="null" expr="33995" line="230" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>33995</e></m></meta>
		</TEXTURE11>
		<TEXTURE12 public="1" get="inline" set="null" expr="33996" line="231" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>33996</e></m></meta>
		</TEXTURE12>
		<TEXTURE13 public="1" get="inline" set="null" expr="33997" line="232" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>33997</e></m></meta>
		</TEXTURE13>
		<TEXTURE14 public="1" get="inline" set="null" expr="33998" line="233" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>33998</e></m></meta>
		</TEXTURE14>
		<TEXTURE15 public="1" get="inline" set="null" expr="33999" line="234" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>33999</e></m></meta>
		</TEXTURE15>
		<TEXTURE16 public="1" get="inline" set="null" expr="34000" line="235" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>34000</e></m></meta>
		</TEXTURE16>
		<TEXTURE17 public="1" get="inline" set="null" expr="34001" line="236" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>34001</e></m></meta>
		</TEXTURE17>
		<TEXTURE18 public="1" get="inline" set="null" expr="34002" line="237" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>34002</e></m></meta>
		</TEXTURE18>
		<TEXTURE19 public="1" get="inline" set="null" expr="34003" line="238" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>34003</e></m></meta>
		</TEXTURE19>
		<TEXTURE20 public="1" get="inline" set="null" expr="34004" line="239" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>34004</e></m></meta>
		</TEXTURE20>
		<TEXTURE21 public="1" get="inline" set="null" expr="34005" line="240" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>34005</e></m></meta>
		</TEXTURE21>
		<TEXTURE22 public="1" get="inline" set="null" expr="34006" line="241" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>34006</e></m></meta>
		</TEXTURE22>
		<TEXTURE23 public="1" get="inline" set="null" expr="34007" line="242" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>34007</e></m></meta>
		</TEXTURE23>
		<TEXTURE24 public="1" get="inline" set="null" expr="34008" line="243" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>34008</e></m></meta>
		</TEXTURE24>
		<TEXTURE25 public="1" get="inline" set="null" expr="34009" line="244" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>34009</e></m></meta>
		</TEXTURE25>
		<TEXTURE26 public="1" get="inline" set="null" expr="34010" line="245" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>34010</e></m></meta>
		</TEXTURE26>
		<TEXTURE27 public="1" get="inline" set="null" expr="34011" line="246" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>34011</e></m></meta>
		</TEXTURE27>
		<TEXTURE28 public="1" get="inline" set="null" expr="34012" line="247" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>34012</e></m></meta>
		</TEXTURE28>
		<TEXTURE29 public="1" get="inline" set="null" expr="34013" line="248" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>34013</e></m></meta>
		</TEXTURE29>
		<TEXTURE30 public="1" get="inline" set="null" expr="34014" line="249" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>34014</e></m></meta>
		</TEXTURE30>
		<TEXTURE31 public="1" get="inline" set="null" expr="34015" line="250" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>34015</e></m></meta>
		</TEXTURE31>
		<ACTIVE_TEXTURE public="1" get="inline" set="null" expr="34016" line="251" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>34016</e></m></meta>
		</ACTIVE_TEXTURE>
		<REPEAT public="1" get="inline" set="null" expr="10497" line="252" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>10497</e></m></meta>
		</REPEAT>
		<CLAMP_TO_EDGE public="1" get="inline" set="null" expr="33071" line="253" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>33071</e></m></meta>
		</CLAMP_TO_EDGE>
		<MIRRORED_REPEAT public="1" get="inline" set="null" expr="33648" line="254" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>33648</e></m></meta>
		</MIRRORED_REPEAT>
		<FLOAT_VEC2 public="1" get="inline" set="null" expr="35664" line="255" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>35664</e></m></meta>
		</FLOAT_VEC2>
		<FLOAT_VEC3 public="1" get="inline" set="null" expr="35665" line="256" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>35665</e></m></meta>
		</FLOAT_VEC3>
		<FLOAT_VEC4 public="1" get="inline" set="null" expr="35666" line="257" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>35666</e></m></meta>
		</FLOAT_VEC4>
		<INT_VEC2 public="1" get="inline" set="null" expr="35667" line="258" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>35667</e></m></meta>
		</INT_VEC2>
		<INT_VEC3 public="1" get="inline" set="null" expr="35668" line="259" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>35668</e></m></meta>
		</INT_VEC3>
		<INT_VEC4 public="1" get="inline" set="null" expr="35669" line="260" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>35669</e></m></meta>
		</INT_VEC4>
		<BOOL public="1" get="inline" set="null" expr="35670" line="261" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>35670</e></m></meta>
		</BOOL>
		<BOOL_VEC2 public="1" get="inline" set="null" expr="35671" line="262" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>35671</e></m></meta>
		</BOOL_VEC2>
		<BOOL_VEC3 public="1" get="inline" set="null" expr="35672" line="263" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>35672</e></m></meta>
		</BOOL_VEC3>
		<BOOL_VEC4 public="1" get="inline" set="null" expr="35673" line="264" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>35673</e></m></meta>
		</BOOL_VEC4>
		<FLOAT_MAT2 public="1" get="inline" set="null" expr="35674" line="265" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>35674</e></m></meta>
		</FLOAT_MAT2>
		<FLOAT_MAT3 public="1" get="inline" set="null" expr="35675" line="266" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>35675</e></m></meta>
		</FLOAT_MAT3>
		<FLOAT_MAT4 public="1" get="inline" set="null" expr="35676" line="267" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>35676</e></m></meta>
		</FLOAT_MAT4>
		<SAMPLER_2D public="1" get="inline" set="null" expr="35678" line="268" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>35678</e></m></meta>
		</SAMPLER_2D>
		<SAMPLER_CUBE public="1" get="inline" set="null" expr="35680" line="269" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>35680</e></m></meta>
		</SAMPLER_CUBE>
		<VERTEX_ATTRIB_ARRAY_ENABLED public="1" get="inline" set="null" expr="34338" line="270" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>34338</e></m></meta>
		</VERTEX_ATTRIB_ARRAY_ENABLED>
		<VERTEX_ATTRIB_ARRAY_SIZE public="1" get="inline" set="null" expr="34339" line="271" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>34339</e></m></meta>
		</VERTEX_ATTRIB_ARRAY_SIZE>
		<VERTEX_ATTRIB_ARRAY_STRIDE public="1" get="inline" set="null" expr="34340" line="272" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>34340</e></m></meta>
		</VERTEX_ATTRIB_ARRAY_STRIDE>
		<VERTEX_ATTRIB_ARRAY_TYPE public="1" get="inline" set="null" expr="34341" line="273" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>34341</e></m></meta>
		</VERTEX_ATTRIB_ARRAY_TYPE>
		<VERTEX_ATTRIB_ARRAY_NORMALIZED public="1" get="inline" set="null" expr="34922" line="274" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>34922</e></m></meta>
		</VERTEX_ATTRIB_ARRAY_NORMALIZED>
		<VERTEX_ATTRIB_ARRAY_POINTER public="1" get="inline" set="null" expr="34373" line="275" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>34373</e></m></meta>
		</VERTEX_ATTRIB_ARRAY_POINTER>
		<VERTEX_ATTRIB_ARRAY_BUFFER_BINDING public="1" get="inline" set="null" expr="34975" line="276" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>34975</e></m></meta>
		</VERTEX_ATTRIB_ARRAY_BUFFER_BINDING>
		<IMPLEMENTATION_COLOR_READ_TYPE public="1" get="inline" set="null" expr="35738" line="277" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>35738</e></m></meta>
		</IMPLEMENTATION_COLOR_READ_TYPE>
		<IMPLEMENTATION_COLOR_READ_FORMAT public="1" get="inline" set="null" expr="35739" line="278" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>35739</e></m></meta>
		</IMPLEMENTATION_COLOR_READ_FORMAT>
		<COMPILE_STATUS public="1" get="inline" set="null" expr="35713" line="279" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>35713</e></m></meta>
		</COMPILE_STATUS>
		<LOW_FLOAT public="1" get="inline" set="null" expr="36336" line="280" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>36336</e></m></meta>
		</LOW_FLOAT>
		<MEDIUM_FLOAT public="1" get="inline" set="null" expr="36337" line="281" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>36337</e></m></meta>
		</MEDIUM_FLOAT>
		<HIGH_FLOAT public="1" get="inline" set="null" expr="36338" line="282" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>36338</e></m></meta>
		</HIGH_FLOAT>
		<LOW_INT public="1" get="inline" set="null" expr="36339" line="283" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>36339</e></m></meta>
		</LOW_INT>
		<MEDIUM_INT public="1" get="inline" set="null" expr="36340" line="284" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>36340</e></m></meta>
		</MEDIUM_INT>
		<HIGH_INT public="1" get="inline" set="null" expr="36341" line="285" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>36341</e></m></meta>
		</HIGH_INT>
		<FRAMEBUFFER public="1" get="inline" set="null" expr="36160" line="286" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>36160</e></m></meta>
		</FRAMEBUFFER>
		<RENDERBUFFER public="1" get="inline" set="null" expr="36161" line="287" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>36161</e></m></meta>
		</RENDERBUFFER>
		<RGBA4 public="1" get="inline" set="null" expr="32854" line="288" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>32854</e></m></meta>
		</RGBA4>
		<RGB5_A1 public="1" get="inline" set="null" expr="32855" line="289" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>32855</e></m></meta>
		</RGB5_A1>
		<RGB565 public="1" get="inline" set="null" expr="36194" line="290" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>36194</e></m></meta>
		</RGB565>
		<DEPTH_COMPONENT16 public="1" get="inline" set="null" expr="33189" line="291" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>33189</e></m></meta>
		</DEPTH_COMPONENT16>
		<STENCIL_INDEX public="1" get="inline" set="null" expr="6401" line="292" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>6401</e></m></meta>
		</STENCIL_INDEX>
		<STENCIL_INDEX8 public="1" get="inline" set="null" expr="36168" line="293" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>36168</e></m></meta>
		</STENCIL_INDEX8>
		<DEPTH_STENCIL public="1" get="inline" set="null" expr="34041" line="294" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>34041</e></m></meta>
		</DEPTH_STENCIL>
		<RENDERBUFFER_WIDTH public="1" get="inline" set="null" expr="36162" line="295" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>36162</e></m></meta>
		</RENDERBUFFER_WIDTH>
		<RENDERBUFFER_HEIGHT public="1" get="inline" set="null" expr="36163" line="296" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>36163</e></m></meta>
		</RENDERBUFFER_HEIGHT>
		<RENDERBUFFER_INTERNAL_FORMAT public="1" get="inline" set="null" expr="36164" line="297" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>36164</e></m></meta>
		</RENDERBUFFER_INTERNAL_FORMAT>
		<RENDERBUFFER_RED_SIZE public="1" get="inline" set="null" expr="36176" line="298" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>36176</e></m></meta>
		</RENDERBUFFER_RED_SIZE>
		<RENDERBUFFER_GREEN_SIZE public="1" get="inline" set="null" expr="36177" line="299" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>36177</e></m></meta>
		</RENDERBUFFER_GREEN_SIZE>
		<RENDERBUFFER_BLUE_SIZE public="1" get="inline" set="null" expr="36178" line="300" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>36178</e></m></meta>
		</RENDERBUFFER_BLUE_SIZE>
		<RENDERBUFFER_ALPHA_SIZE public="1" get="inline" set="null" expr="36179" line="301" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>36179</e></m></meta>
		</RENDERBUFFER_ALPHA_SIZE>
		<RENDERBUFFER_DEPTH_SIZE public="1" get="inline" set="null" expr="36180" line="302" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>36180</e></m></meta>
		</RENDERBUFFER_DEPTH_SIZE>
		<RENDERBUFFER_STENCIL_SIZE public="1" get="inline" set="null" expr="36181" line="303" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>36181</e></m></meta>
		</RENDERBUFFER_STENCIL_SIZE>
		<FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE public="1" get="inline" set="null" expr="36048" line="304" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>36048</e></m></meta>
		</FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE>
		<FRAMEBUFFER_ATTACHMENT_OBJECT_NAME public="1" get="inline" set="null" expr="36049" line="305" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>36049</e></m></meta>
		</FRAMEBUFFER_ATTACHMENT_OBJECT_NAME>
		<FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL public="1" get="inline" set="null" expr="36050" line="306" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>36050</e></m></meta>
		</FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL>
		<FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE public="1" get="inline" set="null" expr="36051" line="307" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>36051</e></m></meta>
		</FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE>
		<COLOR_ATTACHMENT0 public="1" get="inline" set="null" expr="36064" line="308" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>36064</e></m></meta>
		</COLOR_ATTACHMENT0>
		<DEPTH_ATTACHMENT public="1" get="inline" set="null" expr="36096" line="309" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>36096</e></m></meta>
		</DEPTH_ATTACHMENT>
		<STENCIL_ATTACHMENT public="1" get="inline" set="null" expr="36128" line="310" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>36128</e></m></meta>
		</STENCIL_ATTACHMENT>
		<DEPTH_STENCIL_ATTACHMENT public="1" get="inline" set="null" expr="33306" line="311" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>33306</e></m></meta>
		</DEPTH_STENCIL_ATTACHMENT>
		<NONE public="1" get="inline" set="null" expr="0" line="312" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</NONE>
		<FRAMEBUFFER_COMPLETE public="1" get="inline" set="null" expr="36053" line="313" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>36053</e></m></meta>
		</FRAMEBUFFER_COMPLETE>
		<FRAMEBUFFER_INCOMPLETE_ATTACHMENT public="1" get="inline" set="null" expr="36054" line="314" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>36054</e></m></meta>
		</FRAMEBUFFER_INCOMPLETE_ATTACHMENT>
		<FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT public="1" get="inline" set="null" expr="36055" line="315" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>36055</e></m></meta>
		</FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT>
		<FRAMEBUFFER_INCOMPLETE_DIMENSIONS public="1" get="inline" set="null" expr="36057" line="316" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>36057</e></m></meta>
		</FRAMEBUFFER_INCOMPLETE_DIMENSIONS>
		<FRAMEBUFFER_UNSUPPORTED public="1" get="inline" set="null" expr="36061" line="317" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>36061</e></m></meta>
		</FRAMEBUFFER_UNSUPPORTED>
		<FRAMEBUFFER_BINDING public="1" get="inline" set="null" expr="36006" line="318" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>36006</e></m></meta>
		</FRAMEBUFFER_BINDING>
		<RENDERBUFFER_BINDING public="1" get="inline" set="null" expr="36007" line="319" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>36007</e></m></meta>
		</RENDERBUFFER_BINDING>
		<MAX_RENDERBUFFER_SIZE public="1" get="inline" set="null" expr="34024" line="320" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>34024</e></m></meta>
		</MAX_RENDERBUFFER_SIZE>
		<INVALID_FRAMEBUFFER_OPERATION public="1" get="inline" set="null" expr="1286" line="321" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1286</e></m></meta>
		</INVALID_FRAMEBUFFER_OPERATION>
		<UNPACK_FLIP_Y_WEBGL public="1" get="inline" set="null" expr="37440" line="322" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>37440</e></m></meta>
		</UNPACK_FLIP_Y_WEBGL>
		<UNPACK_PREMULTIPLY_ALPHA_WEBGL public="1" get="inline" set="null" expr="37441" line="323" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>37441</e></m></meta>
		</UNPACK_PREMULTIPLY_ALPHA_WEBGL>
		<CONTEXT_LOST_WEBGL public="1" get="inline" set="null" expr="37442" line="324" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>37442</e></m></meta>
		</CONTEXT_LOST_WEBGL>
		<UNPACK_COLORSPACE_CONVERSION_WEBGL public="1" get="inline" set="null" expr="37443" line="325" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>37443</e></m></meta>
		</UNPACK_COLORSPACE_CONVERSION_WEBGL>
		<BROWSER_DEFAULT_WEBGL public="1" get="inline" set="null" expr="37444" line="326" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>37444</e></m></meta>
		</BROWSER_DEFAULT_WEBGL>
		<canvas public="1" set="null"><c path="js.html.CanvasElement"/></canvas>
		<drawingBufferWidth public="1" set="null"><x path="Int"/></drawingBufferWidth>
		<drawingBufferHeight public="1" set="null"><x path="Int"/></drawingBufferHeight>
		<getContextAttributes public="1" set="method"><f a=""><t path="js.html.webgl.ContextAttributes"/></f></getContextAttributes>
		<isContextLost public="1" set="method"><f a=""><x path="Bool"/></f></isContextLost>
		<getSupportedExtensions public="1" set="method"><f a=""><c path="Array"><c path="String"/></c></f></getSupportedExtensions>
		<getExtension public="1" set="method">
			<f a="name">
				<c path="String"/>
				<d/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</getExtension>
		<activeTexture public="1" set="method"><f a="texture">
	<x path="Int"/>
	<x path="Void"/>
</f></activeTexture>
		<attachShader public="1" set="method"><f a="program:shader">
	<c path="js.html.webgl.Program"/>
	<c path="js.html.webgl.Shader"/>
	<x path="Void"/>
</f></attachShader>
		<bindAttribLocation public="1" set="method"><f a="program:index:name">
	<c path="js.html.webgl.Program"/>
	<x path="Int"/>
	<c path="String"/>
	<x path="Void"/>
</f></bindAttribLocation>
		<bindBuffer public="1" set="method"><f a="target:buffer">
	<x path="Int"/>
	<c path="js.html.webgl.Buffer"/>
	<x path="Void"/>
</f></bindBuffer>
		<bindFramebuffer public="1" set="method"><f a="target:framebuffer">
	<x path="Int"/>
	<c path="js.html.webgl.Framebuffer"/>
	<x path="Void"/>
</f></bindFramebuffer>
		<bindRenderbuffer public="1" set="method"><f a="target:renderbuffer">
	<x path="Int"/>
	<c path="js.html.webgl.Renderbuffer"/>
	<x path="Void"/>
</f></bindRenderbuffer>
		<bindTexture public="1" set="method"><f a="target:texture">
	<x path="Int"/>
	<c path="js.html.webgl.Texture"/>
	<x path="Void"/>
</f></bindTexture>
		<blendColor public="1" set="method"><f a="red:green:blue:alpha">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></blendColor>
		<blendEquation public="1" set="method"><f a="mode">
	<x path="Int"/>
	<x path="Void"/>
</f></blendEquation>
		<blendEquationSeparate public="1" set="method"><f a="modeRGB:modeAlpha">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></blendEquationSeparate>
		<blendFunc public="1" set="method"><f a="sfactor:dfactor">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></blendFunc>
		<blendFuncSeparate public="1" set="method"><f a="srcRGB:dstRGB:srcAlpha:dstAlpha">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></blendFuncSeparate>
		<bufferData public="1" set="method">
			<f a="target:data:usage">
				<x path="Int"/>
				<c path="js.html.ArrayBuffer"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<overloads>
				<bufferData public="1" set="method"><f a="target:size:usage">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></bufferData>
				<bufferData public="1" set="method"><f a="target:data:usage">
	<x path="Int"/>
	<c path="js.html.ArrayBufferView"/>
	<x path="Int"/>
	<x path="Void"/>
</f></bufferData>
			</overloads>
		</bufferData>
		<bufferSubData public="1" set="method">
			<f a="target:offset:data">
				<x path="Int"/>
				<x path="Int"/>
				<c path="js.html.ArrayBuffer"/>
				<x path="Void"/>
			</f>
			<overloads><bufferSubData public="1" set="method"><f a="target:offset:data">
	<x path="Int"/>
	<x path="Int"/>
	<c path="js.html.ArrayBufferView"/>
	<x path="Void"/>
</f></bufferSubData></overloads>
		</bufferSubData>
		<checkFramebufferStatus public="1" set="method"><f a="target">
	<x path="Int"/>
	<x path="Int"/>
</f></checkFramebufferStatus>
		<clear public="1" set="method"><f a="mask">
	<x path="Int"/>
	<x path="Void"/>
</f></clear>
		<clearColor public="1" set="method"><f a="red:green:blue:alpha">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></clearColor>
		<clearDepth public="1" set="method"><f a="depth">
	<x path="Float"/>
	<x path="Void"/>
</f></clearDepth>
		<clearStencil public="1" set="method"><f a="s">
	<x path="Int"/>
	<x path="Void"/>
</f></clearStencil>
		<colorMask public="1" set="method"><f a="red:green:blue:alpha">
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></colorMask>
		<compileShader public="1" set="method"><f a="shader">
	<c path="js.html.webgl.Shader"/>
	<x path="Void"/>
</f></compileShader>
		<compressedTexImage2D public="1" set="method"><f a="target:level:internalformat:width:height:border:data">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="js.html.ArrayBufferView"/>
	<x path="Void"/>
</f></compressedTexImage2D>
		<compressedTexSubImage2D public="1" set="method"><f a="target:level:xoffset:yoffset:width:height:format:data">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="js.html.ArrayBufferView"/>
	<x path="Void"/>
</f></compressedTexSubImage2D>
		<copyTexImage2D public="1" set="method"><f a="target:level:internalformat:x:y:width:height:border">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></copyTexImage2D>
		<copyTexSubImage2D public="1" set="method"><f a="target:level:xoffset:yoffset:x:y:width:height">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></copyTexSubImage2D>
		<createBuffer public="1" set="method"><f a=""><c path="js.html.webgl.Buffer"/></f></createBuffer>
		<createFramebuffer public="1" set="method"><f a=""><c path="js.html.webgl.Framebuffer"/></f></createFramebuffer>
		<createProgram public="1" set="method"><f a=""><c path="js.html.webgl.Program"/></f></createProgram>
		<createRenderbuffer public="1" set="method"><f a=""><c path="js.html.webgl.Renderbuffer"/></f></createRenderbuffer>
		<createShader public="1" set="method"><f a="type">
	<x path="Int"/>
	<c path="js.html.webgl.Shader"/>
</f></createShader>
		<createTexture public="1" set="method"><f a=""><c path="js.html.webgl.Texture"/></f></createTexture>
		<cullFace public="1" set="method"><f a="mode">
	<x path="Int"/>
	<x path="Void"/>
</f></cullFace>
		<deleteBuffer public="1" set="method"><f a="buffer">
	<c path="js.html.webgl.Buffer"/>
	<x path="Void"/>
</f></deleteBuffer>
		<deleteFramebuffer public="1" set="method"><f a="framebuffer">
	<c path="js.html.webgl.Framebuffer"/>
	<x path="Void"/>
</f></deleteFramebuffer>
		<deleteProgram public="1" set="method"><f a="program">
	<c path="js.html.webgl.Program"/>
	<x path="Void"/>
</f></deleteProgram>
		<deleteRenderbuffer public="1" set="method"><f a="renderbuffer">
	<c path="js.html.webgl.Renderbuffer"/>
	<x path="Void"/>
</f></deleteRenderbuffer>
		<deleteShader public="1" set="method"><f a="shader">
	<c path="js.html.webgl.Shader"/>
	<x path="Void"/>
</f></deleteShader>
		<deleteTexture public="1" set="method"><f a="texture">
	<c path="js.html.webgl.Texture"/>
	<x path="Void"/>
</f></deleteTexture>
		<depthFunc public="1" set="method"><f a="func">
	<x path="Int"/>
	<x path="Void"/>
</f></depthFunc>
		<depthMask public="1" set="method"><f a="flag">
	<x path="Bool"/>
	<x path="Void"/>
</f></depthMask>
		<depthRange public="1" set="method"><f a="zNear:zFar">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></depthRange>
		<detachShader public="1" set="method"><f a="program:shader">
	<c path="js.html.webgl.Program"/>
	<c path="js.html.webgl.Shader"/>
	<x path="Void"/>
</f></detachShader>
		<disable public="1" set="method"><f a="cap">
	<x path="Int"/>
	<x path="Void"/>
</f></disable>
		<disableVertexAttribArray public="1" set="method"><f a="index">
	<x path="Int"/>
	<x path="Void"/>
</f></disableVertexAttribArray>
		<drawArrays public="1" set="method"><f a="mode:first:count">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></drawArrays>
		<drawElements public="1" set="method"><f a="mode:count:type:offset">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></drawElements>
		<enable public="1" set="method"><f a="cap">
	<x path="Int"/>
	<x path="Void"/>
</f></enable>
		<enableVertexAttribArray public="1" set="method"><f a="index">
	<x path="Int"/>
	<x path="Void"/>
</f></enableVertexAttribArray>
		<finish public="1" set="method"><f a=""><x path="Void"/></f></finish>
		<flush public="1" set="method"><f a=""><x path="Void"/></f></flush>
		<framebufferRenderbuffer public="1" set="method"><f a="target:attachment:renderbuffertarget:renderbuffer">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="js.html.webgl.Renderbuffer"/>
	<x path="Void"/>
</f></framebufferRenderbuffer>
		<framebufferTexture2D public="1" set="method"><f a="target:attachment:textarget:texture:level">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="js.html.webgl.Texture"/>
	<x path="Int"/>
	<x path="Void"/>
</f></framebufferTexture2D>
		<frontFace public="1" set="method"><f a="mode">
	<x path="Int"/>
	<x path="Void"/>
</f></frontFace>
		<generateMipmap public="1" set="method"><f a="target">
	<x path="Int"/>
	<x path="Void"/>
</f></generateMipmap>
		<getActiveAttrib public="1" set="method"><f a="program:index">
	<c path="js.html.webgl.Program"/>
	<x path="Int"/>
	<c path="js.html.webgl.ActiveInfo"/>
</f></getActiveAttrib>
		<getActiveUniform public="1" set="method"><f a="program:index">
	<c path="js.html.webgl.Program"/>
	<x path="Int"/>
	<c path="js.html.webgl.ActiveInfo"/>
</f></getActiveUniform>
		<getAttachedShaders public="1" set="method"><f a="program">
	<c path="js.html.webgl.Program"/>
	<c path="Array"><c path="js.html.webgl.Shader"/></c>
</f></getAttachedShaders>
		<getAttribLocation public="1" set="method"><f a="program:name">
	<c path="js.html.webgl.Program"/>
	<c path="String"/>
	<x path="Int"/>
</f></getAttribLocation>
		<getBufferParameter public="1" set="method"><f a="target:pname">
	<x path="Int"/>
	<x path="Int"/>
	<d/>
</f></getBufferParameter>
		<getParameter public="1" set="method">
			<f a="pname">
				<x path="Int"/>
				<d/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</getParameter>
		<getError public="1" set="method"><f a=""><x path="Int"/></f></getError>
		<getFramebufferAttachmentParameter public="1" set="method">
			<f a="target:attachment:pname">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<d/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</getFramebufferAttachmentParameter>
		<getProgramParameter public="1" set="method"><f a="program:pname">
	<c path="js.html.webgl.Program"/>
	<x path="Int"/>
	<d/>
</f></getProgramParameter>
		<getProgramInfoLog public="1" set="method"><f a="program">
	<c path="js.html.webgl.Program"/>
	<c path="String"/>
</f></getProgramInfoLog>
		<getRenderbufferParameter public="1" set="method"><f a="target:pname">
	<x path="Int"/>
	<x path="Int"/>
	<d/>
</f></getRenderbufferParameter>
		<getShaderParameter public="1" set="method"><f a="shader:pname">
	<c path="js.html.webgl.Shader"/>
	<x path="Int"/>
	<d/>
</f></getShaderParameter>
		<getShaderPrecisionFormat public="1" set="method"><f a="shadertype:precisiontype">
	<x path="Int"/>
	<x path="Int"/>
	<c path="js.html.webgl.ShaderPrecisionFormat"/>
</f></getShaderPrecisionFormat>
		<getShaderInfoLog public="1" set="method"><f a="shader">
	<c path="js.html.webgl.Shader"/>
	<c path="String"/>
</f></getShaderInfoLog>
		<getShaderSource public="1" set="method"><f a="shader">
	<c path="js.html.webgl.Shader"/>
	<c path="String"/>
</f></getShaderSource>
		<getTexParameter public="1" set="method"><f a="target:pname">
	<x path="Int"/>
	<x path="Int"/>
	<d/>
</f></getTexParameter>
		<getUniform public="1" set="method"><f a="program:location">
	<c path="js.html.webgl.Program"/>
	<c path="js.html.webgl.UniformLocation"/>
	<d/>
</f></getUniform>
		<getUniformLocation public="1" set="method"><f a="program:name">
	<c path="js.html.webgl.Program"/>
	<c path="String"/>
	<c path="js.html.webgl.UniformLocation"/>
</f></getUniformLocation>
		<getVertexAttrib public="1" set="method">
			<f a="index:pname">
				<x path="Int"/>
				<x path="Int"/>
				<d/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</getVertexAttrib>
		<getVertexAttribOffset public="1" set="method"><f a="index:pname">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></getVertexAttribOffset>
		<hint public="1" set="method"><f a="target:mode">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></hint>
		<isBuffer public="1" set="method"><f a="buffer">
	<c path="js.html.webgl.Buffer"/>
	<x path="Bool"/>
</f></isBuffer>
		<isEnabled public="1" set="method"><f a="cap">
	<x path="Int"/>
	<x path="Bool"/>
</f></isEnabled>
		<isFramebuffer public="1" set="method"><f a="framebuffer">
	<c path="js.html.webgl.Framebuffer"/>
	<x path="Bool"/>
</f></isFramebuffer>
		<isProgram public="1" set="method"><f a="program">
	<c path="js.html.webgl.Program"/>
	<x path="Bool"/>
</f></isProgram>
		<isRenderbuffer public="1" set="method"><f a="renderbuffer">
	<c path="js.html.webgl.Renderbuffer"/>
	<x path="Bool"/>
</f></isRenderbuffer>
		<isShader public="1" set="method"><f a="shader">
	<c path="js.html.webgl.Shader"/>
	<x path="Bool"/>
</f></isShader>
		<isTexture public="1" set="method"><f a="texture">
	<c path="js.html.webgl.Texture"/>
	<x path="Bool"/>
</f></isTexture>
		<lineWidth public="1" set="method"><f a="width">
	<x path="Float"/>
	<x path="Void"/>
</f></lineWidth>
		<linkProgram public="1" set="method"><f a="program">
	<c path="js.html.webgl.Program"/>
	<x path="Void"/>
</f></linkProgram>
		<pixelStorei public="1" set="method"><f a="pname:param">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></pixelStorei>
		<polygonOffset public="1" set="method"><f a="factor:units">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></polygonOffset>
		<readPixels public="1" set="method">
			<f a="x:y:width:height:format:type:pixels">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="js.html.ArrayBufferView"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</readPixels>
		<renderbufferStorage public="1" set="method"><f a="target:internalformat:width:height">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></renderbufferStorage>
		<sampleCoverage public="1" set="method"><f a="value:invert">
	<x path="Float"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></sampleCoverage>
		<scissor public="1" set="method"><f a="x:y:width:height">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></scissor>
		<shaderSource public="1" set="method"><f a="shader:source">
	<c path="js.html.webgl.Shader"/>
	<c path="String"/>
	<x path="Void"/>
</f></shaderSource>
		<stencilFunc public="1" set="method"><f a="func:ref:mask">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></stencilFunc>
		<stencilFuncSeparate public="1" set="method"><f a="face:func:ref:mask">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></stencilFuncSeparate>
		<stencilMask public="1" set="method"><f a="mask">
	<x path="Int"/>
	<x path="Void"/>
</f></stencilMask>
		<stencilMaskSeparate public="1" set="method"><f a="face:mask">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></stencilMaskSeparate>
		<stencilOp public="1" set="method"><f a="fail:zfail:zpass">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></stencilOp>
		<stencilOpSeparate public="1" set="method"><f a="face:fail:zfail:zpass">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></stencilOpSeparate>
		<texImage2D public="1" set="method">
			<f a="target:level:internalformat:format:type:video">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="js.html.VideoElement"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
			<overloads>
				<texImage2D public="1" set="method">
					<f a="target:level:internalformat:width:height:border:format:type:pixels">
						<x path="Int"/>
						<x path="Int"/>
						<x path="Int"/>
						<x path="Int"/>
						<x path="Int"/>
						<x path="Int"/>
						<x path="Int"/>
						<x path="Int"/>
						<c path="js.html.ArrayBufferView"/>
						<x path="Void"/>
					</f>
					<haxe_doc>@throws DOMError</haxe_doc>
				</texImage2D>
				<texImage2D public="1" set="method">
					<f a="target:level:internalformat:format:type:pixels">
						<x path="Int"/>
						<x path="Int"/>
						<x path="Int"/>
						<x path="Int"/>
						<x path="Int"/>
						<c path="js.html.ImageData"/>
						<x path="Void"/>
					</f>
					<haxe_doc>@throws DOMError</haxe_doc>
				</texImage2D>
				<texImage2D public="1" set="method">
					<f a="target:level:internalformat:format:type:image">
						<x path="Int"/>
						<x path="Int"/>
						<x path="Int"/>
						<x path="Int"/>
						<x path="Int"/>
						<c path="js.html.ImageElement"/>
						<x path="Void"/>
					</f>
					<haxe_doc>@throws DOMError</haxe_doc>
				</texImage2D>
				<texImage2D public="1" set="method">
					<f a="target:level:internalformat:format:type:canvas">
						<x path="Int"/>
						<x path="Int"/>
						<x path="Int"/>
						<x path="Int"/>
						<x path="Int"/>
						<c path="js.html.CanvasElement"/>
						<x path="Void"/>
					</f>
					<haxe_doc>@throws DOMError</haxe_doc>
				</texImage2D>
			</overloads>
		</texImage2D>
		<texParameterf public="1" set="method"><f a="target:pname:param">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Float"/>
	<x path="Void"/>
</f></texParameterf>
		<texParameteri public="1" set="method"><f a="target:pname:param">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></texParameteri>
		<texSubImage2D public="1" set="method">
			<f a="target:level:xoffset:yoffset:format:type:video">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="js.html.VideoElement"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
			<overloads>
				<texSubImage2D public="1" set="method">
					<f a="target:level:xoffset:yoffset:width:height:format:type:pixels">
						<x path="Int"/>
						<x path="Int"/>
						<x path="Int"/>
						<x path="Int"/>
						<x path="Int"/>
						<x path="Int"/>
						<x path="Int"/>
						<x path="Int"/>
						<c path="js.html.ArrayBufferView"/>
						<x path="Void"/>
					</f>
					<haxe_doc>@throws DOMError</haxe_doc>
				</texSubImage2D>
				<texSubImage2D public="1" set="method">
					<f a="target:level:xoffset:yoffset:format:type:pixels">
						<x path="Int"/>
						<x path="Int"/>
						<x path="Int"/>
						<x path="Int"/>
						<x path="Int"/>
						<x path="Int"/>
						<c path="js.html.ImageData"/>
						<x path="Void"/>
					</f>
					<haxe_doc>@throws DOMError</haxe_doc>
				</texSubImage2D>
				<texSubImage2D public="1" set="method">
					<f a="target:level:xoffset:yoffset:format:type:image">
						<x path="Int"/>
						<x path="Int"/>
						<x path="Int"/>
						<x path="Int"/>
						<x path="Int"/>
						<x path="Int"/>
						<c path="js.html.ImageElement"/>
						<x path="Void"/>
					</f>
					<haxe_doc>@throws DOMError</haxe_doc>
				</texSubImage2D>
				<texSubImage2D public="1" set="method">
					<f a="target:level:xoffset:yoffset:format:type:canvas">
						<x path="Int"/>
						<x path="Int"/>
						<x path="Int"/>
						<x path="Int"/>
						<x path="Int"/>
						<x path="Int"/>
						<c path="js.html.CanvasElement"/>
						<x path="Void"/>
					</f>
					<haxe_doc>@throws DOMError</haxe_doc>
				</texSubImage2D>
			</overloads>
		</texSubImage2D>
		<uniform1f public="1" set="method"><f a="location:x">
	<c path="js.html.webgl.UniformLocation"/>
	<x path="Float"/>
	<x path="Void"/>
</f></uniform1f>
		<uniform1fv public="1" set="method">
			<f a="location:v">
				<c path="js.html.webgl.UniformLocation"/>
				<c path="Array"><x path="Float"/></c>
				<x path="Void"/>
			</f>
			<overloads><uniform1fv public="1" set="method"><f a="location:v">
	<c path="js.html.webgl.UniformLocation"/>
	<c path="js.html.Float32Array"/>
	<x path="Void"/>
</f></uniform1fv></overloads>
		</uniform1fv>
		<uniform1i public="1" set="method"><f a="location:x">
	<c path="js.html.webgl.UniformLocation"/>
	<x path="Int"/>
	<x path="Void"/>
</f></uniform1i>
		<uniform1iv public="1" set="method">
			<f a="location:v">
				<c path="js.html.webgl.UniformLocation"/>
				<c path="Array"><x path="Int"/></c>
				<x path="Void"/>
			</f>
			<overloads><uniform1iv public="1" set="method"><f a="location:v">
	<c path="js.html.webgl.UniformLocation"/>
	<c path="js.html.Int32Array"/>
	<x path="Void"/>
</f></uniform1iv></overloads>
		</uniform1iv>
		<uniform2f public="1" set="method"><f a="location:x:y">
	<c path="js.html.webgl.UniformLocation"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></uniform2f>
		<uniform2fv public="1" set="method">
			<f a="location:v">
				<c path="js.html.webgl.UniformLocation"/>
				<c path="Array"><x path="Float"/></c>
				<x path="Void"/>
			</f>
			<overloads><uniform2fv public="1" set="method"><f a="location:v">
	<c path="js.html.webgl.UniformLocation"/>
	<c path="js.html.Float32Array"/>
	<x path="Void"/>
</f></uniform2fv></overloads>
		</uniform2fv>
		<uniform2i public="1" set="method"><f a="location:x:y">
	<c path="js.html.webgl.UniformLocation"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></uniform2i>
		<uniform2iv public="1" set="method">
			<f a="location:v">
				<c path="js.html.webgl.UniformLocation"/>
				<c path="Array"><x path="Int"/></c>
				<x path="Void"/>
			</f>
			<overloads><uniform2iv public="1" set="method"><f a="location:v">
	<c path="js.html.webgl.UniformLocation"/>
	<c path="js.html.Int32Array"/>
	<x path="Void"/>
</f></uniform2iv></overloads>
		</uniform2iv>
		<uniform3f public="1" set="method"><f a="location:x:y:z">
	<c path="js.html.webgl.UniformLocation"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></uniform3f>
		<uniform3fv public="1" set="method">
			<f a="location:v">
				<c path="js.html.webgl.UniformLocation"/>
				<c path="Array"><x path="Float"/></c>
				<x path="Void"/>
			</f>
			<overloads><uniform3fv public="1" set="method"><f a="location:v">
	<c path="js.html.webgl.UniformLocation"/>
	<c path="js.html.Float32Array"/>
	<x path="Void"/>
</f></uniform3fv></overloads>
		</uniform3fv>
		<uniform3i public="1" set="method"><f a="location:x:y:z">
	<c path="js.html.webgl.UniformLocation"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></uniform3i>
		<uniform3iv public="1" set="method">
			<f a="location:v">
				<c path="js.html.webgl.UniformLocation"/>
				<c path="Array"><x path="Int"/></c>
				<x path="Void"/>
			</f>
			<overloads><uniform3iv public="1" set="method"><f a="location:v">
	<c path="js.html.webgl.UniformLocation"/>
	<c path="js.html.Int32Array"/>
	<x path="Void"/>
</f></uniform3iv></overloads>
		</uniform3iv>
		<uniform4f public="1" set="method"><f a="location:x:y:z:w">
	<c path="js.html.webgl.UniformLocation"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></uniform4f>
		<uniform4fv public="1" set="method">
			<f a="location:v">
				<c path="js.html.webgl.UniformLocation"/>
				<c path="Array"><x path="Float"/></c>
				<x path="Void"/>
			</f>
			<overloads><uniform4fv public="1" set="method"><f a="location:v">
	<c path="js.html.webgl.UniformLocation"/>
	<c path="js.html.Float32Array"/>
	<x path="Void"/>
</f></uniform4fv></overloads>
		</uniform4fv>
		<uniform4i public="1" set="method"><f a="location:x:y:z:w">
	<c path="js.html.webgl.UniformLocation"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></uniform4i>
		<uniform4iv public="1" set="method">
			<f a="location:v">
				<c path="js.html.webgl.UniformLocation"/>
				<c path="Array"><x path="Int"/></c>
				<x path="Void"/>
			</f>
			<overloads><uniform4iv public="1" set="method"><f a="location:v">
	<c path="js.html.webgl.UniformLocation"/>
	<c path="js.html.Int32Array"/>
	<x path="Void"/>
</f></uniform4iv></overloads>
		</uniform4iv>
		<uniformMatrix2fv public="1" set="method">
			<f a="location:transpose:value">
				<c path="js.html.webgl.UniformLocation"/>
				<x path="Bool"/>
				<c path="Array"><x path="Float"/></c>
				<x path="Void"/>
			</f>
			<overloads><uniformMatrix2fv public="1" set="method"><f a="location:transpose:value">
	<c path="js.html.webgl.UniformLocation"/>
	<x path="Bool"/>
	<c path="js.html.Float32Array"/>
	<x path="Void"/>
</f></uniformMatrix2fv></overloads>
		</uniformMatrix2fv>
		<uniformMatrix3fv public="1" set="method">
			<f a="location:transpose:value">
				<c path="js.html.webgl.UniformLocation"/>
				<x path="Bool"/>
				<c path="Array"><x path="Float"/></c>
				<x path="Void"/>
			</f>
			<overloads><uniformMatrix3fv public="1" set="method"><f a="location:transpose:value">
	<c path="js.html.webgl.UniformLocation"/>
	<x path="Bool"/>
	<c path="js.html.Float32Array"/>
	<x path="Void"/>
</f></uniformMatrix3fv></overloads>
		</uniformMatrix3fv>
		<uniformMatrix4fv public="1" set="method">
			<f a="location:transpose:value">
				<c path="js.html.webgl.UniformLocation"/>
				<x path="Bool"/>
				<c path="Array"><x path="Float"/></c>
				<x path="Void"/>
			</f>
			<overloads><uniformMatrix4fv public="1" set="method"><f a="location:transpose:value">
	<c path="js.html.webgl.UniformLocation"/>
	<x path="Bool"/>
	<c path="js.html.Float32Array"/>
	<x path="Void"/>
</f></uniformMatrix4fv></overloads>
		</uniformMatrix4fv>
		<useProgram public="1" set="method"><f a="program">
	<c path="js.html.webgl.Program"/>
	<x path="Void"/>
</f></useProgram>
		<validateProgram public="1" set="method"><f a="program">
	<c path="js.html.webgl.Program"/>
	<x path="Void"/>
</f></validateProgram>
		<vertexAttrib1f public="1" set="method"><f a="indx:x">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Void"/>
</f></vertexAttrib1f>
		<vertexAttrib1fv public="1" set="method">
			<f a="indx:values">
				<x path="Int"/>
				<c path="Array"><x path="Float"/></c>
				<x path="Void"/>
			</f>
			<overloads><vertexAttrib1fv public="1" set="method"><f a="indx:values">
	<x path="Int"/>
	<c path="js.html.Float32Array"/>
	<x path="Void"/>
</f></vertexAttrib1fv></overloads>
		</vertexAttrib1fv>
		<vertexAttrib2f public="1" set="method"><f a="indx:x:y">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></vertexAttrib2f>
		<vertexAttrib2fv public="1" set="method">
			<f a="indx:values">
				<x path="Int"/>
				<c path="Array"><x path="Float"/></c>
				<x path="Void"/>
			</f>
			<overloads><vertexAttrib2fv public="1" set="method"><f a="indx:values">
	<x path="Int"/>
	<c path="js.html.Float32Array"/>
	<x path="Void"/>
</f></vertexAttrib2fv></overloads>
		</vertexAttrib2fv>
		<vertexAttrib3f public="1" set="method"><f a="indx:x:y:z">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></vertexAttrib3f>
		<vertexAttrib3fv public="1" set="method">
			<f a="indx:values">
				<x path="Int"/>
				<c path="Array"><x path="Float"/></c>
				<x path="Void"/>
			</f>
			<overloads><vertexAttrib3fv public="1" set="method"><f a="indx:values">
	<x path="Int"/>
	<c path="js.html.Float32Array"/>
	<x path="Void"/>
</f></vertexAttrib3fv></overloads>
		</vertexAttrib3fv>
		<vertexAttrib4f public="1" set="method"><f a="indx:x:y:z:w">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></vertexAttrib4f>
		<vertexAttrib4fv public="1" set="method">
			<f a="indx:values">
				<x path="Int"/>
				<c path="Array"><x path="Float"/></c>
				<x path="Void"/>
			</f>
			<overloads><vertexAttrib4fv public="1" set="method"><f a="indx:values">
	<x path="Int"/>
	<c path="js.html.Float32Array"/>
	<x path="Void"/>
</f></vertexAttrib4fv></overloads>
		</vertexAttrib4fv>
		<vertexAttribPointer public="1" set="method"><f a="indx:size:type:normalized:stride:offset">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></vertexAttribPointer>
		<viewport public="1" set="method"><f a="x:y:width:height">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></viewport>
		<meta><m n=":native"><e>"WebGLRenderingContext"</e></m></meta>
	</class>
	<class path="js.html.webgl.Shader" params="" file="C:\HaxeToolkit\haxe\std/js/html/webgl/Shader.hx" extern="1"><meta><m n=":native"><e>"WebGLShader"</e></m></meta></class>
	<class path="js.html.webgl.ShaderPrecisionFormat" params="" file="C:\HaxeToolkit\haxe\std/js/html/webgl/ShaderPrecisionFormat.hx" extern="1">
		<rangeMin public="1" set="null"><x path="Int"/></rangeMin>
		<rangeMax public="1" set="null"><x path="Int"/></rangeMax>
		<precision public="1" set="null"><x path="Int"/></precision>
		<meta><m n=":native"><e>"WebGLShaderPrecisionFormat"</e></m></meta>
	</class>
	<class path="js.html.webgl.Texture" params="" file="C:\HaxeToolkit\haxe\std/js/html/webgl/Texture.hx" extern="1"><meta><m n=":native"><e>"WebGLTexture"</e></m></meta></class>
	<class path="js.html.webgl.UniformLocation" params="" file="C:\HaxeToolkit\haxe\std/js/html/webgl/UniformLocation.hx" extern="1"><meta><m n=":native"><e>"WebGLUniformLocation"</e></m></meta></class>
	<class path="jsfps.fpsmeter.FPSMeter" params="" file="C:\HaxeToolkit\haxe\lib\jsfps/1,0,1/jsfps/fpsmeter/FPSMeter.hx" extern="1">
		<tick public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Marks the end of each frame. This is the method that measures everything.</haxe_doc>
		</tick>
		<tickStart public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Marks the beginning of each frame. .tick() than uses this time to measure the rendering duration of each frame.
	 * This method is optional, and if omitted, .tick() will measure the duration between frames instead.</haxe_doc>
		</tickStart>
		<showFps public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Changes the meter to display FPS.</haxe_doc>
		</showFps>
		<showDuration public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Changes the meter to display duration between frames, or frame rendering duration when using .tickStart() method.</haxe_doc>
		</showDuration>
		<toggle public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Toggles between showFps amd showDuration.</haxe_doc>
		</toggle>
		<pause public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Pauses the meter rendering. FPSMeter still continues to measure everything, just the meter element rendering is paused.</haxe_doc>
		</pause>
		<resume public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Resumes the paused rendering.</haxe_doc>
		</resume>
		<hide public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Pauses the rendering, and hides the FPSMeter element.</haxe_doc>
		</hide>
		<show public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Shows the FPSMeter element, and resumes the rendering.</haxe_doc>
		</show>
		<set public="1" set="method">
			<f a="name:value">
				<c path="String"/>
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Updates an option value, and when needed, repositions or reloads the meter element.</haxe_doc>
		</set>
		<destroy public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Pauses rendering, unbinds events, removes the element from DOM, and stops listening to ticks.</haxe_doc>
		</destroy>
		<new public="1" set="method"><f a="?anchor:?options">
	<c path="js.html.Element"/>
	<t path="jsfps.fpsmeter.Options"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":native"><e>"FPSMeter"</e></m>
		</meta>
	</class>
	<typedef path="jsfps.fpsmeter.Options" params="" file="C:\HaxeToolkit\haxe\lib\jsfps/1,0,1/jsfps/fpsmeter/FPSMeter.hx" module="jsfps.fpsmeter.FPSMeter"><a>
	<zIndex>
		<t path="Null"><x path="Int"/></t>
		<meta><m n=":optional"/></meta>
	</zIndex>
	<top>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</top>
	<toggleOn>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</toggleOn>
	<threshold>
		<t path="Null"><x path="Int"/></t>
		<meta><m n=":optional"/></meta>
	</threshold>
	<theme>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</theme>
	<smoothing>
		<t path="Null"><x path="Float"/></t>
		<meta><m n=":optional"/></meta>
	</smoothing>
	<show>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</show>
	<right>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</right>
	<position>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</position>
	<maxFps>
		<t path="Null"><x path="Int"/></t>
		<meta><m n=":optional"/></meta>
	</maxFps>
	<margin>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</margin>
	<left>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</left>
	<interval>
		<t path="Null"><x path="Int"/></t>
		<meta><m n=":optional"/></meta>
	</interval>
	<history>
		<t path="Null"><x path="Int"/></t>
		<meta><m n=":optional"/></meta>
	</history>
	<heat>
		<t path="Null"><x path="Int"/></t>
		<meta><m n=":optional"/></meta>
	</heat>
	<graph>
		<t path="Null"><x path="Int"/></t>
		<meta><m n=":optional"/></meta>
	</graph>
	<decimals>
		<t path="Null"><x path="Int"/></t>
		<meta><m n=":optional"/></meta>
	</decimals>
	<bottom>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</bottom>
</a></typedef>
	<class path="pathfinder.Coordinate" params="" file="C:\HaxeToolkit\haxe\lib\pathfinder/0,2,18/pathfinder/Coordinate.hx">
		<x public="1"><x path="Int"/></x>
		<y public="1"><x path="Int"/></y>
		<isEqualTo public="1" set="method" line="47"><f a="p_coordinate">
	<c path="pathfinder.Coordinate"/>
	<x path="Bool"/>
</f></isEqualTo>
		<toString public="1" set="method" line="52"><f a=""><c path="String"/></f></toString>
		<clone public="1" set="method" line="57"><f a=""><c path="pathfinder.Coordinate"/></f></clone>
		<new public="1" set="method" line="41"><f a="?p_x:?p_y">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* @author Statm	https://github.com/statm/haxe-astar
 * @author Robert Fell</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<enum path="pathfinder.EHeuristic" params="" file="C:\HaxeToolkit\haxe\lib\pathfinder/0,2,18/pathfinder/EHeuristic.hx">
		<DIAGONAL><haxe_doc><![CDATA[* pretty & accurate (the allrounder)]]></haxe_doc></DIAGONAL>
		<PRODUCT><haxe_doc>* fast and pretty but might not be shortest (the beauty) - *the default*</haxe_doc></PRODUCT>
		<EUCLIDIAN><haxe_doc>* shortest path but slow (the brainiac)</haxe_doc></EUCLIDIAN>
		<MANHATTAN><haxe_doc>* fastest, ugliest, least accurate (the athlete)</haxe_doc></MANHATTAN>
		<haxe_doc>* @author Statm	https://github.com/statm/haxe-astar
 * @author Robert Fell</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<class path="pathfinder.Node" params="" file="C:\HaxeToolkit\haxe\lib\pathfinder/0,2,18/pathfinder/Node.hx">
		<extends path="pathfinder.Coordinate"/>
		<parent public="1"><c path="pathfinder.Node"/></parent>
		<isWalkable public="1"><x path="Bool"/></isWalkable>
		<f public="1"><x path="Float"/></f>
		<g public="1"><x path="Float"/></g>
		<toString public="1" set="method" line="49" override="1"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="43"><f a="p_x:p_y:?p_isWalkable">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* @author Statm	https://github.com/statm/haxe-astar
 * @author Robert Fell</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="pathfinder.Pathfinder" params="" file="C:\HaxeToolkit\haxe\lib\pathfinder/0,2,18/pathfinder/Pathfinder.hx">
		<_COST_ADJACENT get="inline" set="null" line="40" static="1"><x path="Int"/></_COST_ADJACENT>
		<_COST_DIAGIONAL get="inline" set="null" line="41" static="1"><x path="Int"/></_COST_DIAGIONAL>
		<_map><c path="pathfinder.IMap"/></_map>
		<_timeOutDuration><x path="Int"/></_timeOutDuration>
		<_openList><c path="Array"><c path="pathfinder.Node"/></c></_openList>
		<_closedList><c path="Array"><c path="pathfinder.Node"/></c></_closedList>
		<_isCompleted><x path="Bool"/></_isCompleted>
		<_nodes><c path="Array"><c path="Array"><c path="pathfinder.Node"/></c></c></_nodes>
		<_startNode><c path="pathfinder.Node"/></_startNode>
		<_destNode><c path="pathfinder.Node"/></_destNode>
		<_cols><x path="Int"/></_cols>
		<_rows><x path="Int"/></_rows>
		<_info><a>
	<timeElapsed><x path="Int"/></timeElapsed>
	<pathLength><x path="Int"/></pathLength>
	<isDiagonalEnabled><x path="Bool"/></isDiagonalEnabled>
	<heuristic><e path="pathfinder.EHeuristic"/></heuristic>
</a></_info>
		<configure public="1" set="method" line="70">
			<f a="p_map:?p_timeOutDuration">
				<c path="pathfinder.IMap"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Reconfigures an existing pathfinder class
	 * @param	p_map	The boolean coordinate map
	 * @param	p_timeOutDuration	The maximum time spent to find a path</haxe_doc>
		</configure>
		<_getCost get="inline" set="null" line="87"><f a="p_node1:p_node2:p_heuristic">
	<c path="pathfinder.Node"/>
	<c path="pathfinder.Node"/>
	<e path="pathfinder.EHeuristic"/>
	<x path="Float"/>
</f></_getCost>
		<_getCostDiagonal get="inline" set="null" line="98"><f a="p_node1:p_node2">
	<c path="pathfinder.Node"/>
	<c path="pathfinder.Node"/>
	<x path="Float"/>
</f></_getCostDiagonal>
		<_getCostProduct get="inline" set="null" line="107"><f a="p_node1:p_node2">
	<c path="pathfinder.Node"/>
	<c path="pathfinder.Node"/>
	<x path="Float"/>
</f></_getCostProduct>
		<_getCostEuclidian get="inline" set="null" line="117"><f a="p_node1:p_node2">
	<c path="pathfinder.Node"/>
	<c path="pathfinder.Node"/>
	<x path="Float"/>
</f></_getCostEuclidian>
		<_getCostManhattan get="inline" set="null" line="124"><f a="p_node1:p_node2">
	<c path="pathfinder.Node"/>
	<c path="pathfinder.Node"/>
	<x path="Float"/>
</f></_getCostManhattan>
		<createPath public="1" set="method" line="140">
			<f a="p_start:p_dest:?p_heuristic:?p_isDiagonalEnabled:?p_isMapDynamic">
				<c path="pathfinder.Coordinate"/>
				<c path="pathfinder.Coordinate"/>
				<e path="pathfinder.EHeuristic"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<c path="Array"><c path="pathfinder.Coordinate"/></c>
			</f>
			<haxe_doc>* Calculates an A Star path between two nodes on a boolean map
	 * @param	p_start	The starting node
	 * @param	p_dest	The destination node
	 * @param	p_heuristic	The method of A Star used
	 * @param	p_isDiagonalEnabled	Set to true to ensure only up, left, down, right movements are allowed
	 * @param	p_isMapDynamic	Set to true to force fresh lookups from IMap.isWalkable() for each node's isWalkable property (e.g. for a dynamically changing map)
	 * @return	An array of coordinates from start to destination, or null if no path was found within the time limit</haxe_doc>
		</createPath>
		<_getPath get="inline" set="null" line="167"><f a=""><c path="Array"><c path="pathfinder.Coordinate"/></c></f></_getPath>
		<_searchPath set="method" line="185"><f a="p_heuristic:?p_isDiagonalEnabled:?p_isMapDynamic">
	<e path="pathfinder.EHeuristic"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<c path="Array"><c path="pathfinder.Coordinate"/></c>
</f></_searchPath>
		<_sort set="method" line="262"><f a="p_x:p_y">
	<c path="pathfinder.Node"/>
	<c path="pathfinder.Node"/>
	<x path="Int"/>
</f></_sort>
		<_intAbs get="inline" set="null" line="267"><f a="p_value">
	<x path="Int"/>
	<x path="Int"/>
</f></_intAbs>
		<_intMin get="inline" set="null" line="272"><f a="p_v1:p_v2">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></_intMin>
		<getInfo public="1" set="method" line="281">
			<f a=""><c path="String"/></f>
			<haxe_doc>* A string to interpret the success of the latest path created
	 * @return	Information string</haxe_doc>
		</getInfo>
		<new public="1" set="method" line="60">
			<f a="p_map:?p_timeOutDuration">
				<c path="pathfinder.IMap"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Creates a new pathfinder class
	 * @param	p_map	The boolean coordinate map
	 * @param	p_timeOutDuration	The maximum time spent to find a path</haxe_doc>
		</new>
		<haxe_doc>* A class to find an optimized A Star path across an IMap boolean grid.
 * @author Statm	https://github.com/statm/haxe-astar
 * @author Robert Fell</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="pixi.core.graphics.Graphics" params="" file="C:\HaxeToolkit\haxe\lib\pixijs/3,0,25/pixi/core/graphics/Graphics.hx" extern="1">
		<extends path="pixi.core.display.Container"/>
		<fillAlpha public="1">
			<x path="Float"/>
			<haxe_doc>* The alpha value used when filling the Graphics object.
	 *
	 * @member {Float}
	 * @default 1</haxe_doc>
		</fillAlpha>
		<lineWidth public="1">
			<x path="Float"/>
			<haxe_doc>* The width (thickness) of any lines drawn.
	 *
	 * @member {Float}
	 * @default 0</haxe_doc>
		</lineWidth>
		<lineColor public="1">
			<x path="Int"/>
			<haxe_doc>* The color of any lines drawn.
	 *
	 * @member {Int}
	 * @default 0</haxe_doc>
		</lineColor>
		<tint public="1">
			<x path="Int"/>
			<haxe_doc>* The tint applied to the graphic shape. This is a hex value. Apply a value of 0xFFFFFF to reset the tint.
	 *
	 * @member {Int}
	 * @default 0xFFFFFF</haxe_doc>
		</tint>
		<blendMode public="1">
			<x path="Int"/>
			<haxe_doc>* The blend mode to be applied to the graphic shape. Apply a value of blendModes.NORMAL to reset the blend mode.
	 *
	 * @member {Int}
	 * @default CONST.BLEND_MODES.NORMAL;</haxe_doc>
		</blendMode>
		<isMask public="1">
			<x path="Bool"/>
			<haxe_doc>* Whether this shape is being used as a mask.
	 *
	 * @member {Bool}</haxe_doc>
		</isMask>
		<boundsPadding public="1">
			<x path="Float"/>
			<haxe_doc>* The bounds' padding used for bounds calculation.
	 *
	 * @member {Float}</haxe_doc>
		</boundsPadding>
		<clone public="1" set="method">
			<f a=""><c path="pixi.core.graphics.Graphics"/></f>
			<haxe_doc>* Creates a new Graphics object with the same values as this one.
	 *
	 * @return {Graphics}</haxe_doc>
		</clone>
		<lineStyle public="1" set="method">
			<f a="?lineWidth:?color:?alpha">
				<x path="Float"/>
				<x path="Int"/>
				<x path="Float"/>
				<c path="pixi.core.graphics.Graphics"/>
			</f>
			<haxe_doc>* Specifies the line style used for subsequent calls to Graphics methods such as the lineTo() method or the drawCircle() method.
	 *
	 * @param lineWidth {Float} width of the line to draw, will update the objects stored style
	 * @param color {Int} color of the line to draw, will update the objects stored style
	 * @param alpha {Float} alpha of the line to draw, will update the objects stored style
	 * @return {Graphics}</haxe_doc>
		</lineStyle>
		<moveTo public="1" set="method">
			<f a="x:y">
				<x path="Float"/>
				<x path="Float"/>
				<c path="pixi.core.graphics.Graphics"/>
			</f>
			<haxe_doc>* Moves the current drawing position to x, y.
	 *
	 * @param x {Float} the X coordinate to move to
	 * @param y {Float} the Y coordinate to move to
	 * @return {Graphics}</haxe_doc>
		</moveTo>
		<lineTo public="1" set="method">
			<f a="x:y">
				<x path="Float"/>
				<x path="Float"/>
				<c path="pixi.core.graphics.Graphics"/>
			</f>
			<haxe_doc>* Draws a line using the current line style from the current drawing position to (x, y);
	 * The current drawing position is then set to (x, y).
	 *
	 * @param x {Float} the X coordinate to draw to
	 * @param y {Float} the Y coordinate to draw to
	 * @return {Graphics}</haxe_doc>
		</lineTo>
		<quadraticCurveTo public="1" set="method">
			<f a="cpX:cpY:toX:toY">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="pixi.core.graphics.Graphics"/>
			</f>
			<haxe_doc>* Calculate the points for a quadratic bezier curve and then draws it.
	 * Based on: https://stackoverflow.com/questions/785097/how-do-i-implement-a-bezier-curve-in-c
	 *
	 * @param cpX {Float} Control point x
	 * @param cpY {Float} Control point y
	 * @param toX {Float} Destination point x
	 * @param toY {Float} Destination point y
	 * @return {Graphics}</haxe_doc>
		</quadraticCurveTo>
		<bezierCurveTo public="1" set="method">
			<f a="cpX:cpY:cpX2:cpY2:toX:toY">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="pixi.core.graphics.Graphics"/>
			</f>
			<haxe_doc>* Calculate the points for a bezier curve and then draws it.
	 *
	 * @param cpX {Float} Control point x
	 * @param cpY {Float} Control point y
	 * @param cpX2 {Float} Second Control point x
	 * @param cpY2 {Float} Second Control point y
	 * @param toX {Float} Destination point x
	 * @param toY {Float} Destination point y
	 * @return {Graphics}</haxe_doc>
		</bezierCurveTo>
		<arcTo public="1" set="method">
			<f a="x1:y1:x2:y2:radius">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="pixi.core.graphics.Graphics"/>
			</f>
			<haxe_doc>* The arcTo() method creates an arc/curve between two tangents on the canvas.
	 *
	 * "borrowed" from https://code.google.com/p/fxcanvas/ - thanks google!
	 *
	 * @param x1 {Float} The x-coordinate of the beginning of the arc
	 * @param y1 {Float} The y-coordinate of the beginning of the arc
	 * @param x2 {Float} The x-coordinate of the end of the arc
	 * @param y2 {Float} The y-coordinate of the end of the arc
	 * @param radius {Float} The radius of the arc
	 * @return {Graphics}</haxe_doc>
		</arcTo>
		<arc public="1" set="method">
			<f a="cx:cy:radius:startAngle:endAngle:?anticlockwise">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<c path="pixi.core.graphics.Graphics"/>
			</f>
			<haxe_doc>* The arc method creates an arc/curve (used to create circles, or parts of circles).
	 *
	 * @param cx {Float} The x-coordinate of the center of the circle
	 * @param cy {Float} The y-coordinate of the center of the circle
	 * @param radius {Float} The radius of the circle
	 * @param startAngle {Float} The starting angle, in radians (0 is at the 3 o'clock position of the arc's circle)
	 * @param endAngle {Float} The ending angle, in radians
	 * @param anticlockwise {Bool} Optional. Specifies whether the drawing should be counterclockwise or clockwise. False is default, and indicates clockwise, while true indicates counter-clockwise.
	 * @return {Graphics}</haxe_doc>
		</arc>
		<beginFill public="1" set="method">
			<f a="?color:?alpha">
				<x path="Int"/>
				<x path="Float"/>
				<c path="pixi.core.graphics.Graphics"/>
			</f>
			<haxe_doc>* Specifies a simple one-color fill that subsequent calls to other Graphics methods
	 * (such as lineTo() or drawCircle()) use when drawing.
	 *
	 * @param color {Int} the color of the fill
	 * @param alpha {Float} the alpha of the fill
	 * @return {Graphics}</haxe_doc>
		</beginFill>
		<endFill public="1" set="method">
			<f a=""><c path="pixi.core.graphics.Graphics"/></f>
			<haxe_doc>* Applies a fill to the lines and shapes that were added since the last call to the beginFill() method.
	 *
	 * @return {Graphics}</haxe_doc>
		</endFill>
		<drawRect public="1" set="method">
			<f a="x:y:width:height">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="pixi.core.graphics.Graphics"/>
			</f>
			<haxe_doc>*
	 * @param x {Float} The X coord of the top-left of the rectangle
	 * @param y {Float} The Y coord of the top-left of the rectangle
	 * @param width {Float} The width of the rectangle
	 * @param height {Float} The height of the rectangle
	 * @return {Graphics}</haxe_doc>
		</drawRect>
		<drawRoundedRect public="1" set="method">
			<f a="x:y:width:height:radius">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="pixi.core.graphics.Graphics"/>
			</f>
			<haxe_doc>*
	 * @param x {Float} The X coord of the top-left of the rectangle
	 * @param y {Float} The Y coord of the top-left of the rectangle
	 * @param width {Float} The width of the rectangle
	 * @param height {Float} The height of the rectangle
	 * @param radius {Float} Radius of the rectangle corners</haxe_doc>
		</drawRoundedRect>
		<drawCircle public="1" set="method">
			<f a="x:y:radius">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="pixi.core.graphics.Graphics"/>
			</f>
			<haxe_doc>* Draws a circle.
	 *
	 * @param x {Float} The X coordinate of the center of the circle
	 * @param y {Float} The Y coordinate of the center of the circle
	 * @param radius {Float} The radius of the circle
	 * @return {Graphics}</haxe_doc>
		</drawCircle>
		<drawEllipse public="1" set="method">
			<f a="x:y:width:height">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="pixi.core.graphics.Graphics"/>
			</f>
			<haxe_doc>* Draws an ellipse.
	 *
	 * @param x {Float} The X coordinate of the center of the ellipse
	 * @param y {Float} The Y coordinate of the center of the ellipse
	 * @param width {Float} The half width of the ellipse
	 * @param height {Float} The half height of the ellipse
	 * @return {Graphics}</haxe_doc>
		</drawEllipse>
		<drawPolygon public="1" set="method">
			<f a="path">
				<c path="Array"><x path="Float"/></c>
				<c path="pixi.core.graphics.Graphics"/>
			</f>
			<haxe_doc>* Draws a polygon using the given path.
	 *
	 * @param path {Array} The path data used to construct the polygon.
	 * @return {Graphics}</haxe_doc>
		</drawPolygon>
		<clear public="1" set="method">
			<f a=""><c path="pixi.core.graphics.Graphics"/></f>
			<haxe_doc>* Clears the graphics that were drawn to this Graphics object, and resets fill and line style settings.
	 *
	 * @return {Graphics}</haxe_doc>
		</clear>
		<updateLocalBounds public="1" set="method">
			<f a=""><c path="pixi.core.graphics.Graphics"/></f>
			<haxe_doc>* Update the bounds of the object
	 *</haxe_doc>
		</updateLocalBounds>
		<drawShape public="1" set="method">
			<f a="shape">
				<c path="pixi.core.math.shapes.Circle"/>
				<c path="pixi.core.graphics.GraphicsData"/>
			</f>
			<haxe_doc>* Draws the given shape to this Graphics object. Can be any of Circle, Rectangle, Ellipse, Line or Polygon.
	 *
	 * @param {Circle|Rectangle|Ellipse|Line|Polygon} shape The Shape object to draw.
	 * @return {GraphicsData} The generated GraphicsData object.</haxe_doc>
			<overloads>
				<drawShape public="1" set="method">
					<f a="shape">
						<c path="pixi.core.math.shapes.Rectangle"/>
						<c path="pixi.core.graphics.GraphicsData"/>
					</f>
					<haxe_doc>* Draws the given shape to this Graphics object. Can be any of Circle, Rectangle, Ellipse, Line or Polygon.
	 *
	 * @param {Circle|Rectangle|Ellipse|Line|Polygon} shape The Shape object to draw.
	 * @return {GraphicsData} The generated GraphicsData object.</haxe_doc>
				</drawShape>
				<drawShape public="1" set="method">
					<f a="shape">
						<c path="pixi.core.math.shapes.Ellipse"/>
						<c path="pixi.core.graphics.GraphicsData"/>
					</f>
					<haxe_doc>* Draws the given shape to this Graphics object. Can be any of Circle, Rectangle, Ellipse, Line or Polygon.
	 *
	 * @param {Circle|Rectangle|Ellipse|Line|Polygon} shape The Shape object to draw.
	 * @return {GraphicsData} The generated GraphicsData object.</haxe_doc>
				</drawShape>
				<drawShape public="1" set="method">
					<f a="shape">
						<c path="pixi.core.math.shapes.Polygon"/>
						<c path="pixi.core.graphics.GraphicsData"/>
					</f>
					<haxe_doc>* Draws the given shape to this Graphics object. Can be any of Circle, Rectangle, Ellipse, Line or Polygon.
	 *
	 * @param {Circle|Rectangle|Ellipse|Line|Polygon} shape The Shape object to draw.
	 * @return {GraphicsData} The generated GraphicsData object.</haxe_doc>
				</drawShape>
			</overloads>
		</drawShape>
		<new public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* The Graphics class contains methods used to draw primitive shapes such as lines, circles and
	 * rectangles to the display, and color and fill them.
	 *
	 * @class
	 * @extends Container
	 * @namespace PIXI</haxe_doc>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":native"><e>"PIXI.Graphics"</e></m>
		</meta>
	</class>
	<class path="pixi.core.graphics.GraphicsData" params="" file="C:\HaxeToolkit\haxe\lib\pixijs/3,0,25/pixi/core/graphics/GraphicsData.hx" extern="1">
		<lineWidth public="1"><x path="Float"/></lineWidth>
		<lineColor public="1"><c path="String"/></lineColor>
		<lineAlpha public="1"><x path="Float"/></lineAlpha>
		<fillColor public="1"><c path="String"/></fillColor>
		<fillAlpha public="1"><x path="Float"/></fillAlpha>
		<fill public="1"><c path="String"/></fill>
		<shape public="1"><d/></shape>
		<type public="1"><x path="Int"/></type>
		<clone public="1" set="method">
			<f a=""><c path="pixi.core.graphics.GraphicsData"/></f>
			<haxe_doc>* Creates a new GraphicsData object with the same values as this one.
	 *
	 * @return {GraphicsData}</haxe_doc>
		</clone>
		<new public="1" set="method">
			<f a="lineWidth:lineColor:lineAlpha:fillColor:fillAlpha:fill:shape">
				<x path="Float"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Int"/>
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>* A GraphicsData object.
	 *
	 * @class
	 * @namespace PIXI</haxe_doc>
		</new>
		<meta><m n=":native"><e>"PIXI.GraphicsData"</e></m></meta>
	</class>
	<class path="pixi.core.math.Matrix" params="" file="C:\HaxeToolkit\haxe\lib\pixijs/3,0,25/pixi/core/math/Matrix.hx" extern="1">
		<a public="1">
			<x path="Float"/>
			<haxe_doc>* @member {Float}
	 * @default 1</haxe_doc>
		</a>
		<b public="1">
			<x path="Float"/>
			<haxe_doc>* @member {Float}
	 * @default 0</haxe_doc>
		</b>
		<c public="1">
			<x path="Float"/>
			<haxe_doc>* @member {Float}
	 * @default 0</haxe_doc>
		</c>
		<d public="1">
			<x path="Float"/>
			<haxe_doc>* @member {Float}
	 * @default 1</haxe_doc>
		</d>
		<tx public="1">
			<x path="Float"/>
			<haxe_doc>* @member {Float}
	 * @default 0</haxe_doc>
		</tx>
		<ty public="1">
			<x path="Float"/>
			<haxe_doc>* @member {Float}
	 * @default 0</haxe_doc>
		</ty>
		<fromArray public="1" set="method">
			<f a="array">
				<c path="Array"><x path="Float"/></c>
				<x path="Void"/>
			</f>
			<haxe_doc>* Creates a Matrix object based on the given array. The Element to Matrix mapping order is as follows:
	 *
	 * a = array[0]
	 * b = array[1]
	 * c = array[3]
	 * d = array[4]
	 * tx = array[2]
	 * ty = array[5]
	 *
	 * @param array {Float[]} The array that the matrix will be populated from.</haxe_doc>
		</fromArray>
		<toArray public="1" set="method">
			<f a="transpose">
				<x path="Bool"/>
				<c path="Array"><x path="Float"/></c>
			</f>
			<haxe_doc>* Creates an array from the current Matrix object.
	 *
	 * @param transpose {Bool} Whether we need to transpose the matrix or not
	 * @return {Float[]} the newly created array which contains the matrix</haxe_doc>
		</toArray>
		<apply public="1" set="method">
			<f a="pos:?newPos">
				<c path="pixi.core.math.Point"/>
				<c path="pixi.core.math.Point"/>
				<c path="pixi.core.math.Point"/>
			</f>
			<haxe_doc>* Get a new position with the current transformation applied.
	 * Can be used to go from a child's coordinate space to the world coordinate space. (e.g. rendering)
	 *
	 * @param pos {Point} The origin
	 * @param [newPos] {Point} The point that the new position is assigned to (allowed to be same as input)
	 * @return {Point} The new point, transformed through this matrix</haxe_doc>
		</apply>
		<applyInverse public="1" set="method">
			<f a="pos:?newPos">
				<c path="pixi.core.math.Point"/>
				<c path="pixi.core.math.Point"/>
				<c path="pixi.core.math.Point"/>
			</f>
			<haxe_doc>* Get a new position with the inverse of the current transformation applied.
	 * Can be used to go from the world coordinate space to a child's coordinate space. (e.g. input)
	 *
	 * @param pos {Point} The origin
	 * @param [newPos] {Point} The point that the new position is assigned to (allowed to be same as input)
	 * @return {Point} The new point, inverse-transformed through this matrix</haxe_doc>
		</applyInverse>
		<translate public="1" set="method">
			<f a="x:y">
				<x path="Float"/>
				<x path="Float"/>
				<c path="pixi.core.math.Matrix"/>
			</f>
			<haxe_doc>* Translates the matrix on the x and y.
	 *
	 * @param {Float} x
	 * @param {Float} y
	 * @return {Matrix} This matrix. Good for chaining method calls.</haxe_doc>
		</translate>
		<scale public="1" set="method">
			<f a="x:y">
				<x path="Float"/>
				<x path="Float"/>
				<c path="pixi.core.math.Matrix"/>
			</f>
			<haxe_doc>* Applies a scale transformation to the matrix.
	 *
	 * @param {Float} x The amount to scale horizontally
	 * @param {Float} y The amount to scale vertically
	 * @return {Matrix} This matrix. Good for chaining method calls.</haxe_doc>
		</scale>
		<rotate public="1" set="method">
			<f a="angle">
				<x path="Float"/>
				<c path="pixi.core.math.Matrix"/>
			</f>
			<haxe_doc>* Applies a rotation transformation to the matrix.
	 *
	 * @param {Float} angle - The angle in radians.
	 * @return {Matrix} This matrix. Good for chaining method calls.</haxe_doc>
		</rotate>
		<append public="1" set="method">
			<f a="matrix">
				<c path="pixi.core.math.Matrix"/>
				<c path="pixi.core.math.Matrix"/>
			</f>
			<haxe_doc>* Appends the given Matrix to this Matrix.
	 *
	 * @param {Matrix} matrix
	 * @return {Matrix} This matrix. Good for chaining method calls.</haxe_doc>
		</append>
		<prepend public="1" set="method">
			<f a="matrix">
				<c path="pixi.core.math.Matrix"/>
				<c path="pixi.core.math.Matrix"/>
			</f>
			<haxe_doc>* Prepends the given Matrix to this Matrix.
	 *
	 * @param {Matrix} matrix
	 * @return {Matrix} This matrix. Good for chaining method calls.</haxe_doc>
		</prepend>
		<identity public="1" set="method">
			<f a=""><c path="pixi.core.math.Matrix"/></f>
			<haxe_doc>* Resets this Matix to an identity (default) matrix.
	 *
	 * @return {Matrix} This matrix. Good for chaining method calls.</haxe_doc>
		</identity>
		<invert public="1" set="method"><f a=""><c path="pixi.core.math.Matrix"/></f></invert>
		<clone public="1" set="method"><f a=""><c path="pixi.core.math.Matrix"/></f></clone>
		<copy public="1" set="method"><f a="matrix">
	<c path="pixi.core.math.Matrix"/>
	<c path="pixi.core.math.Matrix"/>
</f></copy>
		<new public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* The Matrix class is now an object, which makes it a lot faster,
	 * here is a representation of it :
	 * | a | b | tx|
	 * | c | d | ty|
	 * | 0 | 0 | 1 |
	 *
	 * @class
	 * @namespace PIXI</haxe_doc>
		</new>
		<meta><m n=":native"><e>"PIXI.Matrix"</e></m></meta>
	</class>
	<class path="pixi.core.math.Point" params="" file="C:\HaxeToolkit\haxe\lib\pixijs/3,0,25/pixi/core/math/Point.hx" extern="1">
		<clone public="1" set="method">
			<f a=""><c path="pixi.core.math.Point"/></f>
			<haxe_doc>* Creates a clone of this point
	 *
	 * @return {Point} a copy of the point</haxe_doc>
		</clone>
		<set public="1" set="method">
			<f a="?x:?y">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets the point to a new x and y position.
	 * If y is ommited, both x and y will be set to x.
	 *
	 * @method set
	 * @param [x=0] {Float} position of the point on the x axis
	 * @param [y=0] {Float} position of the point on the y axis</haxe_doc>
		</set>
		<x public="1">
			<x path="Float"/>
			<haxe_doc>* @property x
	 * @type Float
	 * @default 0</haxe_doc>
		</x>
		<y public="1">
			<x path="Float"/>
			<haxe_doc>* @property y
	 * @type Float
	 * @default 0</haxe_doc>
		</y>
		<new public="1" set="method">
			<f a="?x:?y">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* The Point object represents a location in a two-dimensional coordinate system, where x represents
	 * the horizontal axis and y represents the vertical axis.
	 *
	 * @class
	 * @namespace PIXI
	 * @param [x=0] {number} position of the point on the x axis
	 * @param [y=0] {number} position of the point on the y axis</haxe_doc>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":native"><e>"PIXI.Point"</e></m>
		</meta>
	</class>
	<class path="pixi.core.math.shapes.Circle" params="" file="C:\HaxeToolkit\haxe\lib\pixijs/3,0,25/pixi/core/math/shapes/Circle.hx" extern="1">
		<clone public="1" set="method">
			<f a=""><c path="pixi.core.math.shapes.Circle"/></f>
			<haxe_doc>* Creates a clone of this Circle instance
	 *
	 * @method clone
	 * @return {Circle} a copy of the circle</haxe_doc>
		</clone>
		<contains public="1" set="method">
			<f a="x:y">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Checks whether the x, and y coordinates passed to this function are contained within this circle
	 *
	 * @method contains
	 * @param x {Float} The X coordinate of the point to test
	 * @param y {Float} The Y coordinate of the point to test
	 * @return {Bool} Whether the x/y coordinates are within this polygon</haxe_doc>
		</contains>
		<getBounds public="1" set="method">
			<f a=""><c path="pixi.core.math.shapes.Rectangle"/></f>
			<haxe_doc>* Returns the framing rectangle of the circle as a PIXI.Rectangle object
	 *
	 * @method getBounds
	 * @return {Rectangle} the framing rectangle</haxe_doc>
		</getBounds>
		<x public="1">
			<x path="Float"/>
			<haxe_doc>* @property x
	 * @type Float
	 * @default 0</haxe_doc>
		</x>
		<y public="1">
			<x path="Float"/>
			<haxe_doc>* @property y
	 * @type Float
	 * @default 0</haxe_doc>
		</y>
		<radius public="1">
			<x path="Float"/>
			<haxe_doc>* @property radius
	 * @type Float
	 * @default 0</haxe_doc>
		</radius>
		<new public="1" set="method">
			<f a="x:y:radius">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* The Circle object can be used to specify a hit area for displayObjects
	 *
	 * @class Circle
	 * @constructor
	 * @param x {Float} The X coordinate of the center of this circle
	 * @param y {Float} The Y coordinate of the center of this circle
	 * @param radius {Float} The radius of the circle</haxe_doc>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":native"><e>"PIXI.Circle"</e></m>
		</meta>
	</class>
	<class path="pixi.core.math.shapes.Ellipse" params="" file="C:\HaxeToolkit\haxe\lib\pixijs/3,0,25/pixi/core/math/shapes/Ellipse.hx" extern="1">
		<clone public="1" set="method">
			<f a=""><c path="pixi.core.math.shapes.Ellipse"/></f>
			<haxe_doc>* Creates a clone of this Ellipse instance
	 *
	 * @method clone
	 * @return {Ellipse} a copy of the ellipse</haxe_doc>
		</clone>
		<contains public="1" set="method">
			<f a="x:y">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Checks whether the x and y coordinates passed to this function are contained within this ellipse
	 *
	 * @method contains
	 * @param x {Float} The X coordinate of the point to test
	 * @param y {Float} The Y coordinate of the point to test
	 * @return {Bool} Whether the x/y coords are within this ellipse</haxe_doc>
		</contains>
		<getBounds public="1" set="method">
			<f a=""><c path="pixi.core.math.shapes.Rectangle"/></f>
			<haxe_doc>* Returns the framing rectangle of the circle as a PIXI.Rectangle object
	 *
	 * @method getBounds
	 * @return {Rectangle} the framing rectangle</haxe_doc>
		</getBounds>
		<x public="1">
			<x path="Float"/>
			<haxe_doc>* @property x
	 * @type Float
	 * @default 0</haxe_doc>
		</x>
		<y public="1">
			<x path="Float"/>
			<haxe_doc>* @property y
	 * @type Float
	 * @default 0</haxe_doc>
		</y>
		<width public="1">
			<x path="Float"/>
			<haxe_doc>* @property width
	 * @type Float
	 * @default 0</haxe_doc>
		</width>
		<height public="1">
			<x path="Float"/>
			<haxe_doc>* @property height
	 * @type Float
	 * @default 0</haxe_doc>
		</height>
		<new public="1" set="method">
			<f a="x:y:width:height">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* The Ellipse object can be used to specify a hit area for displayObjects
	 *
	 * @class Ellipse
	 * @constructor
	 * @param x {Float} The X coordinate of the center of the ellipse
	 * @param y {Float} The Y coordinate of the center of the ellipse
	 * @param width {Float} The half width of this ellipse
	 * @param height {Float} The half height of this ellipse</haxe_doc>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":native"><e>"PIXI.Ellipse"</e></m>
		</meta>
	</class>
	<class path="pixi.core.math.shapes.Polygon" params="" file="C:\HaxeToolkit\haxe\lib\pixijs/3,0,25/pixi/core/math/shapes/Polygon.hx" extern="1">
		<clone public="1" set="method">
			<f a=""><c path="pixi.core.math.shapes.Polygon"/></f>
			<haxe_doc>* Creates a clone of this polygon
	 *
	 * @method clone
	 * @return {Polygon} a copy of the polygon</haxe_doc>
		</clone>
		<contains public="1" set="method">
			<f a="x:y">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Checks whether the x and y coordinates passed to this function are contained within this polygon
	 *
	 * @method contains
	 * @param x {Float} The X coordinate of the point to test
	 * @param y {Float} The Y coordinate of the point to test
	 * @return {Bool} Whether the x/y coordinates are within this polygon</haxe_doc>
		</contains>
		<points public="1">
			<c path="Array"><c path="pixi.core.math.Point"/></c>
			<haxe_doc><![CDATA[* An array of the points of this polygon
	 * @property points
	 * @type Array<Point>
	 *]]></haxe_doc>
		</points>
		<new public="1" set="method">
			<f a="points">
				<c path="Array"><c path="pixi.core.math.Point"/></c>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* @class Polygon
	 * @constructor
	 * @param points* {Array<Point>|Array<Number>|Point...|Number...} This can be an array of Points that form the polygon,
	 *      a flat array of numbers that will be interpreted as [x,y, x,y, ...], or the arguments passed can be
	 *      all the points of the polygon e.g. `new PIXI.Polygon(new PIXI.Point(), new PIXI.Point(), ...)`, or the
	 *      arguments passed can be flat x,y values e.g. `new PIXI.Polygon(x,y, x,y, x,y, ...)` where `x` and `y` are
	 *      Numbers.]]></haxe_doc>
			<overloads><new public="1" set="method">
	<f a="points">
		<c path="Array"><x path="Float"/></c>
		<x path="Void"/>
	</f>
	<haxe_doc><![CDATA[* @class Polygon
	 * @constructor
	 * @param points* {Array<Point>|Array<Number>|Point...|Number...} This can be an array of Points that form the polygon,
	 *      a flat array of numbers that will be interpreted as [x,y, x,y, ...], or the arguments passed can be
	 *      all the points of the polygon e.g. `new PIXI.Polygon(new PIXI.Point(), new PIXI.Point(), ...)`, or the
	 *      arguments passed can be flat x,y values e.g. `new PIXI.Polygon(x,y, x,y, x,y, ...)` where `x` and `y` are
	 *      Numbers.]]></haxe_doc>
</new></overloads>
		</new>
		<meta><m n=":native"><e>"PIXI.Polygon"</e></m></meta>
	</class>
	<class path="pixi.core.math.shapes.Rectangle" params="" file="C:\HaxeToolkit\haxe\lib\pixijs/3,0,25/pixi/core/math/shapes/Rectangle.hx" extern="1">
		<clone public="1" set="method">
			<f a=""><c path="pixi.core.math.shapes.Rectangle"/></f>
			<haxe_doc>* Creates a clone of this Rectangle instance
	 *
	 * @method clone
	 * @return {Rectangle} a copy of the rectangle</haxe_doc>
		</clone>
		<contains public="1" set="method">
			<f a="x:y">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Checks whether the x and y coordinates passed to this function are contained within this Rectangle
	 *
	 * @method contains
	 * @param x {Float} The X coordinate of the point to test
	 * @param y {Float} The Y coordinate of the point to test
	 * @return {Bool} Whether the x/y coords are within this Rectangle</haxe_doc>
		</contains>
		<x public="1">
			<x path="Float"/>
			<haxe_doc>* @property x
	 * @type Float
	 * @default 0</haxe_doc>
		</x>
		<y public="1">
			<x path="Float"/>
			<haxe_doc>* @property y
	 * @type Float
	 * @default 0</haxe_doc>
		</y>
		<width public="1">
			<x path="Float"/>
			<haxe_doc>* @property width
	 * @type Float
	 * @default 0</haxe_doc>
		</width>
		<height public="1">
			<x path="Float"/>
			<haxe_doc>* @property height
	 * @type Float
	 * @default 0</haxe_doc>
		</height>
		<new public="1" set="method">
			<f a="x:y:width:height">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* the Rectangle object is an area defined by its position, as indicated by its top-left corner point (x, y) and by its width and its height.
	 *
	 * @class Rectangle
	 * @constructor
	 * @param x {Float} The X coord of the upper-left corner of the rectangle
	 * @param y {Float} The Y coord of the upper-left corner of the rectangle
	 * @param width {Float} The overall width of this rectangle
	 * @param height {Float} The overall height of this rectangle</haxe_doc>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":native"><e>"PIXI.Rectangle"</e></m>
		</meta>
	</class>
	<class path="pixi.core.renderers.Detector" params="" file="C:\HaxeToolkit\haxe\lib\pixijs/3,0,25/pixi/core/renderers/Detector.hx" extern="1">
		<autoDetectRenderer public="1" set="method" static="1">
			<f a="width:height:?options:?noWebGL">
				<x path="Float"/>
				<x path="Float"/>
				<t path="pixi.core.renderers.RenderingOptions"/>
				<x path="Bool"/>
				<c path="pixi.core.renderers.webgl.WebGLRenderer"/>
			</f>
			<haxe_doc>* @class Detector</haxe_doc>
			<overloads><autoDetectRenderer public="1" set="method">
	<f a="width:height:?options:?noWebGL">
		<x path="Float"/>
		<x path="Float"/>
		<t path="pixi.core.renderers.RenderingOptions"/>
		<x path="Bool"/>
		<c path="pixi.core.renderers.canvas.CanvasRenderer"/>
	</f>
	<haxe_doc>* @class Detector</haxe_doc>
</autoDetectRenderer></overloads>
		</autoDetectRenderer>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":native"><e>"PIXI"</e></m>
		</meta>
	</class>
	<typedef path="pixi.core.renderers.RenderingOptions" params="" file="C:\HaxeToolkit\haxe\lib\pixijs/3,0,25/pixi/core/renderers/Detector.hx" module="pixi.core.renderers.Detector"><a>
	<view>
		<t path="Null"><c path="js.html.CanvasElement"/></t>
		<meta><m n=":optional"/></meta>
	</view>
	<transparent>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</transparent>
	<resolution>
		<t path="Null"><x path="Float"/></t>
		<meta><m n=":optional"/></meta>
	</resolution>
	<preserveDrawingBuffer>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</preserveDrawingBuffer>
	<forceFXAA>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</forceFXAA>
	<clearBeforeRender>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</clearBeforeRender>
	<backgroundColor>
		<t path="Null"><x path="Int"/></t>
		<meta><m n=":optional"/></meta>
	</backgroundColor>
	<autoResize>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</autoResize>
	<antialias>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</antialias>
</a></typedef>
	<class path="pixi.core.renderers.SystemRenderer" params="" file="C:\HaxeToolkit\haxe\lib\pixijs/3,0,25/pixi/core/renderers/SystemRenderer.hx" extern="1">
		<extends path="pixi.interaction.EventEmitter"/>
		<type public="1">
			<x path="Int"/>
			<haxe_doc>* The type of the renderer.
	 *
	 * @member {CONST.RENDERER_TYPE}
	 * @default CONT.RENDERER_TYPE.UNKNOWN</haxe_doc>
		</type>
		<width public="1">
			<x path="Float"/>
			<haxe_doc>* The width of the canvas view
	 *
	 * @member {Float}
	 * @default 800</haxe_doc>
		</width>
		<height public="1">
			<x path="Float"/>
			<haxe_doc>* The height of the canvas view
	 *
	 * @member {Float}
	 * @default 600</haxe_doc>
		</height>
		<view public="1">
			<c path="js.html.CanvasElement"/>
			<haxe_doc>* The canvas element that everything is drawn to
	 *
	 * @member {CanvasElement}</haxe_doc>
		</view>
		<resolution public="1">
			<x path="Float"/>
			<haxe_doc>* The resolution of the renderer
	 *
	 * @member {Float}
	 * @default 1</haxe_doc>
		</resolution>
		<transparent public="1">
			<x path="Bool"/>
			<haxe_doc>* Whether the render view is transparent
	 *
	 * @member {Bool}</haxe_doc>
		</transparent>
		<autoResize public="1">
			<x path="Bool"/>
			<haxe_doc>* Whether the render view should be resized automatically
	 *
	 * @member {Bool}</haxe_doc>
		</autoResize>
		<blendModes public="1">
			<d/>
			<haxe_doc><![CDATA[* Tracks the blend modes useful for this renderer.
	 *
	 * @member {object<string, mixed>}]]></haxe_doc>
		</blendModes>
		<preserveDrawingBuffer public="1">
			<x path="Bool"/>
			<haxe_doc>* The value of the preserveDrawingBuffer flag affects whether or not the contents of the stencil buffer is retained after rendering.
	 *
	 * @member {Bool}</haxe_doc>
		</preserveDrawingBuffer>
		<clearBeforeRender public="1">
			<x path="Bool"/>
			<haxe_doc>* This sets if the CanvasRenderer will clear the canvas or not before the new render pass.
	 * If the scene is NOT transparent Pixi will use a canvas sized fillRect operation every frame to set the canvas background color.
	 * If the scene is transparent Pixi will use clearRect to clear the canvas every frame.
	 * Disable this by setting this to false. For example if your game has a canvas filling background image you often don't need this set.
	 *
	 * @member {Bool}
	 * @default</haxe_doc>
		</clearBeforeRender>
		<backgroundColor public="1">
			<x path="Int"/>
			<haxe_doc>* The background color to fill if not transparent
	 *
	 * @member {Int}
	 * @default 0x000000</haxe_doc>
		</backgroundColor>
		<plugins public="1">
			<d/>
			<haxe_doc>* Plugins object</haxe_doc>
		</plugins>
		<resize public="1" set="method">
			<f a="width:height">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Resizes the canvas view to the specified width and height
	 *
	 * @param width {Float} the new width of the canvas view
	 * @param height {Float} the new height of the canvas view</haxe_doc>
		</resize>
		<destroy public="1" set="method">
			<f a="?removeView" v="false">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{removeView:false}</e></m></meta>
			<haxe_doc>* Removes everything from the renderer and optionally removes the Canvas DOM element.
	 *
	 * @param [removeView=false] {Bool} Removes the Canvas element from the DOM.</haxe_doc>
		</destroy>
		<render public="1" set="method">
			<f a="object">
				<c path="pixi.core.display.DisplayObject"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Renders the object to canvas/webGL view
	 *
	 * @param object {DisplayObject} the object to be rendered</haxe_doc>
		</render>
		<new public="1" set="method">
			<f a="system:?width:?height:?options" v=":800:600:">
				<c path="String"/>
				<x path="Float"/>
				<x path="Float"/>
				<t path="pixi.core.renderers.RenderingOptions"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{height:600,width:800}</e></m></meta>
			<haxe_doc>* The CanvasRenderer draws the scene and all its content onto a 2d canvas. This renderer should be used for browsers that do not support webGL.
	 * Don't forget to add the CanvasRenderer.view to your DOM or you will not see anything :)
	 *
	 * @class
	 * @namespace PIXI
	 * @param system {string} The name of the system this renderer is for.
	 * @param [width=800] {number} the width of the canvas view
	 * @param [height=600] {number} the height of the canvas view
	 * @param [options] {object} The optional renderer parameters
	 * @param [options.view] {HTMLCanvasElement} the canvas to use as a view, optional
	 * @param [options.transparent=false] {boolean} If the render view is transparent, default false
	 * @param [options.autoResize=false] {boolean} If the render view is automatically resized, default false
	 * @param [options.antialias=false] {boolean} sets antialias (only applicable in chrome at the moment)
	 * @param [options.resolution=1] {number} the resolution of the renderer retina would be 2
	 * @param [options.clearBeforeRender=true] {boolean} This sets if the CanvasRenderer will clear the canvas or
	 *      not before the new render pass.</haxe_doc>
		</new>
		<meta><m n=":native"><e>"PIXI.SystemRenderer"</e></m></meta>
	</class>
	<class path="pixi.core.renderers.canvas.CanvasRenderer" params="" file="C:\HaxeToolkit\haxe\lib\pixijs/3,0,25/pixi/core/renderers/canvas/CanvasRenderer.hx" extern="1">
		<extends path="pixi.core.renderers.SystemRenderer"/>
		<context public="1">
			<c path="js.html.CanvasRenderingContext2D"/>
			<haxe_doc>* The canvas 2d context that everything is drawn with.
	 *
	 * @member {CanvasRenderingContext2D}</haxe_doc>
		</context>
		<refresh public="1">
			<x path="Bool"/>
			<haxe_doc>* Boolean flag controlling canvas refresh.
	 *
	 * @member {Bool}</haxe_doc>
		</refresh>
		<maskManager public="1">
			<d/>
			<haxe_doc>* Instance of a CanvasMaskManager, handles masking when using the canvas renderer.
	 *
	 * @member {CanvasMaskManager}</haxe_doc>
		</maskManager>
		<roundPixels public="1">
			<x path="Bool"/>
			<haxe_doc>* If true Pixi will Math.floor() x/y values when rendering, stopping pixel interpolation.
	 * Handy for crisp pixel art and speed on legacy devices.
	 *
	 * @member {Bool}</haxe_doc>
		</roundPixels>
		<currentScaleMode public="1">
			<x path="Int"/>
			<haxe_doc>* Tracks the active scale mode for this renderer.
	 *
	 * @member {SCALE_MODE}</haxe_doc>
		</currentScaleMode>
		<currentBlendMode public="1">
			<x path="Int"/>
			<haxe_doc>* Tracks the active blend mode for this renderer.
	 *
	 * @member {BLEND_MODES}</haxe_doc>
		</currentBlendMode>
		<smoothProperty public="1">
			<c path="String"/>
			<haxe_doc>* The canvas property used to set the canvas smoothing property.
	 *
	 * @member {String}</haxe_doc>
		</smoothProperty>
		<new public="1" set="method">
			<f a="width:height:?options">
				<x path="Float"/>
				<x path="Float"/>
				<t path="pixi.core.renderers.RenderingOptions"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* The CanvasRenderer draws the scene and all its content onto a 2d canvas. This renderer should be used for browsers that do not support webGL.
	 * Don't forget to add the CanvasRenderer.view to your DOM or you will not see anything :)
	 *
	 * @class
	 * @namespace PIXI
	 * @param system {string} The name of the system this renderer is for.
	 * @param [width=800] {number} the width of the canvas view
	 * @param [height=600] {number} the height of the canvas view
	 * @param [options] {object} The optional renderer parameters
	 * @param [options.view] {HTMLCanvasElement} the canvas to use as a view, optional
	 * @param [options.transparent=false] {boolean} If the render view is transparent, default false
	 * @param [options.autoResize=false] {boolean} If the render view is automatically resized, default false
	 * @param [options.antialias=false] {boolean} sets antialias (only applicable in chrome at the moment)
	 * @param [options.resolution=1] {number} the resolution of the renderer retina would be 2
	 * @param [options.clearBeforeRender=true] {boolean} This sets if the CanvasRenderer will clear the canvas or
	 *      not before the new render pass.</haxe_doc>
		</new>
		<meta><m n=":native"><e>"PIXI.CanvasRenderer"</e></m></meta>
	</class>
	<class path="pixi.core.renderers.webgl.WebGLRenderer" params="" file="C:\HaxeToolkit\haxe\lib\pixijs/3,0,25/pixi/core/renderers/webgl/WebGLRenderer.hx" extern="1">
		<extends path="pixi.core.renderers.SystemRenderer"/>
		<drawCount public="1">
			<x path="Int"/>
			<haxe_doc>* Counter for the number of draws made each frame
	 *
	 * @member {Int}</haxe_doc>
		</drawCount>
		<shaderManager public="1">
			<d/>
			<haxe_doc>* Deals with managing the shader programs and their attribs.
     *
     * @member {ShaderManager}</haxe_doc>
		</shaderManager>
		<maskManager public="1">
			<c path="pixi.core.renderers.webgl.managers.MaskManager"/>
			<haxe_doc>* Manages the masks using the stencil buffer.
     *
     * @member {MaskManager}</haxe_doc>
		</maskManager>
		<stencilManager public="1">
			<d/>
			<haxe_doc>* Manages the stencil buffer.
     *
     * @member {StencilManager}</haxe_doc>
		</stencilManager>
		<filterManager public="1">
			<c path="pixi.core.renderers.webgl.managers.FilterManager"/>
			<haxe_doc>* Manages the filters.
     *
     * @member {FilterManager}</haxe_doc>
		</filterManager>
		<blendModeManager public="1">
			<c path="pixi.core.renderers.webgl.managers.BlendModeManager"/>
			<haxe_doc>* Manages the blendModes
     * @member {BlendModeManager}</haxe_doc>
		</blendModeManager>
		<currentRenderTarget public="1">
			<d/>
			<haxe_doc>* Holds the current render target
     * @member {Object}</haxe_doc>
		</currentRenderTarget>
		<currentRenderer public="1">
			<d/>
			<haxe_doc>* object renderer @alvin
     * @member {ObjectRenderer}</haxe_doc>
		</currentRenderer>
		<new public="1" set="method">
			<f a="width:height:?options">
				<x path="Float"/>
				<x path="Float"/>
				<t path="pixi.core.renderers.RenderingOptions"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* The WebGLRenderer draws the scene and all its content onto a webGL enabled canvas. This renderer
	 * should be used for browsers that support webGL. This Render works by automatically managing webGLBatchs.
	 * So no need for Sprite Batches or Sprite Clouds.
	 * Don't forget to add the view to your DOM or you will not see anything :)
	 *
	 * @class
	 * @namespace PIXI
	 * @param [width=0] {number} the width of the canvas view
	 * @param [height=0] {number} the height of the canvas view
	 * @param [options] {object} The optional renderer parameters
	 * @param [options.view] {HTMLCanvasElement} the canvas to use as a view, optional
	 * @param [options.transparent=false] {boolean} If the render view is transparent, default false
	 * @param [options.autoResize=false] {boolean} If the render view is automatically resized, default false
	 * @param [options.antialias=false] {boolean} sets antialias (only applicable in chrome at the moment)
	 * @param [options.resolution=1] {number} the resolution of the renderer retina would be 2
	 * @param [options.clearBeforeRender=true] {boolean} This sets if the CanvasRenderer will clear the canvas or
	 *      not before the new render pass.
	 * @param [options.preserveDrawingBuffer=false] {boolean} enables drawing buffer preservation, enable var if
	 *      you need to call toDataUrl on the webgl context.</haxe_doc>
		</new>
		<meta><m n=":native"><e>"PIXI.WebGLRenderer"</e></m></meta>
	</class>
	<class path="pixi.core.renderers.webgl.managers.WebGLManager" params="" file="C:\HaxeToolkit\haxe\lib\pixijs/3,0,25/pixi/core/renderers/webgl/managers/WebGLManager.hx" extern="1">
		<onContextChange public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Generic method called when there is a WebGL context change.
	 *</haxe_doc>
		</onContextChange>
		<destroy public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Generic destroy methods to be overridden by the subclass
	 *</haxe_doc>
		</destroy>
		<new public="1" set="method">
			<f a="renderer">
				<c path="pixi.core.renderers.webgl.WebGLRenderer"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* @class
	 * @memberof PIXI
	 * @param renderer {WebGLRenderer} The renderer this manager works for.</haxe_doc>
		</new>
	</class>
	<class path="pixi.core.renderers.webgl.managers.BlendModeManager" params="" file="C:\HaxeToolkit\haxe\lib\pixijs/3,0,25/pixi/core/renderers/webgl/managers/BlendModeManager.hx" extern="1">
		<extends path="pixi.core.renderers.webgl.managers.WebGLManager"/>
		<setBlendMode public="1" set="method">
			<f a="blendMode">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets-up the given blendMode from WebGL's point of view.
	 *
	 * @param blendMode {number} the blendMode, should be a Pixi const, such as BlendModes.ADD</haxe_doc>
		</setBlendMode>
		<new public="1" set="method">
			<f a="renderer">
				<c path="pixi.core.renderers.webgl.WebGLRenderer"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* @class
	 * @memberof PIXI
	 * @extends WebGlManager
	 * @param renderer {WebGLRenderer} The renderer this manager works for.</haxe_doc>
		</new>
	</class>
	<class path="pixi.core.renderers.webgl.managers.FilterManager" params="" file="C:\HaxeToolkit\haxe\lib\pixijs/3,0,25/pixi/core/renderers/webgl/managers/FilterManager.hx" extern="1">
		<extends path="pixi.core.renderers.webgl.managers.WebGLManager"/>
		<filterStack public="1">
			<c path="Array"><d/></c>
			<haxe_doc>* @member {any[]}</haxe_doc>
		</filterStack>
		<texturePool public="1">
			<c path="Array"><d/></c>
			<haxe_doc>* @member {any[]}</haxe_doc>
		</texturePool>
		<setFilterStack public="1" set="method">
			<f a="filterStack">
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>* @param renderer {WebGLRenderer}
	 * @param buffer {ArrayBuffer}</haxe_doc>
		</setFilterStack>
		<pushFilter public="1" set="method">
			<f a="target:filters">
				<d/>
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Applies the filter and adds it to the current filter stack.
	 *
	 * @param filterBlock {object} the filter that will be pushed to the current filter stack</haxe_doc>
		</pushFilter>
		<popFilter public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Removes the last filter from the filter stack and returns it.
	 *</haxe_doc>
		</popFilter>
		<getRenderTarget public="1" set="method">
			<f a="?clear">
				<x path="Bool"/>
				<d/>
			</f>
			<haxe_doc>* Grabs an render target from the internal pool
	 *
	 * @param clear {Bool} Whether or not we need to clear the RenderTarget
	 * @return {RenderTarget}</haxe_doc>
		</getRenderTarget>
		<returnRenderTarget public="1" set="method"><f a="renderTarget">
	<d/>
	<d/>
</f></returnRenderTarget>
		<applyFilter public="1" set="method"><f a="shader:inputTarget:outputTarget:?clear">
	<d/>
	<d/>
	<d/>
	<x path="Bool"/>
	<x path="Void"/>
</f></applyFilter>
		<capFilterArea public="1" set="method"><f a="filterArea">
	<c path="pixi.core.math.shapes.Rectangle"/>
	<x path="Void"/>
</f></capFilterArea>
		<resize public="1" set="method"><f a="width:height">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></resize>
		<new public="1" set="method">
			<f a="renderer">
				<c path="pixi.core.renderers.webgl.WebGLRenderer"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* @class
	 * @memberof PIXI
	 * @extends WebGlManager
	 * @param renderer {WebGLRenderer} The renderer this manager works for.</haxe_doc>
		</new>
	</class>
	<class path="pixi.core.renderers.webgl.managers.MaskManager" params="" file="C:\HaxeToolkit\haxe\lib\pixijs/3,0,25/pixi/core/renderers/webgl/managers/MaskManager.hx" extern="1">
		<extends path="pixi.core.renderers.webgl.managers.WebGLManager"/>
		<pushMask public="1" set="method">
			<f a="target:maskData">
				<d/>
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Applies the Mask and adds it to the current filter stack.
	 *
	 * @param graphics {Graphics}
	 * @param webGLData {any[]}</haxe_doc>
		</pushMask>
		<popMask public="1" set="method">
			<f a="target:maskData">
				<d/>
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Removes the last mask from the mask stack and doesn't return it.
	 *
	 * @param target {RenderTarget}
	 * @param maskData {any[]}</haxe_doc>
		</popMask>
		<pushSpriteMask public="1" set="method">
			<f a="target:maskData">
				<d/>
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Applies the Mask and adds it to the current filter stack.
	 *
	 * @param target {RenderTarget}
	 * @param maskData {any[]}</haxe_doc>
		</pushSpriteMask>
		<popSpriteMask public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Removes the last filter from the filter stack and doesn't return it.
	 *</haxe_doc>
		</popSpriteMask>
		<pushStencilMask public="1" set="method">
			<f a="target:maskData">
				<d/>
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Applies the Mask and adds it to the current filter stack.
	 *
	 * @param target {RenderTarget}
	 * @param maskData {any[]}</haxe_doc>
		</pushStencilMask>
		<popStencilMask public="1" set="method">
			<f a="target:maskData">
				<d/>
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Removes the last filter from the filter stack and doesn't return it.
	 * @param target {RenderTarget}
	 * @param maskData {any[]}</haxe_doc>
		</popStencilMask>
		<new public="1" set="method">
			<f a="renderer">
				<c path="pixi.core.renderers.webgl.WebGLRenderer"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* @class
	 * @memberof PIXI
	 * @param renderer {WebGLRenderer} The renderer this manager works for.</haxe_doc>
		</new>
	</class>
	<class path="pixi.core.sprites.Sprite" params="" file="C:\HaxeToolkit\haxe\lib\pixijs/3,0,25/pixi/core/sprites/Sprite.hx" extern="1">
		<extends path="pixi.core.display.Container"/>
		<fromFrame public="1" set="method" static="1">
			<f a="frameId">
				<c path="String"/>
				<c path="pixi.core.sprites.Sprite"/>
			</f>
			<haxe_doc>* Helper function that creates a sprite that will contain a texture from the TextureCache based on the frameId
	 * The frame ids are created when a Texture packer file has been loaded
	 *
	 * @static
	 * @param frameId {String} The frame Id of the texture in the cache
	 * @return {Sprite} A new Sprite using a texture from the texture cache matching the frameId</haxe_doc>
		</fromFrame>
		<fromImage public="1" set="method" static="1">
			<f a="imageId:?crossorigin:?scaleMode">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Int"/>
				<c path="pixi.core.sprites.Sprite"/>
			</f>
			<haxe_doc>* Helper function that creates a sprite that will contain a texture based on an image url
	 * If the image is not in the texture cache it will be loaded
	 *
	 * @static
	 * @param imageId {String} The image url of the texture
	 * @return {Sprite} A new Sprite using a texture from the texture cache matching the image id</haxe_doc>
		</fromImage>
		<anchor public="1">
			<c path="pixi.core.math.Point"/>
			<haxe_doc>* The anchor sets the origin point of the texture.
	 * The default is 0,0 this means the texture's origin is the top left
	 * Setting than anchor to 0.5,0.5 means the textures origin is centered
	 * Setting the anchor to 1,1 would mean the textures origin points will be the bottom right corner
	 *
	 * @member {Point}</haxe_doc>
		</anchor>
		<texture public="1">
			<c path="pixi.core.textures.Texture"/>
			<haxe_doc>* The height of the sprite, setting this will actually modify the scale to achieve the value set
	 *
	 * @member
	 * @memberof Sprite#</haxe_doc>
		</texture>
		<tint public="1">
			<x path="Int"/>
			<haxe_doc>* The tint applied to the sprite. This is a hex value. A value of 0xFFFFFF will remove any tint effect.
	 *
	 * @member {Int}
	 * @default 0xFFFFFF</haxe_doc>
		</tint>
		<blendMode public="1">
			<x path="Int"/>
			<haxe_doc>* The blend mode to be applied to the sprite. Set to CONST.blendModes.NORMAL to remove any blend mode.
	 *
	 * @member {Int}
	 * @default CONST.blendModes.NORMAL;</haxe_doc>
		</blendMode>
		<shader public="1">
			<d/>
			<haxe_doc>* The shader that will be used to render the sprite. Set to null to remove a current shader.
	 *
	 * @member {AbstractFilter}</haxe_doc>
		</shader>
		<renderCanvas public="1" set="method">
			<f a="renderer">
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Renders the object using the Canvas renderer
	*
	* @param renderer {CanvasRenderer} The renderer</haxe_doc>
		</renderCanvas>
		<new public="1" set="method">
			<f a="texture">
				<c path="pixi.core.textures.Texture"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* The Sprite object is the base for all textured objects that are rendered to the screen
	 *
	 * A sprite can be created directly from an image like this:
	 *
	 * ```js
	 * 	var sprite = new Sprite.fromImage('assets/image.png');
	 * ```
	 *
	 * @class Sprite
	 * @extends Container
	 * @namespace PIXI
	 * @param texture {Texture} The texture for this sprite</haxe_doc>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":native"><e>"PIXI.Sprite"</e></m>
		</meta>
	</class>
	<class path="pixi.core.text.Text" params="" file="C:\HaxeToolkit\haxe\lib\pixijs/3,0,25/pixi/core/text/Text.hx" extern="1">
		<extends path="pixi.core.sprites.Sprite"/>
		<canvas public="1">
			<c path="js.html.CanvasElement"/>
			<haxe_doc>* The canvas element that everything is drawn to
	 *
	 * @member {HTMLCanvasElement}</haxe_doc>
		</canvas>
		<context public="1">
			<c path="js.html.CanvasRenderingContext2D"/>
			<haxe_doc>* The canvas 2d context that everything is drawn with
	 * @member {HTMLCanvasElement}</haxe_doc>
		</context>
		<resolution public="1">
			<x path="Float"/>
			<haxe_doc>* The resolution of the canvas.
	 * @member {number}</haxe_doc>
		</resolution>
		<style public="1">
			<t path="pixi.core.text.TextStyle"/>
			<haxe_doc>* Set the style of the text
     *
	 * @param [style.font] {String} default 'bold 20px Arial' The style and size of the font
	 * @param [style.fill='black'] {String} A canvas fillstyle that will be used on the text e.g 'red', '#00FF00'
	 * @param [style.align='left'] {String} Alignment for multiline text ('left', 'center' or 'right'), does not affect single line text
	 * @param [style.stroke] {String} A canvas fillstyle that will be used on the text stroke e.g 'blue', '#FCFF00'
	 * @param [style.strokeThickness=0] {Float} A number that represents the thickness of the stroke. Default is 0 (no stroke)
	 * @param [style.wordWrap=false] {Bool} Indicates if word wrap should be used
	 * @param [style.wordWrapWidth=100] {Float} The width at which text will wrap, it needs wordWrap to be set to true
	 * @param [style.lineHeight] {Float} The line height, a number that represents the vertical space that a letter uses
	 * @param [style.dropShadow=false] {Bool} Set a drop shadow for the text
	 * @param [style.dropShadowColor='#000000'] {string} A fill style to be used on the dropshadow e.g 'red', '#00FF00'
	 * @param [style.dropShadowAngle=Math.PI/4] {number} Set a angle of the drop shadow
	 * @param [style.dropShadowDistance=5] {Float} Set a distance of the drop shadow
	 * @param [style.padding=0] {number} Occasionally some fonts are cropped on top or bottom. Adding some padding will
	 *      prevent this from happening by adding padding to the top and bottom of text height.
	 * @param [style.textBaseline='alphabetic'] {String} The baseline of the text that is rendered.
	 * @param [style.lineJoin='miter'] {String} The lineJoin property sets the type of corner created, it can resolve
	 *      spiked text issues. Default is 'miter' (creates a sharp corner).
	 * @param [style.miterLimit=10] {Int} The miter limit to use when using the 'miter' lineJoin mode. This can reduce
	 *      or increase the spikiness of rendered text.
     * @memberof Text#</haxe_doc>
		</style>
		<text public="1">
			<c path="String"/>
			<haxe_doc>* Set the copy for the text object. To split a line you can use '\n'.
     *
     * @param text {String} The copy that you would like the text to display
     * @memberof Text#</haxe_doc>
		</text>
		<new public="1" set="method">
			<f a="text:?style:?resolution">
				<c path="String"/>
				<t path="pixi.core.text.TextStyle"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* A Text Object will create a line or multiple lines of text. To split a line you can use '\n' in your text string,
	 * or add a wordWrap property set to true and and wordWrapWidth property with a value in the style object.
	 *
	 * A Text can be created directly from a string and a style object
	 *
	 * ```js
	 * var text = new PIXI.Text('This is a pixi text',{font : '24px Arial', fill : 0xff1010, align : 'center'});
	 * ```
	 *
	 * @class
	 * @extends PIXI.Sprite
	 * @memberof PIXI
	 * @param text {string} The copy that you would like the text to display
	 * @param [style] {TextStyle} The style parameters
	 * @param [style.font] {String} default 'bold 20px Arial' The style and size of the font
	 * @param [style.fill='black'] {String} A canvas fillstyle that will be used on the text e.g 'red', '#00FF00'
	 * @param [style.align='left'] {String} Alignment for multiline text ('left', 'center' or 'right'), does not affect single line text
	 * @param [style.stroke] {String} A canvas fillstyle that will be used on the text stroke e.g 'blue', '#FCFF00'
	 * @param [style.strokeThickness=0] {Float} A number that represents the thickness of the stroke. Default is 0 (no stroke)
	 * @param [style.wordWrap=false] {Bool} Indicates if word wrap should be used
	 * @param [style.wordWrapWidth=100] {Float} The width at which text will wrap, it needs wordWrap to be set to true
	 * @param [style.lineHeight] {Float} The line height, a number that represents the vertical space that a letter uses
	 * @param [style.dropShadow=false] {Bool} Set a drop shadow for the text
	 * @param [style.dropShadowColor='#000000'] {string} A fill style to be used on the dropshadow e.g 'red', '#00FF00'
	 * @param [style.dropShadowAngle=Math.PI/4] {number} Set a angle of the drop shadow
	 * @param [style.dropShadowDistance=5] {Float} Set a distance of the drop shadow
	 * @param [style.padding=0] {number} Occasionally some fonts are cropped on top or bottom. Adding some padding will
	 *      prevent this from happening by adding padding to the top and bottom of text height.
	 * @param [style.textBaseline='alphabetic'] {String} The baseline of the text that is rendered.
	 * @param [style.lineJoin='miter'] {String} The lineJoin property sets the type of corner created, it can resolve
	 *      spiked text issues. Default is 'miter' (creates a sharp corner).
	 * @param [style.miterLimit=10] {Int} The miter limit to use when using the 'miter' lineJoin mode. This can reduce
	 *      or increase the spikiness of rendered text.</haxe_doc>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":native"><e>"PIXI.Text"</e></m>
		</meta>
	</class>
	<typedef path="pixi.core.text.TextStyle" params="" file="C:\HaxeToolkit\haxe\lib\pixijs/3,0,25/pixi/core/text/Text.hx" module="pixi.core.text.Text"><a>
	<wordWrapWidth>
		<t path="Null"><x path="Float"/></t>
		<meta><m n=":optional"/></meta>
	</wordWrapWidth>
	<wordWrap>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</wordWrap>
	<textBaseline>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</textBaseline>
	<strokeThickness>
		<t path="Null"><x path="Float"/></t>
		<meta><m n=":optional"/></meta>
	</strokeThickness>
	<stroke>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</stroke>
	<padding>
		<t path="Null"><x path="Float"/></t>
		<meta><m n=":optional"/></meta>
	</padding>
	<miterLimit>
		<t path="Null"><x path="Int"/></t>
		<meta><m n=":optional"/></meta>
	</miterLimit>
	<lineJoin>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</lineJoin>
	<lineHeight>
		<t path="Null"><x path="Float"/></t>
		<meta><m n=":optional"/></meta>
	</lineHeight>
	<font>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</font>
	<fill>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</fill>
	<dropShadowDistance>
		<t path="Null"><x path="Float"/></t>
		<meta><m n=":optional"/></meta>
	</dropShadowDistance>
	<dropShadowColor>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</dropShadowColor>
	<dropShadowAngle>
		<t path="Null"><x path="Float"/></t>
		<meta><m n=":optional"/></meta>
	</dropShadowAngle>
	<dropShadow>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</dropShadow>
	<align>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</align>
</a></typedef>
	<class path="pixi.core.textures.BaseTexture" params="" file="C:\HaxeToolkit\haxe\lib\pixijs/3,0,25/pixi/core/textures/BaseTexture.hx" extern="1">
		<extends path="pixi.interaction.EventEmitter"/>
		<fromImage public="1" set="method" static="1">
			<f a="imageUrl:?crossorigin:?scaleMode">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Int"/>
				<c path="pixi.core.textures.BaseTexture"/>
			</f>
			<haxe_doc>* Helper function that creates a base texture from the given image url.
	 * If the image is not in the base texture cache it will be created and loaded.
	 *
	 * @static
	 * @param imageUrl {String} The image url of the texture
	 * @param [crossorigin=(auto)] {Bool} Should use anonymouse CORS? Defaults to true if the URL is not a data-URI.
	 * @param [scaleMode=scaleModes.DEFAULT] {Int} See {@link scaleModes} for possible values
	 * @return BaseTexture</haxe_doc>
		</fromImage>
		<fromCanvas public="1" set="method" static="1">
			<f a="canvas:?scaleMode">
				<c path="js.html.CanvasElement"/>
				<x path="Int"/>
				<c path="pixi.core.textures.BaseTexture"/>
			</f>
			<haxe_doc>* Helper function that creates a base texture from the given canvas element.
	 *
	 * @static
	 * @param canvas {Canvas} The canvas element source of the texture
	 * @param scaleMode {Int} See {{#crossLink "PIXI/scaleModes:property"}}scaleModes{{/crossLink}} for possible values
	 * @return BaseTexture</haxe_doc>
		</fromCanvas>
		<resolution public="1">
			<x path="Float"/>
			<haxe_doc>* The Resolution of the texture.
	 *
	 * @member {Float}</haxe_doc>
		</resolution>
		<width public="1">
			<x path="Float"/>
			<haxe_doc>* The width of the base texture set when the image has loaded
	 *
	 * @member {Float}
	 * @readOnly</haxe_doc>
		</width>
		<height public="1">
			<x path="Float"/>
			<haxe_doc>* The height of the base texture set when the image has loaded
	 *
	 * @member {Float}
	 * @readOnly</haxe_doc>
		</height>
		<scaleMode public="1">
			<x path="Int"/>
			<haxe_doc>* The scale mode to apply when scaling this texture
	 *
	 * @member {Int}
	 * @default scaleModes.LINEAR</haxe_doc>
		</scaleMode>
		<hasLoaded public="1">
			<x path="Bool"/>
			<haxe_doc>* Set to true once the base texture has successfully loaded.
	 *
	 * This is never true if the underlying source fails to load or has no texture data.
	 *
	 * @member {Bool}
	 * @readOnly</haxe_doc>
		</hasLoaded>
		<isLoading public="1">
			<x path="Bool"/>
			<haxe_doc>* Set to true if the source is currently loading.
	 *
	 * If an Image source is loading the 'loaded' or 'error' event will be
	 * dispatched when the operation ends. An underyling source that is
	 * immediately-available bypasses loading entirely.
	 *
	 * @member {Bool}
	 * @readonly</haxe_doc>
		</isLoading>
		<source public="1">
			<d/>
			<haxe_doc>* The image source that is used to create the texture.
	 *
	 * @member {Image|Canvas}
	 * @readonly</haxe_doc>
		</source>
		<premultipliedAlpha public="1">
			<x path="Bool"/>
			<haxe_doc>* Controls if RGB channels should be pre-multiplied by Alpha  (WebGL only)
	 *
	 * @member {Bool}
	 * @default true</haxe_doc>
		</premultipliedAlpha>
		<imageUrl public="1">
			<c path="String"/>
			<haxe_doc>* @member {String}</haxe_doc>
		</imageUrl>
		<mipmap public="1">
			<x path="Bool"/>
			<haxe_doc>*
	 * Set this to true if a mipmap of this texture needs to be generated. This value needs to be set before the texture is used
	 * Also the texture must be a power of two size to work
	 *
	 * @member {Bool}</haxe_doc>
		</mipmap>
		<update public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Updates the texture on all the webgl renderers.
	 *
	 * @fires update</haxe_doc>
		</update>
		<destroy public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Destroys this base texture
	 *</haxe_doc>
		</destroy>
		<dispose public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Frees the texture from WebGL memory without destroying this texture object.
	 * This means you can still use the texture later which will upload it to GPU
	 * memory again.
	 *</haxe_doc>
		</dispose>
		<loadSource public="1" set="method">
			<f a="source">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Load a source.
	 *
	 * If the source is not-immediately-available, such as an image that needs to be
	 * downloaded, then the 'loaded' or 'error' event will be dispatched in the future
	 * and `hasLoaded` will remain false after this call.
	 *
	 * The logic state after calling `loadSource` directly or indirectly (eg. `fromImage`, `new BaseTexture`) is:
	 *
	 *     if (texture.hasLoaded) {
	 *        // texture ready for use
	 *     } else if (texture.isLoading) {
	 *        // listen to 'loaded' and/or 'error' events on texture
	 *     } else {
	 *        // not loading, not going to load UNLESS the source is reloaded
	 *        // (it may still make sense to listen to the events)
	 *     }
	 *
	 * @protected
	 * @param source {Image|Canvas} the source object of the texture.</haxe_doc>
		</loadSource>
		<updateSourceImage public="1" set="method">
			<f a="newSrc">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Changes the source image of the texture.
	 * The original source must be an Image element.
	 *
	 * @param newSrc {String} the path of the image</haxe_doc>
		</updateSourceImage>
		<new public="1" set="method">
			<f a="source:?scaleMode:?resolution">
				<c path="js.html.ImageElement"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* A texture stores the information that represents an image. All textures have a base texture.
	 *
	 * @class
	 * @memberof PIXI
	 * @param source {Image|Canvas} the source object of the texture.
	 * @param [scaleMode=scaleModes.DEFAULT] {number} See {@link SCALE_MODES} for possible values
	 * @param resolution {number} the resolution of the texture for devices with different pixel ratios</haxe_doc>
			<overloads>
				<new public="1" set="method">
					<f a="source:?scaleMode:?resolution">
						<d/>
						<x path="Int"/>
						<x path="Float"/>
						<x path="Void"/>
					</f>
					<haxe_doc>* A texture stores the information that represents an image. All textures have a base texture.
	 *
	 * @class
	 * @memberof PIXI
	 * @param source {Image|Canvas} the source object of the texture.
	 * @param [scaleMode=scaleModes.DEFAULT] {number} See {@link SCALE_MODES} for possible values
	 * @param resolution {number} the resolution of the texture for devices with different pixel ratios</haxe_doc>
				</new>
				<new public="1" set="method">
					<f a="source:?scaleMode:?resolution">
						<c path="js.html.CanvasElement"/>
						<x path="Int"/>
						<x path="Float"/>
						<x path="Void"/>
					</f>
					<haxe_doc>* A texture stores the information that represents an image. All textures have a base texture.
	 *
	 * @class
	 * @memberof PIXI
	 * @param source {Image|Canvas} the source object of the texture.
	 * @param [scaleMode=scaleModes.DEFAULT] {number} See {@link SCALE_MODES} for possible values
	 * @param resolution {number} the resolution of the texture for devices with different pixel ratios</haxe_doc>
				</new>
			</overloads>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":native"><e>"PIXI.BaseTexture"</e></m>
		</meta>
	</class>
	<class path="pixi.core.textures.Texture" params="" file="C:\HaxeToolkit\haxe\lib\pixijs/3,0,25/pixi/core/textures/Texture.hx" extern="1">
		<extends path="pixi.interaction.EventEmitter"/>
		<fromImage public="1" set="method" static="1">
			<f a="imageId:?crossorigin:?scaleMode">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Int"/>
				<c path="pixi.core.textures.Texture"/>
			</f>
			<haxe_doc>* Helper function that creates a Texture object from the given image url.
	 * If the image is not in the texture cache it will be  created and loaded.
	 *
	 * @static
	 * @param imageUrl {String} The image url of the texture
	 * @param crossorigin {Bool} Whether requests should be treated as crossorigin
	 * @param scaleMode {Int} See {{#crossLink "PIXI/scaleModes:property"}}scaleModes{{/crossLink}} for possible values
	 * @return Texture</haxe_doc>
		</fromImage>
		<fromFrame public="1" set="method" static="1">
			<f a="frameId">
				<c path="String"/>
				<c path="pixi.core.textures.Texture"/>
			</f>
			<haxe_doc>* Helper function that creates a sprite that will contain a texture from the TextureCache based on the frameId
	 * The frame ids are created when a Texture packer file has been loaded
	 *
	 * @static
	 * @param frameId {String} The frame Id of the texture in the cache
	 * @return {Texture} The newly created texture</haxe_doc>
		</fromFrame>
		<fromCanvas public="1" set="method" static="1">
			<f a="canvas:?scaleMode">
				<d/>
				<x path="Int"/>
				<c path="pixi.core.textures.Texture"/>
			</f>
			<haxe_doc>* Helper function that creates a new Texture based on the given canvas element.
	 *
	 * @static
	 * @param canvas {Canvas} The canvas element source of the texture
	 * @param scaleMode {Int} See {{#crossLink "PIXI/scaleModes:property"}}scaleModes{{/crossLink}} for possible values
	 * @return {Texture}</haxe_doc>
		</fromCanvas>
		<fromVideo public="1" set="method" static="1">
			<f a="video:?scaleMode">
				<c path="js.html.VideoElement"/>
				<x path="Int"/>
				<c path="pixi.core.textures.Texture"/>
			</f>
			<haxe_doc>* Helper function that creates a new Texture based on the given video element.
	 *
	 * @static
	 * @param video {VideoElement}
	 * @param scaleMode {Int} See {{#crossLink "PIXI/scaleModes:property"}}scaleModes{{/crossLink}} for possible values
	 * @return {Texture} A Texture</haxe_doc>
		</fromVideo>
		<fromVideoUrl public="1" set="method" static="1">
			<f a="videoUrl:?scaleMode">
				<c path="String"/>
				<x path="Int"/>
				<c path="pixi.core.textures.Texture"/>
			</f>
			<haxe_doc>* Helper function that creates a new Texture based on the video url.
	 *
	 * @static
	 * @param videoUrl {String}
	 * @param scaleMode {Int} See {{#crossLink "PIXI/scaleModes:property"}}scaleModes{{/crossLink}} for possible values
	 * @return {Texture} A Texture</haxe_doc>
		</fromVideoUrl>
		<addTextureToCache public="1" set="method" static="1">
			<f a="texture:id">
				<c path="pixi.core.textures.Texture"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Adds a texture to the global utils.TextureCache. This cache is shared across the whole PIXI object.
	 *
	 * @static
	 * @param texture {Texture} The Texture to add to the cache.
	 * @param id {String} The id that the texture will be stored against.</haxe_doc>
		</addTextureToCache>
		<removeTextureFromCache public="1" set="method" static="1">
			<f a="id">
				<c path="String"/>
				<c path="pixi.core.textures.Texture"/>
			</f>
			<haxe_doc>* Remove a texture from the global utils.TextureCache.
	 *
	 * @static
	 * @param id {String} The id of the texture to be removed
	 * @return {Texture} The texture that was removed</haxe_doc>
		</removeTextureFromCache>
		<noFrame public="1">
			<x path="Bool"/>
			<haxe_doc>* Does this Texture have any frame data assigned to it?
	 *
	 * @member {Bool}</haxe_doc>
		</noFrame>
		<baseTexture public="1">
			<c path="pixi.core.textures.BaseTexture"/>
			<haxe_doc>* The base texture that this texture uses.
	 *
	 * @member {BaseTexture}</haxe_doc>
		</baseTexture>
		<trim public="1">
			<c path="pixi.core.math.shapes.Rectangle"/>
			<haxe_doc>* The texture trim data.
	 *
	 * @member {Rectangle}</haxe_doc>
		</trim>
		<valid public="1">
			<x path="Bool"/>
			<haxe_doc>* This will let the renderer know if the texture is valid. If it's not then it cannot be rendered.
	 *
	 * @member {Bool}</haxe_doc>
		</valid>
		<requiresUpdate public="1">
			<x path="Bool"/>
			<haxe_doc>* This will let a renderer know that a texture has been updated (used mainly for webGL uv updates)
	 *
	 * @member {Bool}</haxe_doc>
		</requiresUpdate>
		<width public="1">
			<x path="Float"/>
			<haxe_doc>* The width of the Texture in pixels.
	 *
	 * @member {Float}</haxe_doc>
		</width>
		<height public="1">
			<x path="Float"/>
			<haxe_doc>* The height of the Texture in pixels.
	 *
	 * @member {Float}</haxe_doc>
		</height>
		<crop public="1">
			<c path="pixi.core.math.shapes.Rectangle"/>
			<haxe_doc>* This is the area of the BaseTexture image to actually copy to the Canvas / WebGL when rendering,
	 * irrespective of the actual frame size or placement (which can be influenced by trimmed texture atlases)
	 *
	 * @member {Rectangle}</haxe_doc>
		</crop>
		<spritePivot public="1">
			<c path="pixi.core.math.Point"/>
			<haxe_doc>* The pivot point to used for a sprite this texture belongs to.
	 *
	 * @member {Point}</haxe_doc>
		</spritePivot>
		<rotation public="1">
			<x path="Float"/>
			<haxe_doc>* The rotation value of the texture, copied to a sprite when assigned to it.
	 *
	 * @member {Float}</haxe_doc>
		</rotation>
		<frame public="1">
			<c path="pixi.core.math.shapes.Rectangle"/>
			<haxe_doc>* The frame specifies the region of the base texture that this texture uses
	 *
	 * @member {Rectangle}</haxe_doc>
		</frame>
		<destroy public="1" set="method">
			<f a="?destroyBase">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Destroys this texture
	 *
	 * @param destroyBase {Bool} Whether to destroy the base texture as well</haxe_doc>
		</destroy>
		<update public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Updates this texture on the gpu.
	 *</haxe_doc>
		</update>
		<new public="1" set="method">
			<f a="baseTexture:?frame:?crop:?trim:?rotate">
				<c path="pixi.core.textures.BaseTexture"/>
				<c path="pixi.core.math.shapes.Rectangle"/>
				<c path="pixi.core.math.shapes.Rectangle"/>
				<c path="pixi.core.math.shapes.Rectangle"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* A texture stores the information that represents an image or part of an image. It cannot be added
	 * to the display list directly. Instead use it as the texture for a Sprite. If no frame is provided then the whole image is used.
	 *
	 * You can directly create a texture from an image and then reuse it multiple times like this :
	 *
	 * ```js
	 * 	var texture = PIXI.Texture.fromImage('assets/image.png');
	 * 	var sprite1 = new PIXI.Sprite(texture);
	 * 	var sprite2 = new PIXI.Sprite(texture);
	 * ```
	 *
	 * @class
	 * @mixes eventTarget
	 * @memberof PIXI
	 * @param baseTexture {BaseTexture} The base texture source to create the texture from
	 * @param [frame] {Rectangle} The rectangle frame of the texture to show
	 * @param [crop] {Rectangle} The area of original texture
	 * @param [trim] {Rectangle} Trimmed texture rectangle
	 * @param [rotate] {boolean} indicates whether the texture should be rotated by 90 degrees ( used by texture packer )</haxe_doc>
			<overloads><new public="1" set="method">
	<f a="baseTexture:?frame:?crop:?trim:?rotate">
		<c path="pixi.core.textures.VideoBaseTexture"/>
		<c path="pixi.core.math.shapes.Rectangle"/>
		<c path="pixi.core.math.shapes.Rectangle"/>
		<c path="pixi.core.math.shapes.Rectangle"/>
		<x path="Bool"/>
		<x path="Void"/>
	</f>
	<haxe_doc>* A texture stores the information that represents an image or part of an image. It cannot be added
	 * to the display list directly. Instead use it as the texture for a Sprite. If no frame is provided then the whole image is used.
	 *
	 * You can directly create a texture from an image and then reuse it multiple times like this :
	 *
	 * ```js
	 * 	var texture = PIXI.Texture.fromImage('assets/image.png');
	 * 	var sprite1 = new PIXI.Sprite(texture);
	 * 	var sprite2 = new PIXI.Sprite(texture);
	 * ```
	 *
	 * @class
	 * @mixes eventTarget
	 * @memberof PIXI
	 * @param baseTexture {BaseTexture} The base texture source to create the texture from
	 * @param [frame] {Rectangle} The rectangle frame of the texture to show
	 * @param [crop] {Rectangle} The area of original texture
	 * @param [trim] {Rectangle} Trimmed texture rectangle
	 * @param [rotate] {boolean} indicates whether the texture should be rotated by 90 degrees ( used by texture packer )</haxe_doc>
</new></overloads>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":native"><e>"PIXI.Texture"</e></m>
		</meta>
	</class>
	<class path="pixi.core.textures.VideoBaseTexture" params="" file="C:\HaxeToolkit\haxe\lib\pixijs/3,0,25/pixi/core/textures/VideoBaseTexture.hx" extern="1">
		<extends path="pixi.core.textures.BaseTexture"/>
		<fromVideo public="1" set="method" static="1">
			<f a="video:?scaleMode">
				<c path="js.html.VideoElement"/>
				<x path="Int"/>
				<c path="pixi.core.textures.VideoBaseTexture"/>
			</f>
			<haxe_doc>* Mimic Pixi BaseTexture.from.... method.
	 *
	 * @static
	 * @param video {HTMLVideoElement}
	 * @param scaleMode {number} See {@link SCALE_MODES} for possible values
	 * @return {VideoBaseTexture}</haxe_doc>
		</fromVideo>
		<fromUrl public="1" set="method" static="1">
			<f a="videoSrc:?scaleMode">
				<c path="String"/>
				<x path="Int"/>
				<c path="pixi.core.textures.VideoBaseTexture"/>
			</f>
			<haxe_doc>* Mimic Pixi BaseTexture.from.... method.
	 *
	 * This can be used in a couple ways, such as:
	 *
	 * ```js
	 * 	var texture = PIXI.VideoBaseTexture.fromUrl('http://mydomain.com/video.mp4');
	 *
	 * 	var texture = PIXI.VideoBaseTexture.fromUrl({ src: 'http://mydomain.com/video.mp4', mime: 'video/mp4' });
	 *
	 * 	var texture = PIXI.VideoBaseTexture.fromUrls(['/video.webm', '/video.mp4']);
	 *
	 * 	var texture = PIXI.VideoBaseTexture.fromUrls([
	 *     { src: '/video.webm', mime: 'video/webm' },
	 *     { src: '/video.mp4', mime: 'video/mp4' }
	 * ]);
	 * ```
	 *
	 * @alias fromUrls
	 * @static
	 * @param videoSrc {string|object|string[]|object[]} The URL(s) for the video.
	 * @param [videoSrc.src] {string} One of the source urls for the video
	 * @param [videoSrc.mime] {string} The mimetype of the video (e.g. 'video/mp4'). If not specified
	 *  the url's extension will be used as the second part of the mime type.
	 * @param scaleMode {number} See {@link SCALE_MODES} for possible values
	 * @return {VideoBaseTexture}</haxe_doc>
		</fromUrl>
		<fromUrls public="1" set="method" static="1"><f a="videoSrc:?scaleMode">
	<c path="Array"><c path="String"/></c>
	<x path="Int"/>
	<c path="pixi.core.textures.VideoBaseTexture"/>
</f></fromUrls>
		<new public="1" set="method">
			<f a="source:?scaleMode">
				<c path="js.html.VideoElement"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* A texture of a [playing] Video.
	 *
	 * Video base textures mimic Pixi BaseTexture.from.... method in their creation process.
	 *
	 * This can be used in several ways, such as:
	 *
	 * ```js
	 * var texture = PIXI.VideoBaseTexture.fromUrl('http://mydomain.com/video.mp4');
	 *
	 * var texture = PIXI.VideoBaseTexture.fromUrl({ src: 'http://mydomain.com/video.mp4', mime: 'video/mp4' });
	 *
	 * var texture = PIXI.VideoBaseTexture.fromUrls(['/video.webm', '/video.mp4']);
	 *
	 * var texture = PIXI.VideoBaseTexture.fromUrls([
	 *     { src: '/video.webm', mime: 'video/webm' },
	 *     { src: '/video.mp4', mime: 'video/mp4' }
	 * ]);
	 * ```
	 *
	 * See the ["deus" demo](http://www.goodboydigital.com/pixijs/examples/deus/).
	 *
	 * @class
	 * @extends BaseTexture
	 * @memberof PIXI
	 * @param source {HTMLVideoElement}
	 * @param [scaleMode] {number} See {@link SCALE_MODES} for possible values</haxe_doc>
		</new>
		<meta><m n=":native"><e>"PIXI.VideoBaseTexture"</e></m></meta>
	</class>
	<class path="pixi.core.ticker.Ticker" params="" file="C:\HaxeToolkit\haxe\lib\pixijs/3,0,25/pixi/core/ticker/Ticker.hx" extern="1">
		<extends path="pixi.interaction.EventEmitter"/>
		<autoStart public="1">
			<x path="Bool"/>
			<haxe_doc>* Whether or not this ticker should invoke the method
     * {@link PIXI.ticker.Ticker#start} automatically
     * when a listener is added.
     *
     * @member {Bool}
     * @default false</haxe_doc>
		</autoStart>
		<deltaTime public="1">
			<x path="Float"/>
			<haxe_doc>* Scalar time value from last frame to this frame.
     * This value is capped by setting {@link PIXI.ticker.Ticker#minFPS}
     * and is scaled with {@link PIXI.ticker.Ticker#speed}.
     * **Note:** The cap may be exceeded by scaling.
     *
     * @member {Float}
     * @default 1</haxe_doc>
		</deltaTime>
		<elapsedMS public="1">
			<x path="Float"/>
			<haxe_doc>* Time elapsed in milliseconds from last frame to this frame.
     * Opposed to what the scalar {@link PIXI.ticker.Ticker#deltaTime}
     * is based, this value is neither capped nor scaled.
     * If the platform supports DOMHighResTimeStamp,
     * this value will have a precision of 1 µs.
     *
     * @member {Float}
     * @default 1 / TARGET_FPMS</haxe_doc>
		</elapsedMS>
		<lastTime public="1">
			<x path="Float"/>
			<haxe_doc>* The last time {@link PIXI.ticker.Ticker#update} was invoked.
     * This value is also reset internally outside of invoking
     * update, but only when a new animation frame is requested.
     * If the platform supports DOMHighResTimeStamp,
     * this value will have a precision of 1 µs.
     *
     * @member {Float}
     * @default 0</haxe_doc>
		</lastTime>
		<speed public="1">
			<x path="Float"/>
			<haxe_doc>* Factor of current {@link PIXI.ticker.Ticker#deltaTime}.
     * @example
     *     // Scales ticker.deltaTime to what would be
     *     // the equivalent of approximately 120 FPS
     *     ticker.speed = 2;
     *
     * @member {Float}
     * @default 1</haxe_doc>
		</speed>
		<started public="1">
			<x path="Bool"/>
			<haxe_doc>* Whether or not this ticker has been started.
     * `true` if {@link PIXI.ticker.Ticker#start} has been called.
     * `false` if {@link PIXI.ticker.Ticker#stop} has been called.
     * While `false`, this value may change to `true` in the
     * event of {@link PIXI.ticker.Ticker#autoStart} being `true`
     * and a listener is added.
     *
     * @member {Bool}
     * @default false</haxe_doc>
		</started>
		<FPS public="1">
			<x path="Int"/>
			<haxe_doc>* The frames per second at which this ticker is running.
     * The default is approximately 60 in most modern browsers.
     * **Note:** This does not factor in the value of
     * {@link PIXI.ticker.Ticker#speed}, which is specific
     * to scaling {@link PIXI.ticker.Ticker#deltaTime}.
     *
     * @member
     * @memberof PIXI.ticker.Ticker#
     * @readonly</haxe_doc>
		</FPS>
		<minFPS public="1">
			<x path="Int"/>
			<haxe_doc>* Manages the maximum amount of milliseconds allowed to
     * elapse between invoking {@link PIXI.ticker.Ticker#update}.
     * This value is used to cap {@link PIXI.ticker.Ticker#deltaTime},
     * but does not effect the measured value of {@link PIXI.ticker.Ticker#FPS}.
     * When setting this property it is clamped to a value between
     * `0` and `PIXI.TARGET_FPMS * 1000`.
     *
     * @member
     * @memberof PIXI.ticker.Ticker#
     * @default 10</haxe_doc>
		</minFPS>
		<add public="1" set="method">
			<f a="fn:?context">
				<f a=""><x path="Void"/></f>
				<f a=""><x path="Void"/></f>
				<c path="pixi.core.ticker.Ticker"/>
			</f>
			<haxe_doc>* Calls EventEmitter.on internally for the
	 * internal 'tick' event. It checks if the emitter has listeners,
	 * and if so it requests a new animation frame at this point.
	 *
	 * @param fn {Function} The listener function to be added for updates
	 * @param [context] {Function} The listener context
	 * @returns {Ticker} this</haxe_doc>
		</add>
		<addOnce public="1" set="method">
			<f a="fn:?context">
				<f a=""><x path="Void"/></f>
				<f a=""><x path="Void"/></f>
				<c path="pixi.core.ticker.Ticker"/>
			</f>
			<haxe_doc>* Calls EventEmitter.once internally for the
	 * internal 'tick' event. It checks if the emitter has listeners,
	 * and if so it requests a new animation frame at this point.
	 *
	 * @param fn {Function} The listener function to be added for one update
	 * @param [context] {Function} The listener context
	 * @returns {Ticker} this</haxe_doc>
		</addOnce>
		<remove public="1" set="method">
			<f a="fn:?context">
				<f a=""><x path="Void"/></f>
				<f a=""><x path="Void"/></f>
				<c path="pixi.core.ticker.Ticker"/>
			</f>
			<haxe_doc>* Calls EventEmitter.off internally for 'tick' event.
	 * It checks if the emitter has listeners for 'tick' event.
	 * If it does, then it cancels the animation frame.
	 *
	 * @param [fn] {Function} The listener function to be removed
	 * @param [context] {Function} The listener context to be removed
	 * @returns {Ticker} this</haxe_doc>
		</remove>
		<start public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Starts the ticker. If the ticker has listeners
	 * a new animation frame is requested at this point.</haxe_doc>
		</start>
		<stop public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Stops the ticker. If the ticker has requested
	 * an animation frame it is canceled at this point.</haxe_doc>
		</stop>
		<update public="1" set="method">
			<f a="?currentTime">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Triggers an update. An update entails setting the
	 * current elapsedMS,
	 * the current deltaTime,
	 * invoking all listeners with current deltaTime,
	 * and then finally setting lastTime
	 * with the value of currentTime that was provided.
	 * This method will be called automatically by animation
	 * frame callbacks if the ticker instance has been started
	 * and listeners are added.
	 *
	 * @param [currentTime=performance.now()] {DOMHighResTimeStamp|number} the current time of execution</haxe_doc>
		</update>
		<new public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* A Ticker class that runs an update loop that other objects listen to.
	 * This class is composed around an EventEmitter object to add listeners
	 * meant for execution on the next requested animation frame.
	 * Animation frames are requested only when necessary,
	 * e.g. When the ticker is started and the emitter has listeners.
	 *
	 * @class
	 * @memberof PIXI.ticker</haxe_doc>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":native"><e>"PIXI.ticker.Ticker"</e></m>
		</meta>
	</class>
	<class path="pixi.display.FlumpMovie" params="" file="C:\HaxeToolkit\haxe\lib\pixi-flump-runtime/0,1,1/src/pixi/display/FlumpMovie.hx">
		<extends path="pixi.core.display.Container"/>
		<implements path="flump.IFlumpMovie"/>
		<player public="1"><c path="flump.MoviePlayer"/></player>
		<symbol><c path="flump.library.MovieSymbol"/></symbol>
		<layers><x path="Map">
	<c path="flump.library.Layer"/>
	<c path="pixi.display.PixiLayer"/>
</x></layers>
		<layerLookup><x path="Map">
	<c path="String"/>
	<c path="pixi.core.display.Container"/>
</x></layerLookup>
		<movieChildren><x path="Map">
	<c path="flump.DisplayObjectKey"/>
	<c path="pixi.core.display.DisplayObject"/>
</x></movieChildren>
		<displaying><x path="Map">
	<c path="flump.library.Layer"/>
	<c path="flump.DisplayObjectKey"/>
</x></displaying>
		<ticker>
			<c path="pixi.core.ticker.Ticker"/>
			<meta><m n=":has_untyped"/></meta>
		</ticker>
		<master><x path="Bool"/></master>
		<resource><c path="pixi.display.FlumpResource"/></resource>
		<resourceId><c path="String"/></resourceId>
		<disableAsMaster set="method" line="53"><f a=""><x path="Void"/></f></disableAsMaster>
		<animationSpeed public="1"><x path="Float"/></animationSpeed>
		<getLayer public="1" set="method" line="67"><f a="layerId">
	<c path="String"/>
	<c path="pixi.core.display.Container"/>
</f></getLayer>
		<getChildDisplayObject public="1" set="method" line="73"><f a="layerId:?keyframeIndex">
	<c path="String"/>
	<x path="UInt"/>
	<c path="pixi.core.display.DisplayObject"/>
</f></getChildDisplayObject>
		<getChildMovie public="1" set="method" line="79"><f a="layerId:?keyframeIndex">
	<c path="String"/>
	<x path="UInt"/>
	<c path="pixi.display.FlumpMovie"/>
</f></getChildMovie>
		<symbolId public="1" get="accessor" set="null"><c path="String"/></symbolId>
		<get_symbolId set="method" line="87"><f a=""><c path="String"/></f></get_symbolId>
		<loop public="1" set="accessor"><x path="Bool"/></loop>
		<set_loop set="method" line="92"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_loop>
		<onComplete public="1" set="accessor"><f a=""><x path="Void"/></f></onComplete>
		<set_onComplete set="method" line="100"><f a="value">
	<f a=""><x path="Void"/></f>
	<f a=""><x path="Void"/></f>
</f></set_onComplete>
		<currentFrame public="1" get="accessor" set="accessor"><x path="Int"/></currentFrame>
		<set_currentFrame set="method" line="105"><f a="value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_currentFrame>
		<get_currentFrame set="method" line="109"><f a=""><x path="Int"/></f></get_currentFrame>
		<playing public="1" get="accessor" set="null"><x path="Bool"/></playing>
		<get_playing set="method" line="114"><f a=""><x path="Bool"/></f></get_playing>
		<independantTimeline public="1" get="accessor" set="accessor"><x path="Bool"/></independantTimeline>
		<get_independantTimeline set="method" line="120"><f a=""><x path="Bool"/></f></get_independantTimeline>
		<set_independantTimeline set="method" line="123"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_independantTimeline>
		<independantControl public="1" get="accessor" set="accessor"><x path="Bool"/></independantControl>
		<get_independantControl set="method" line="130"><f a=""><x path="Bool"/></f></get_independantControl>
		<set_independantControl set="method" line="133"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_independantControl>
		<totalFrames public="1" get="accessor" set="null"><x path="Int"/></totalFrames>
		<get_totalFrames set="method" line="140"><f a=""><x path="UInt"/></f></get_totalFrames>
		<stop public="1" set="method" line="145"><f a=""><x path="Void"/></f></stop>
		<play public="1" set="method" line="150"><f a=""><x path="Void"/></f></play>
		<gotoAndStop public="1" set="method" line="156"><f a="frameNumber">
	<x path="Int"/>
	<x path="Void"/>
</f></gotoAndStop>
		<gotoAndPlay public="1" set="method" line="165"><f a="frameNumber">
	<x path="Int"/>
	<x path="Void"/>
</f></gotoAndPlay>
		<getLabelFrame public="1" set="method" line="175"><f a="label">
	<c path="String"/>
	<x path="UInt"/>
</f></getLabelFrame>
		<tick set="method" line="186"><f a=""><x path="Void"/></f></tick>
		<onAdded set="method" line="191"><f a="to">
	<t path="pixi.interaction.EventTarget"/>
	<x path="Void"/>
</f></onAdded>
		<onRemoved set="method" line="197"><f a="from">
	<t path="pixi.interaction.EventTarget"/>
	<x path="Void"/>
</f></onRemoved>
		<createLayer set="method" line="212"><f a="layer">
	<c path="flump.library.Layer"/>
	<x path="Void"/>
</f></createLayer>
		<getChildPlayer set="method" line="219"><f a="keyframe">
	<c path="flump.library.Keyframe"/>
	<c path="flump.MoviePlayer"/>
</f></getChildPlayer>
		<createFlumpChild set="method" line="225"><f a="displayKey">
	<c path="flump.DisplayObjectKey"/>
	<x path="Void"/>
</f></createFlumpChild>
		<removeFlumpChild set="method" line="230"><f a="layer:displayKey">
	<c path="flump.library.Layer"/>
	<c path="flump.DisplayObjectKey"/>
	<x path="Void"/>
</f></removeFlumpChild>
		<addFlumpChild set="method" line="236"><f a="layer:displayKey">
	<c path="flump.library.Layer"/>
	<c path="flump.DisplayObjectKey"/>
	<x path="Void"/>
</f></addFlumpChild>
		<onAnimationComplete set="method" line="242"><f a=""><x path="Void"/></f></onAnimationComplete>
		<renderFrame set="method" line="247"><f a="keyframe:x:y:scaleX:scaleY:skewX:skewY">
	<c path="flump.library.Keyframe"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></renderFrame>
		<labelPassed set="method" line="260"><f a="label">
	<c path="flump.library.Label"/>
	<x path="Void"/>
</f></labelPassed>
		<destroy public="1" set="method" line="264" override="1"><f a=""><x path="Void"/></f></destroy>
		<new public="1" set="method" line="31"><f a="symbolId:?resourceId">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":access"><e>pixi.display.FlumpResource</e></m>
		</meta>
	</class>
	<class path="pixi.display.FlumpResource" params="" file="C:\HaxeToolkit\haxe\lib\pixi-flump-runtime/0,1,1/src/pixi/display/FlumpResource.hx">
		<resources line="26" static="1"><x path="Map">
	<c path="String"/>
	<c path="pixi.display.FlumpResource"/>
</x></resources>
		<exists public="1" set="method" line="29" static="1"><f a="resourceName">
	<c path="String"/>
	<x path="Bool"/>
</f></exists>
		<destroy public="1" set="method" line="34" static="1"><f a="resourceName">
	<c path="String"/>
	<x path="Void"/>
</f></destroy>
		<flumpParser public="1" set="method" line="44" static="1"><f a="resource:next">
	<c path="pixi.loaders.Resource"/>
	<f a=""><x path="Void"/></f>
	<x path="Void"/>
</f></flumpParser>
		<get set="method" line="78" static="1"><f a="resourceName">
	<c path="String"/>
	<t path="Null"><c path="pixi.display.FlumpResource"/></t>
</f></get>
		<getResourceForMovie set="method" line="84" static="1"><f a="symbolId">
	<c path="String"/>
	<c path="pixi.display.FlumpResource"/>
</f></getResourceForMovie>
		<getResourceForSprite set="method" line="94" static="1"><f a="symbolId">
	<c path="String"/>
	<c path="pixi.display.FlumpResource"/>
</f></getResourceForSprite>
		<library><c path="flump.library.FlumpLibrary"/></library>
		<textures><x path="Map">
	<c path="String"/>
	<c path="pixi.core.textures.Texture"/>
</x></textures>
		<resourceId><c path="String"/></resourceId>
		<createMovie set="method" line="112"><f a="id">
	<c path="String"/>
	<c path="pixi.display.FlumpMovie"/>
</f></createMovie>
		<createSprite set="method" line="119"><f a="id">
	<c path="String"/>
	<c path="pixi.core.sprites.Sprite"/>
</f></createSprite>
		<createDisplayObject set="method" line="124"><f a="id">
	<c path="String"/>
	<c path="pixi.core.display.DisplayObject"/>
</f></createDisplayObject>
		<new set="method" line="105"><f a="library:textures:resourceId">
	<c path="flump.library.FlumpLibrary"/>
	<x path="Map">
		<c path="String"/>
		<c path="pixi.core.textures.Texture"/>
	</x>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":access"><e>pixi.display.FlumpMovie</e></m>
		</meta>
	</class>
	<class path="pixi.display.FlumpSprite" params="" file="C:\HaxeToolkit\haxe\lib\pixi-flump-runtime/0,1,1/src/pixi/display/FlumpSprite.hx">
		<extends path="pixi.core.sprites.Sprite"/>
		<symbolId public="1"><c path="String"/></symbolId>
		<resourceId public="1"><c path="String"/></resourceId>
		<new public="1" set="method" line="14"><f a="symbolId:?resourceId">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":access"><e>pixi.display.FlumpResource</e></m>
		</meta>
	</class>
	<class path="pixi.display.PixiLayer" params="" file="C:\HaxeToolkit\haxe\lib\pixi-flump-runtime/0,1,1/src/pixi/display/PixiLayer.hx">
		<extends path="pixi.core.display.Container"/>
		<skew public="1"><c path="pixi.core.math.Point"/></skew>
		<updateTransform public="1" set="method" line="11" override="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":has_untyped"/></meta>
		</updateTransform>
		<new public="1" set="method" line="7"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="pixi.extras.MovieClip" params="" file="C:\HaxeToolkit\haxe\lib\pixijs/3,0,25/pixi/extras/MovieClip.hx" extern="1">
		<extends path="pixi.core.sprites.Sprite"/>
		<fromFrames public="1" set="method" static="1">
			<f a="frames">
				<c path="Array"><c path="String"/></c>
				<c path="pixi.extras.MovieClip"/>
			</f>
			<haxe_doc><![CDATA[* A short hand way of creating a movieclip from an array of frame ids
	 *
	 * @static
	 * @param frames {Array<String>} the array of frames ids the movieclip will use as its texture frames]]></haxe_doc>
		</fromFrames>
		<fromImages public="1" set="method" static="1">
			<f a="images">
				<c path="Array"><c path="String"/></c>
				<c path="pixi.extras.MovieClip"/>
			</f>
			<haxe_doc><![CDATA[* A short hand way of creating a movieclip from an array of image ids
	 *
	 * @static
	 * @param images {Array<String>} the array of image urls the movieclip will use as its texture frames]]></haxe_doc>
		</fromImages>
		<animationSpeed public="1">
			<x path="Float"/>
			<haxe_doc>* The speed that the MovieClip will play at. Higher is faster, lower is slower
	 *
	 * @member {Float}
	 * @default 1</haxe_doc>
		</animationSpeed>
		<loop public="1">
			<x path="Bool"/>
			<haxe_doc>* Whether or not the movie clip repeats after playing.
	 *
	 * @member {Bool}
	 * @default true</haxe_doc>
		</loop>
		<onComplete public="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* 	function to call when a MovieClip finishes playing
	 *
	 * @method
	 * @memberof MovieClip#</haxe_doc>
		</onComplete>
		<currentFrame public="1">
			<x path="Int"/>
			<haxe_doc>* The MovieClips current frame index (this may not have to be a whole number)
	 *
	 * @member {Int}
	 * @default 0
	 * @readonly</haxe_doc>
		</currentFrame>
		<playing public="1">
			<x path="Bool"/>
			<haxe_doc>* Indicates if the MovieClip is currently playing
	 *
	 * @member {Bool}
	 * @readonly</haxe_doc>
		</playing>
		<totalFrames public="1">
			<x path="Int"/>
			<haxe_doc>* totalFrames is the total number of frames in the MovieClip. This is the same as number of textures
	 * assigned to the MovieClip.
	 *
	 * @member
	 * @memberof MovieClip#
	 * @default 0
	 * @readonly</haxe_doc>
		</totalFrames>
		<textures public="1">
			<c path="Array"><c path="pixi.core.textures.Texture"/></c>
			<haxe_doc>* The array of textures used for this MovieClip
	 *
	 * @member
	 * @memberof MovieClip#
	 *</haxe_doc>
		</textures>
		<stop public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Stops the MovieClip
	 *</haxe_doc>
		</stop>
		<play public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Plays the MovieClip
	 *</haxe_doc>
		</play>
		<gotoAndStop public="1" set="method">
			<f a="frameNumber">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Stops the MovieClip and goes to a specific frame
	 *
	 * @param frameNumber {Int} frame index to stop at</haxe_doc>
		</gotoAndStop>
		<gotoAndPlay public="1" set="method">
			<f a="frameNumber">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Goes to a specific frame and begins playing the MovieClip
	 *
	 * @param frameNumber {Int} frame index to start at</haxe_doc>
		</gotoAndPlay>
		<new public="1" set="method">
			<f a="textures">
				<c path="Array"><c path="pixi.core.textures.Texture"/></c>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* A MovieClip is a simple way to display an animation depicted by a list of textures.
	 *
	 * ```js
	 * 	var alienImages = ["image_sequence_01.png","image_sequence_02.png","image_sequence_03.png","image_sequence_04.png"];
	 * 	var textureArray = [];
	 *
	 * for (	var i=0; i < 4; i++)
	 * {
	 *      	var texture = PIXI.Texture.fromImage(alienImages[i]);
	 *      textureArray.push(texture);
	 * };
	 *
	 * 	var mc = new PIXI.MovieClip(textureArray);
	 * ```
	 *
	 * @class
	 * @extends Sprite
	 * @memberof PIXI.extras
	 * @param textures {Texture[]} an array of {Texture} objects that make up the animation]]></haxe_doc>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":native"><e>"PIXI.extras.MovieClip"</e></m>
		</meta>
	</class>
	<typedef path="pixi.interaction.EventTarget" params="" file="C:\HaxeToolkit\haxe\lib\pixijs/3,0,25/pixi/interaction/EventTarget.hx"><a>
	<type><c path="String"/></type>
	<target><d/></target>
	<stopped><x path="Bool"/></stopped>
	<stopPropagation set="method"><f a=""><x path="Void"/></f></stopPropagation>
	<data><c path="pixi.interaction.InteractionData"/></data>
</a></typedef>
	<class path="pixi.interaction.InteractionData" params="" file="C:\HaxeToolkit\haxe\lib\pixijs/3,0,25/pixi/interaction/InteractionData.hx" extern="1">
		<global public="1">
			<c path="pixi.core.math.Point"/>
			<haxe_doc>* This point stores the global coords of where the touch/mouse event happened
     *
     * @member {Point}</haxe_doc>
		</global>
		<target public="1">
			<c path="pixi.core.sprites.Sprite"/>
			<haxe_doc>* The target Sprite that was interacted with
     *
     * @member {Sprite}</haxe_doc>
		</target>
		<originalEvent public="1">
			<c path="js.html.Event"/>
			<haxe_doc>* When passed to an event handler, this will be the original DOM Event that was captured
     *
     * @member {Event}</haxe_doc>
		</originalEvent>
		<identifier public="1">
			<x path="Int"/>
			<haxe_doc>* Touch identifier
     *
     * @member {Event}</haxe_doc>
		</identifier>
		<getLocalPosition public="1" set="method">
			<f a="displayObject:?point">
				<c path="pixi.core.display.DisplayObject"/>
				<c path="pixi.core.math.Point"/>
				<c path="pixi.core.math.Point"/>
			</f>
			<haxe_doc>* This will return the local coordinates of the specified displayObject for this InteractionData
	 *
	 * @param displayObject {DisplayObject} The DisplayObject that you would like the local coords off
	 * @param [point] {Point} A Point object in which to store the value, optional (otherwise will create a new point)
	 * @return {Point} A point containing the coordinates of the InteractionData position relative to the DisplayObject</haxe_doc>
		</getLocalPosition>
		<new public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Holds all information related to an Interaction event
	 *
	 * @class
	 * @memberof PIXI.interaction</haxe_doc>
		</new>
		<meta><m n=":native"><e>"PIXI.interaction.InteractionData"</e></m></meta>
	</class>
	<typedef path="pixi.interaction.InteractionManagerOptions" params="" file="C:\HaxeToolkit\haxe\lib\pixijs/3,0,25/pixi/interaction/InteractionManager.hx" module="pixi.interaction.InteractionManager"><a>
	<interactionFrequency>
		<t path="Null"><x path="Int"/></t>
		<meta><m n=":optional"/></meta>
	</interactionFrequency>
	<autoPreventDefault>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</autoPreventDefault>
</a></typedef>
	<class path="pixi.loaders.FlumpParser" params="" file="C:\HaxeToolkit\haxe\lib\pixi-flump-runtime/0,1,1/src/pixi/loaders/FlumpParser.hx">
		<flumpParser public="1" set="method" line="22" static="1"><f a="resource:next">
	<c path="pixi.loaders.Resource"/>
	<f a=""><x path="Void"/></f>
	<x path="Void"/>
</f></flumpParser>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":access"><e>pixi.display.FlumpResource</e></m>
		</meta>
	</class>
	<typedef path="pixi.loaders.LoaderOptions" params="" file="C:\HaxeToolkit\haxe\lib\pixijs/3,0,25/pixi/loaders/LoaderOptions.hx"><a>
	<xhrType>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</xhrType>
	<loadType>
		<t path="Null"><x path="Int"/></t>
		<meta><m n=":optional"/></meta>
	</loadType>
	<crossOrigin>
		<t path="Null"><d/></t>
		<meta><m n=":optional"/></meta>
	</crossOrigin>
</a></typedef>
	<class path="pixi.loaders.Resource" params="" file="C:\HaxeToolkit\haxe\lib\pixijs/3,0,25/pixi/loaders/Resource.hx" extern="1">
		<texture public="1"><c path="pixi.core.textures.Texture"/></texture>
		<textures public="1"><d/></textures>
		<name public="1">
			<c path="String"/>
			<haxe_doc>* The name of this resource.
     *
     * @member {string}
     * @readonly</haxe_doc>
		</name>
		<url public="1">
			<c path="String"/>
			<haxe_doc>* The url used to load this resource.
     *
     * @member {string}
     * @readonly</haxe_doc>
		</url>
		<data public="1">
			<d/>
			<haxe_doc>* The data that was loaded by the resource.
     *
     * @member {any}</haxe_doc>
		</data>
		<xhr public="1">
			<d/>
			<haxe_doc>* The XHR object that was used to load this resource. This is only set
     * when `loadType` is `Resource.LOAD_TYPE.XHR`.
     *
     * @member {XMLHttpRequest}</haxe_doc>
		</xhr>
		<xhrType public="1">
			<c path="String"/>
			<haxe_doc>* The type used to load the resource via XHR. If unset, determined automatically.
     *
     * @member {String}</haxe_doc>
		</xhrType>
		<crossOrigin public="1">
			<c path="String"/>
			<haxe_doc>* Is this request cross-origin? If unset, determined automatically.
     *
     * @member {string}</haxe_doc>
		</crossOrigin>
		<loadType public="1">
			<x path="Int"/>
			<haxe_doc>* The method of loading to use for this resource.
     *
     * @member {Resource.LOAD_TYPE}</haxe_doc>
		</loadType>
		<error public="1">
			<d/>
			<haxe_doc>* The error that occurred while loading (if any).
     *
     * @member {Error}
     * @readonly</haxe_doc>
		</error>
		<isJson public="1">
			<x path="Bool"/>
			<haxe_doc>* Describes if this resource was loaded as json. Only valid after the resource
     * has completely loaded.
     *
     * @member {Bool}</haxe_doc>
		</isJson>
		<isXml public="1">
			<x path="Bool"/>
			<haxe_doc>* Describes if this resource was loaded as xml. Only valid after the resource
     * has completely loaded.
     *
     * @member {Bool}</haxe_doc>
		</isXml>
		<isImage public="1">
			<x path="Bool"/>
			<haxe_doc>* Describes if this resource was loaded as an image tag. Only valid after the resource
     * has completely loaded.
     *
     * @member {Bool}</haxe_doc>
		</isImage>
		<isAudio public="1">
			<x path="Bool"/>
			<haxe_doc>* Describes if this resource was loaded as an audio tag. Only valid after the resource
     * has completely loaded.
     *
     * @member {Bool}</haxe_doc>
		</isAudio>
		<isVideo public="1">
			<x path="Bool"/>
			<haxe_doc>* Describes if this resource was loaded as a video tag. Only valid after the resource
     * has completely loaded.
     *
     * @member {Bool}</haxe_doc>
		</isVideo>
		<new public="1" set="method">
			<f a="name:url:?options">
				<c path="String"/>
				<c path="String"/>
				<t path="pixi.loaders.LoaderOptions"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Manages the state and loading of a single resource represented by
	 * a single URL.
	 *
	 * @class
	 * @param name {string} The name of the resource to load.
	 * @param url {string|string[]} The url for this resource, for audio/video loads you can pass an array of sources.
	 * @param [options] {object} The options for the load.
	 * @param [options.crossOrigin] {boolean} Is this request cross-origin? Default is to determine automatically.
	 * @param [options.loadType=Resource.LOAD_TYPE.XHR] {Resource.LOAD_TYPE} How should this resource be loaded?
	 * @param [options.xhrType=Resource.XHR_RESPONSE_TYPE.DEFAULT] {Resource.XHR_RESPONSE_TYPE} How should the data being
	 *      loaded be interpreted when using XHR?</haxe_doc>
		</new>
	</class>
	<typedef path="pixi.loaders.LOAD_TYPE" params="" file="C:\HaxeToolkit\haxe\lib\pixijs/3,0,25/pixi/loaders/Resource.hx" module="pixi.loaders.Resource">
		<a>
			<XHR><x path="Int"/></XHR>
			<VIDEO><x path="Int"/></VIDEO>
			<IMAGE><x path="Int"/></IMAGE>
			<AUDIO><x path="Int"/></AUDIO>
		</a>
		<haxe_doc>* The types of loading a resource can use.
 *
 * @static
 * @constant
 * @property {object} LOAD_TYPE
 * @property {number} LOAD_TYPE.XHR - Uses XMLHttpRequest to load the resource.
 * @property {number} LOAD_TYPE.IMAGE - Uses an `Image` object to load the resource.
 * @property {number} LOAD_TYPE.AUDIO - Uses an `Audio` object to load the resource.
 * @property {number} LOAD_TYPE.VIDEO - Uses a `Video` object to load the resource.</haxe_doc>
	</typedef>
	<typedef path="pixi.loaders.XHR_READY_STATE" params="" file="C:\HaxeToolkit\haxe\lib\pixijs/3,0,25/pixi/loaders/Resource.hx" module="pixi.loaders.Resource">
		<a>
			<UNSENT><x path="Int"/></UNSENT>
			<OPENED><x path="Int"/></OPENED>
			<LOADING><x path="Int"/></LOADING>
			<HEADERS_RECEIVED><x path="Int"/></HEADERS_RECEIVED>
			<DONE><x path="Int"/></DONE>
		</a>
		<haxe_doc>* The XHR ready states, used internally.
 *
 * @static
 * @constant
 * @property {object} XHR_READY_STATE
 * @property {number} XHR_READY_STATE.UNSENT - open()has not been called yet.
 * @property {number} XHR_READY_STATE.OPENED - send()has not been called yet.
 * @property {number} XHR_READY_STATE.HEADERS_RECEIVED - send() has been called, and headers and status are available.
 * @property {number} XHR_READY_STATE.LOADING - Downloading; responseText holds partial data.
 * @property {number} XHR_READY_STATE.DONE - The operation is complete.</haxe_doc>
	</typedef>
	<typedef path="pixi.loaders.XHR_RESPONSE_TYPE" params="" file="C:\HaxeToolkit\haxe\lib\pixijs/3,0,25/pixi/loaders/Resource.hx" module="pixi.loaders.Resource">
		<a>
			<TEXT><c path="String"/></TEXT>
			<JSON><c path="String"/></JSON>
			<DOCUMENT><c path="String"/></DOCUMENT>
			<DEFAULT><c path="String"/></DEFAULT>
			<BUFFER><c path="String"/></BUFFER>
			<BLOB><c path="String"/></BLOB>
		</a>
		<haxe_doc>* The XHR ready states, used internally.
 *
 * @static
 * @constant
 * @property {object} XHR_RESPONSE_TYPE
 * @property {string} XHR_RESPONSE_TYPE.DEFAULT - defaults to text
 * @property {string} XHR_RESPONSE_TYPE.BUFFER - ArrayBuffer
 * @property {string} XHR_RESPONSE_TYPE.BLOB - Blob
 * @property {string} XHR_RESPONSE_TYPE.DOCUMENT - Document
 * @property {string} XHR_RESPONSE_TYPE.JSON - Object
 * @property {string} XHR_RESPONSE_TYPE.TEXT - String</haxe_doc>
	</typedef>
	<typedef path="pixi.loaders.ResourceObject" params="" file="C:\HaxeToolkit\haxe\lib\pixijs/3,0,25/pixi/loaders/ResourceLoader.hx" module="pixi.loaders.ResourceLoader"><a>
	<xhrType>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</xhrType>
	<url><c path="String"/></url>
	<name>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</name>
	<loadType>
		<t path="Null"><x path="Int"/></t>
		<meta><m n=":optional"/></meta>
	</loadType>
	<crossOrigin>
		<t path="Null"><d/></t>
		<meta><m n=":optional"/></meta>
	</crossOrigin>
	<callback>
		<t path="Null"><f a="">
	<c path="pixi.loaders.Resource"/>
	<x path="Void"/>
</f></t>
		<meta><m n=":optional"/></meta>
	</callback>
</a></typedef>
	<class path="webfont.WebFontLoader" params="" file="C:\HaxeToolkit\haxe\lib\WebFont/1,0,1/src/webfont/WebFontLoader.hx" extern="1">
		<load public="1" set="method" static="1"><f a="WebConfig">
	<d/>
	<x path="Void"/>
</f></load>
		<haxe_doc>* extern pour webfontloader
 * @author Maxime Lo Re</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":native"><e>"WebFont"</e></m>
		</meta>
	</class>
</haxe>